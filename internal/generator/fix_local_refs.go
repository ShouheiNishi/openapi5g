// Code generated by github.com/ShouheiNishi/openapi5g/internal/generator/sub, DO NOT EDIT.

package generator

import (
	"sort"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

type fixLocalRefIType struct {
	visited map[interface{}]struct{}
	doc     *openapi3.T
	rootUri string
}

func fixLocalRefInRemoteRef(d *openapi3.T, rootUri string) error {
	s := &fixLocalRefIType{
		visited: make(map[interface{}]struct{}),
		doc:     d,
	}

	s.rootUri = rootUri

	return s.walkT(s.doc, rootUri)
}

func (s *fixLocalRefIType) walkAdditionalProperties(v *openapi3.AdditionalProperties, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Schema != nil {
		if err := s.walkSchemaRef(v.Schema, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkCallback(v *openapi3.Callback, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	k0s0 := make([]string, 0, len(v.Map()))
	for k0 := range v.Map() {
		k0s0 = append(k0s0, k0)
	}
	sort.Strings(k0s0)
	for _, k0 := range k0s0 {
		if v.Map()[k0] != nil {
			if err := s.walkPathItem(v.Map()[k0], curUri); err != nil {
				return err
			}
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkCallbackRef(v *openapi3.CallbackRef, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Ref != "" {
		split := strings.SplitN(v.Ref, "#", 2)
		if len(split) == 2 {
			if split[0] != "" {
				curUri = split[0]
			}
			if curUri == s.rootUri {
				v.Ref = "#" + split[1]
			} else {
				v.Ref = curUri + "#" + split[1]
			}
		} else {
			curUri = split[0]
		}
	}

	if v.Value != nil {
		if err := s.walkCallback(v.Value, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkComponents(v *openapi3.Components, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	k0s0 := make([]string, 0, len(v.Callbacks))
	for k0 := range v.Callbacks {
		k0s0 = append(k0s0, k0)
	}
	sort.Strings(k0s0)
	for _, k0 := range k0s0 {
		if v.Callbacks[k0] != nil {
			if err := s.walkCallbackRef(v.Callbacks[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s1 := make([]string, 0, len(v.Examples))
	for k0 := range v.Examples {
		k0s1 = append(k0s1, k0)
	}
	sort.Strings(k0s1)
	for _, k0 := range k0s1 {
		if v.Examples[k0] != nil {
			if err := s.walkExampleRef(v.Examples[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s2 := make([]string, 0, len(v.Headers))
	for k0 := range v.Headers {
		k0s2 = append(k0s2, k0)
	}
	sort.Strings(k0s2)
	for _, k0 := range k0s2 {
		if v.Headers[k0] != nil {
			if err := s.walkHeaderRef(v.Headers[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s3 := make([]string, 0, len(v.Links))
	for k0 := range v.Links {
		k0s3 = append(k0s3, k0)
	}
	sort.Strings(k0s3)
	for _, k0 := range k0s3 {
		if v.Links[k0] != nil {
			if err := s.walkLinkRef(v.Links[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s4 := make([]string, 0, len(v.Parameters))
	for k0 := range v.Parameters {
		k0s4 = append(k0s4, k0)
	}
	sort.Strings(k0s4)
	for _, k0 := range k0s4 {
		if v.Parameters[k0] != nil {
			if err := s.walkParameterRef(v.Parameters[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s5 := make([]string, 0, len(v.RequestBodies))
	for k0 := range v.RequestBodies {
		k0s5 = append(k0s5, k0)
	}
	sort.Strings(k0s5)
	for _, k0 := range k0s5 {
		if v.RequestBodies[k0] != nil {
			if err := s.walkRequestBodyRef(v.RequestBodies[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s6 := make([]string, 0, len(v.Responses))
	for k0 := range v.Responses {
		k0s6 = append(k0s6, k0)
	}
	sort.Strings(k0s6)
	for _, k0 := range k0s6 {
		if v.Responses[k0] != nil {
			if err := s.walkResponseRef(v.Responses[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s7 := make([]string, 0, len(v.Schemas))
	for k0 := range v.Schemas {
		k0s7 = append(k0s7, k0)
	}
	sort.Strings(k0s7)
	for _, k0 := range k0s7 {
		if v.Schemas[k0] != nil {
			if err := s.walkSchemaRef(v.Schemas[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s8 := make([]string, 0, len(v.SecuritySchemes))
	for k0 := range v.SecuritySchemes {
		k0s8 = append(k0s8, k0)
	}
	sort.Strings(k0s8)
	for _, k0 := range k0s8 {
		if v.SecuritySchemes[k0] != nil {
			if err := s.walkSecuritySchemeRef(v.SecuritySchemes[k0], curUri); err != nil {
				return err
			}
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkEncoding(v *openapi3.Encoding, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	k0s3 := make([]string, 0, len(v.Headers))
	for k0 := range v.Headers {
		k0s3 = append(k0s3, k0)
	}
	sort.Strings(k0s3)
	for _, k0 := range k0s3 {
		if v.Headers[k0] != nil {
			if err := s.walkHeaderRef(v.Headers[k0], curUri); err != nil {
				return err
			}
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkExampleRef(v *openapi3.ExampleRef, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Ref != "" {
		split := strings.SplitN(v.Ref, "#", 2)
		if len(split) == 2 {
			if split[0] != "" {
				curUri = split[0]
			}
			if curUri == s.rootUri {
				v.Ref = "#" + split[1]
			} else {
				v.Ref = curUri + "#" + split[1]
			}
		} else {
			curUri = split[0]
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkHeader(v *openapi3.Header, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if err := s.walkParameter(&v.Parameter, curUri); err != nil {
		return err
	}

	return nil
}

func (s *fixLocalRefIType) walkHeaderRef(v *openapi3.HeaderRef, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Ref != "" {
		split := strings.SplitN(v.Ref, "#", 2)
		if len(split) == 2 {
			if split[0] != "" {
				curUri = split[0]
			}
			if curUri == s.rootUri {
				v.Ref = "#" + split[1]
			} else {
				v.Ref = curUri + "#" + split[1]
			}
		} else {
			curUri = split[0]
		}
	}

	if v.Value != nil {
		if err := s.walkHeader(v.Value, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkLinkRef(v *openapi3.LinkRef, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Ref != "" {
		split := strings.SplitN(v.Ref, "#", 2)
		if len(split) == 2 {
			if split[0] != "" {
				curUri = split[0]
			}
			if curUri == s.rootUri {
				v.Ref = "#" + split[1]
			} else {
				v.Ref = curUri + "#" + split[1]
			}
		} else {
			curUri = split[0]
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkMediaType(v *openapi3.MediaType, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	k0s0 := make([]string, 0, len(v.Encoding))
	for k0 := range v.Encoding {
		k0s0 = append(k0s0, k0)
	}
	sort.Strings(k0s0)
	for _, k0 := range k0s0 {
		if v.Encoding[k0] != nil {
			if err := s.walkEncoding(v.Encoding[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s1 := make([]string, 0, len(v.Examples))
	for k0 := range v.Examples {
		k0s1 = append(k0s1, k0)
	}
	sort.Strings(k0s1)
	for _, k0 := range k0s1 {
		if v.Examples[k0] != nil {
			if err := s.walkExampleRef(v.Examples[k0], curUri); err != nil {
				return err
			}
		}
	}

	if v.Schema != nil {
		if err := s.walkSchemaRef(v.Schema, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkOperation(v *openapi3.Operation, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	k0s0 := make([]string, 0, len(v.Callbacks))
	for k0 := range v.Callbacks {
		k0s0 = append(k0s0, k0)
	}
	sort.Strings(k0s0)
	for _, k0 := range k0s0 {
		if v.Callbacks[k0] != nil {
			if err := s.walkCallbackRef(v.Callbacks[k0], curUri); err != nil {
				return err
			}
		}
	}

	for i0 := range v.Parameters {
		if v.Parameters[i0] != nil {
			if err := s.walkParameterRef(v.Parameters[i0], curUri); err != nil {
				return err
			}
		}
	}

	if v.RequestBody != nil {
		if err := s.walkRequestBodyRef(v.RequestBody, curUri); err != nil {
			return err
		}
	}

	if v.Responses != nil {
		if err := s.walkResponses(v.Responses, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkParameter(v *openapi3.Parameter, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	k0s2 := make([]string, 0, len(v.Content))
	for k0 := range v.Content {
		k0s2 = append(k0s2, k0)
	}
	sort.Strings(k0s2)
	for _, k0 := range k0s2 {
		if v.Content[k0] != nil {
			if err := s.walkMediaType(v.Content[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s5 := make([]string, 0, len(v.Examples))
	for k0 := range v.Examples {
		k0s5 = append(k0s5, k0)
	}
	sort.Strings(k0s5)
	for _, k0 := range k0s5 {
		if v.Examples[k0] != nil {
			if err := s.walkExampleRef(v.Examples[k0], curUri); err != nil {
				return err
			}
		}
	}

	if v.Schema != nil {
		if err := s.walkSchemaRef(v.Schema, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkParameterRef(v *openapi3.ParameterRef, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Ref != "" {
		split := strings.SplitN(v.Ref, "#", 2)
		if len(split) == 2 {
			if split[0] != "" {
				curUri = split[0]
			}
			if curUri == s.rootUri {
				v.Ref = "#" + split[1]
			} else {
				v.Ref = curUri + "#" + split[1]
			}
		} else {
			curUri = split[0]
		}
	}

	if v.Value != nil {
		if err := s.walkParameter(v.Value, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkPathItem(v *openapi3.PathItem, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Ref != "" {
		split := strings.SplitN(v.Ref, "#", 2)
		if len(split) == 2 {
			if split[0] != "" {
				curUri = split[0]
			}
			if curUri == s.rootUri {
				v.Ref = "#" + split[1]
			} else {
				v.Ref = curUri + "#" + split[1]
			}
		} else {
			curUri = split[0]
		}
	}

	if v.Connect != nil {
		if err := s.walkOperation(v.Connect, curUri); err != nil {
			return err
		}
	}

	if v.Delete != nil {
		if err := s.walkOperation(v.Delete, curUri); err != nil {
			return err
		}
	}

	if v.Get != nil {
		if err := s.walkOperation(v.Get, curUri); err != nil {
			return err
		}
	}

	if v.Head != nil {
		if err := s.walkOperation(v.Head, curUri); err != nil {
			return err
		}
	}

	if v.Options != nil {
		if err := s.walkOperation(v.Options, curUri); err != nil {
			return err
		}
	}

	for i0 := range v.Parameters {
		if v.Parameters[i0] != nil {
			if err := s.walkParameterRef(v.Parameters[i0], curUri); err != nil {
				return err
			}
		}
	}

	if v.Patch != nil {
		if err := s.walkOperation(v.Patch, curUri); err != nil {
			return err
		}
	}

	if v.Post != nil {
		if err := s.walkOperation(v.Post, curUri); err != nil {
			return err
		}
	}

	if v.Put != nil {
		if err := s.walkOperation(v.Put, curUri); err != nil {
			return err
		}
	}

	if v.Trace != nil {
		if err := s.walkOperation(v.Trace, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkPaths(v *openapi3.Paths, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	k0s0 := make([]string, 0, len(v.Map()))
	for k0 := range v.Map() {
		k0s0 = append(k0s0, k0)
	}
	sort.Strings(k0s0)
	for _, k0 := range k0s0 {
		if v.Map()[k0] != nil {
			if err := s.walkPathItem(v.Map()[k0], curUri); err != nil {
				return err
			}
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkRequestBody(v *openapi3.RequestBody, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	k0s0 := make([]string, 0, len(v.Content))
	for k0 := range v.Content {
		k0s0 = append(k0s0, k0)
	}
	sort.Strings(k0s0)
	for _, k0 := range k0s0 {
		if v.Content[k0] != nil {
			if err := s.walkMediaType(v.Content[k0], curUri); err != nil {
				return err
			}
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkRequestBodyRef(v *openapi3.RequestBodyRef, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Ref != "" {
		split := strings.SplitN(v.Ref, "#", 2)
		if len(split) == 2 {
			if split[0] != "" {
				curUri = split[0]
			}
			if curUri == s.rootUri {
				v.Ref = "#" + split[1]
			} else {
				v.Ref = curUri + "#" + split[1]
			}
		} else {
			curUri = split[0]
		}
	}

	if v.Value != nil {
		if err := s.walkRequestBody(v.Value, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkResponse(v *openapi3.Response, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	k0s0 := make([]string, 0, len(v.Content))
	for k0 := range v.Content {
		k0s0 = append(k0s0, k0)
	}
	sort.Strings(k0s0)
	for _, k0 := range k0s0 {
		if v.Content[k0] != nil {
			if err := s.walkMediaType(v.Content[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s2 := make([]string, 0, len(v.Headers))
	for k0 := range v.Headers {
		k0s2 = append(k0s2, k0)
	}
	sort.Strings(k0s2)
	for _, k0 := range k0s2 {
		if v.Headers[k0] != nil {
			if err := s.walkHeaderRef(v.Headers[k0], curUri); err != nil {
				return err
			}
		}
	}

	k0s3 := make([]string, 0, len(v.Links))
	for k0 := range v.Links {
		k0s3 = append(k0s3, k0)
	}
	sort.Strings(k0s3)
	for _, k0 := range k0s3 {
		if v.Links[k0] != nil {
			if err := s.walkLinkRef(v.Links[k0], curUri); err != nil {
				return err
			}
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkResponseRef(v *openapi3.ResponseRef, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Ref != "" {
		split := strings.SplitN(v.Ref, "#", 2)
		if len(split) == 2 {
			if split[0] != "" {
				curUri = split[0]
			}
			if curUri == s.rootUri {
				v.Ref = "#" + split[1]
			} else {
				v.Ref = curUri + "#" + split[1]
			}
		} else {
			curUri = split[0]
		}
	}

	if v.Value != nil {
		if err := s.walkResponse(v.Value, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkResponses(v *openapi3.Responses, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	k0s0 := make([]string, 0, len(v.Map()))
	for k0 := range v.Map() {
		k0s0 = append(k0s0, k0)
	}
	sort.Strings(k0s0)
	for _, k0 := range k0s0 {
		if v.Map()[k0] != nil {
			if err := s.walkResponseRef(v.Map()[k0], curUri); err != nil {
				return err
			}
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkSchema(v *openapi3.Schema, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if err := s.walkAdditionalProperties(&v.AdditionalProperties, curUri); err != nil {
		return err
	}

	for i0 := range v.AllOf {
		if v.AllOf[i0] != nil {
			if err := s.walkSchemaRef(v.AllOf[i0], curUri); err != nil {
				return err
			}
		}
	}

	for i0 := range v.AnyOf {
		if v.AnyOf[i0] != nil {
			if err := s.walkSchemaRef(v.AnyOf[i0], curUri); err != nil {
				return err
			}
		}
	}

	if v.Items != nil {
		if err := s.walkSchemaRef(v.Items, curUri); err != nil {
			return err
		}
	}

	if v.Not != nil {
		if err := s.walkSchemaRef(v.Not, curUri); err != nil {
			return err
		}
	}

	for i0 := range v.OneOf {
		if v.OneOf[i0] != nil {
			if err := s.walkSchemaRef(v.OneOf[i0], curUri); err != nil {
				return err
			}
		}
	}

	k0s25 := make([]string, 0, len(v.Properties))
	for k0 := range v.Properties {
		k0s25 = append(k0s25, k0)
	}
	sort.Strings(k0s25)
	for _, k0 := range k0s25 {
		if v.Properties[k0] != nil {
			if err := s.walkSchemaRef(v.Properties[k0], curUri); err != nil {
				return err
			}
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkSchemaRef(v *openapi3.SchemaRef, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Ref != "" {
		split := strings.SplitN(v.Ref, "#", 2)
		if len(split) == 2 {
			if split[0] != "" {
				curUri = split[0]
			}
			if curUri == s.rootUri {
				v.Ref = "#" + split[1]
			} else {
				v.Ref = curUri + "#" + split[1]
			}
		} else {
			curUri = split[0]
		}
	}

	if v.Value != nil {
		if err := s.walkSchema(v.Value, curUri); err != nil {
			return err
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkSecuritySchemeRef(v *openapi3.SecuritySchemeRef, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Ref != "" {
		split := strings.SplitN(v.Ref, "#", 2)
		if len(split) == 2 {
			if split[0] != "" {
				curUri = split[0]
			}
			if curUri == s.rootUri {
				v.Ref = "#" + split[1]
			} else {
				v.Ref = curUri + "#" + split[1]
			}
		} else {
			curUri = split[0]
		}
	}

	return nil
}

func (s *fixLocalRefIType) walkT(v *openapi3.T, curUri string) error {
	if _, exist := s.visited[v]; exist {
		return nil
	}
	s.visited[v] = struct{}{}

	if v.Components != nil {
		if err := s.walkComponents(v.Components, curUri); err != nil {
			return err
		}
	}

	if v.Paths != nil {
		if err := s.walkPaths(v.Paths, curUri); err != nil {
			return err
		}
	}

	return nil
}
