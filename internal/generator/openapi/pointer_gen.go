// Code generated by github.com/ShouheiNishi/openapi5g/internal/generator/openapi/pointer/generator.go, DO NOT EDIT.

package openapi

import (
	"errors"
	"fmt"
	"strconv"
)

func (s *APIKeySecurityScheme) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "in":
		if len(p) == 1 {
			return s.In, nil
		} else {
			return nil, errors.New("cannot traverse type openapi.APIKeySecuritySchemeIn")
		}
	case "name":
		if len(p) == 1 {
			return s.Name, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "type":
		if len(p) == 1 {
			return s.Type, nil
		} else {
			return nil, errors.New("cannot traverse type openapi.APIKeySecuritySchemeType")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *AuthorizationCodeOAuthFlow) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "authorizationUrl":
		if len(p) == 1 {
			return s.AuthorizationUrl, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "refreshUrl":
		if len(p) == 1 {
			return s.RefreshUrl, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "scopes":
		if len(p) == 1 {
			return s.Scopes, nil
		} else if _, exist := s.Scopes[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Scopes[p[1]], nil
		} else {
			return nil, errors.New("cannot traverse type map[string]string")
		}
	case "tokenUrl":
		if len(p) == 1 {
			return s.TokenUrl, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *ClientCredentialsFlow) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "refreshUrl":
		if len(p) == 1 {
			return s.RefreshUrl, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "scopes":
		if len(p) == 1 {
			return s.Scopes, nil
		} else if _, exist := s.Scopes[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Scopes[p[1]], nil
		} else {
			return nil, errors.New("cannot traverse type map[string]string")
		}
	case "tokenUrl":
		if len(p) == 1 {
			return s.TokenUrl, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Components) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "callbacks":
		if len(p) == 1 {
			return s.Callbacks, nil
		} else if _, exist := s.Callbacks[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Callbacks[p[1]], nil
		} else if s.Callbacks[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Callbacks[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "examples":
		if len(p) == 1 {
			return s.Examples, nil
		} else if _, exist := s.Examples[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Examples[p[1]], nil
		} else if s.Examples[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Examples[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "headers":
		if len(p) == 1 {
			return s.Headers, nil
		} else if _, exist := s.Headers[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Headers[p[1]], nil
		} else if s.Headers[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Headers[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "links":
		if len(p) == 1 {
			return s.Links, nil
		} else if _, exist := s.Links[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Links[p[1]], nil
		} else if s.Links[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Links[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "parameters":
		if len(p) == 1 {
			return s.Parameters, nil
		} else if _, exist := s.Parameters[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Parameters[p[1]], nil
		} else if s.Parameters[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Parameters[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "requestBodies":
		if len(p) == 1 {
			return s.RequestBodies, nil
		} else if _, exist := s.RequestBodies[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.RequestBodies[p[1]], nil
		} else if s.RequestBodies[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.RequestBodies[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "responses":
		if len(p) == 1 {
			return s.Responses, nil
		} else if _, exist := s.Responses[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Responses[p[1]], nil
		} else if s.Responses[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Responses[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "schemas":
		if len(p) == 1 {
			return s.Schemas, nil
		} else if _, exist := s.Schemas[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Schemas[p[1]], nil
		} else if s.Schemas[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Schemas[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "securitySchemes":
		if len(p) == 1 {
			return s.SecuritySchemes, nil
		} else if _, exist := s.SecuritySchemes[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.SecuritySchemes[p[1]], nil
		} else if s.SecuritySchemes[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.SecuritySchemes[p[1]].GetFromJsonPointerSub(p[2:])
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Contact) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "email":
		if len(p) == 1 {
			return s.Email, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	case "name":
		if len(p) == 1 {
			return s.Name, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	case "url":
		if len(p) == 1 {
			return s.Url, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Discriminator) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "mapping":
		if len(p) == 1 {
			return s.Mapping, nil
		} else if _, exist := s.Mapping[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Mapping[p[1]], nil
		} else {
			return nil, errors.New("cannot traverse type map[string]string")
		}
	case "propertyName":
		if len(p) == 1 {
			return s.PropertyName, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Document) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "components":
		if len(p) == 1 {
			return s.Components, nil
		} else if s.Components == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Components.GetFromJsonPointerSub(p[1:])
		}
	case "externalDocs":
		if len(p) == 1 {
			return s.ExternalDocs, nil
		} else if s.ExternalDocs == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.ExternalDocs.GetFromJsonPointerSub(p[1:])
		}
	case "info":
		if len(p) == 1 {
			return s.Info, nil
		} else {
			return s.Info.GetFromJsonPointerSub(p[1:])
		}
	case "openapi":
		if len(p) == 1 {
			return s.Openapi, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "paths":
		if len(p) == 1 {
			return s.Paths, nil
		} else if _, exist := s.Paths[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Paths[p[1]], nil
		} else if s.Paths[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Paths[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "security":
		if len(p) == 1 {
			return s.Security, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Security) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Security), i1)
		} else if len(p) == 2 {
			return s.Security[i1], nil
		} else if _, exist := s.Security[i1][p[2]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[2])
		} else if len(p) == 3 {
			return s.Security[i1][p[2]], nil
		} else if i3, err := strconv.Atoi(p[3]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[3])
		} else if i3 < 0 || i3 >= len(s.Security[i1][p[2]]) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Security[i1][p[2]]), i3)
		} else if len(p) == 4 {
			return s.Security[i1][p[2]][i3], nil
		} else {
			return nil, errors.New("cannot traverse type []map[string][]string")
		}
	case "servers":
		if len(p) == 1 {
			return s.Servers, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Servers) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Servers), i1)
		} else if len(p) == 2 {
			return s.Servers[i1], nil
		} else {
			return s.Servers[i1].GetFromJsonPointerSub(p[2:])
		}
	case "tags":
		if len(p) == 1 {
			return s.Tags, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Tags) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Tags), i1)
		} else if len(p) == 2 {
			return s.Tags[i1], nil
		} else {
			return s.Tags[i1].GetFromJsonPointerSub(p[2:])
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Encoding) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "allowReserved":
		if len(p) == 1 {
			return s.AllowReserved, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "contentType":
		if len(p) == 1 {
			return s.ContentType, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "explode":
		if len(p) == 1 {
			return s.Explode, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "headers":
		if len(p) == 1 {
			return s.Headers, nil
		} else if _, exist := s.Headers[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Headers[p[1]], nil
		} else if s.Headers[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Headers[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "style":
		if len(p) == 1 {
			return s.Style, nil
		} else {
			return nil, errors.New("cannot traverse type *openapi.EncodingStyle")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Example) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "externalValue":
		if len(p) == 1 {
			return s.ExternalValue, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "summary":
		if len(p) == 1 {
			return s.Summary, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "value":
		if len(p) == 1 {
			return s.Value, nil
		} else {
			return nil, errors.New("cannot traverse type yaml.Node")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *ExternalDocumentation) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	case "url":
		if len(p) == 1 {
			return s.Url, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *GoTypeImport) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "name":
		if len(p) == 1 {
			return s.Name, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "path":
		if len(p) == 1 {
			return s.Path, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *HTTPSecurityScheme) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "bearerFormat":
		if len(p) == 1 {
			return s.BearerFormat, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "scheme":
		if len(p) == 1 {
			return s.Scheme, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "type":
		if len(p) == 1 {
			return s.Type, nil
		} else {
			return nil, errors.New("cannot traverse type openapi.HTTPSecuritySchemeType")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Header) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "allowEmptyValue":
		if len(p) == 1 {
			return s.AllowEmptyValue, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "allowReserved":
		if len(p) == 1 {
			return s.AllowReserved, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "content":
		if len(p) == 1 {
			return s.Content, nil
		} else if _, exist := s.Content[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Content[p[1]], nil
		} else if s.Content[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Content[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "deprecated":
		if len(p) == 1 {
			return s.Deprecated, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "example":
		if len(p) == 1 {
			return s.Example, nil
		} else {
			return nil, errors.New("cannot traverse type yaml.Node")
		}
	case "examples":
		if len(p) == 1 {
			return s.Examples, nil
		} else if _, exist := s.Examples[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Examples[p[1]], nil
		} else if s.Examples[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Examples[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "explode":
		if len(p) == 1 {
			return s.Explode, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "required":
		if len(p) == 1 {
			return s.Required, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "schema":
		if len(p) == 1 {
			return s.Schema, nil
		} else {
			return s.Schema.GetFromJsonPointerSub(p[1:])
		}
	case "style":
		if len(p) == 1 {
			return s.Style, nil
		} else {
			return nil, errors.New("cannot traverse type openapi.HeaderStyle")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *ImplicitOAuthFlow) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "authorizationUrl":
		if len(p) == 1 {
			return s.AuthorizationUrl, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "refreshUrl":
		if len(p) == 1 {
			return s.RefreshUrl, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "scopes":
		if len(p) == 1 {
			return s.Scopes, nil
		} else if _, exist := s.Scopes[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Scopes[p[1]], nil
		} else {
			return nil, errors.New("cannot traverse type map[string]string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Info) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "contact":
		if len(p) == 1 {
			return s.Contact, nil
		} else if s.Contact == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Contact.GetFromJsonPointerSub(p[1:])
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	case "license":
		if len(p) == 1 {
			return s.License, nil
		} else if s.License == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.License.GetFromJsonPointerSub(p[1:])
		}
	case "termsOfService":
		if len(p) == 1 {
			return s.TermsOfService, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	case "title":
		if len(p) == 1 {
			return s.Title, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "version":
		if len(p) == 1 {
			return s.Version, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *License) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "name":
		if len(p) == 1 {
			return s.Name, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "url":
		if len(p) == 1 {
			return s.Url, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Link) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "operationId":
		if len(p) == 1 {
			return s.OperationId, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "operationRef":
		if len(p) == 1 {
			return s.OperationRef, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "parameters":
		if len(p) == 1 {
			return s.Parameters, nil
		} else if _, exist := s.Parameters[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Parameters[p[1]], nil
		} else {
			return nil, errors.New("cannot traverse type map[string]yaml.Node")
		}
	case "requestBody":
		if len(p) == 1 {
			return s.RequestBody, nil
		} else {
			return nil, errors.New("cannot traverse type yaml.Node")
		}
	case "server":
		if len(p) == 1 {
			return s.Server, nil
		} else if s.Server == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Server.GetFromJsonPointerSub(p[1:])
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *MediaType) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "encoding":
		if len(p) == 1 {
			return s.Encoding, nil
		} else if _, exist := s.Encoding[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Encoding[p[1]], nil
		} else if s.Encoding[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Encoding[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "example":
		if len(p) == 1 {
			return s.Example, nil
		} else {
			return nil, errors.New("cannot traverse type yaml.Node")
		}
	case "examples":
		if len(p) == 1 {
			return s.Examples, nil
		} else if _, exist := s.Examples[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Examples[p[1]], nil
		} else if s.Examples[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Examples[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "schema":
		if len(p) == 1 {
			return s.Schema, nil
		} else {
			return s.Schema.GetFromJsonPointerSub(p[1:])
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *OAuth2SecurityScheme) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "flows":
		if len(p) == 1 {
			return s.Flows, nil
		} else {
			return s.Flows.GetFromJsonPointerSub(p[1:])
		}
	case "type":
		if len(p) == 1 {
			return s.Type, nil
		} else {
			return nil, errors.New("cannot traverse type openapi.OAuth2SecuritySchemeType")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *OAuthFlows) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "authorizationCode":
		if len(p) == 1 {
			return s.AuthorizationCode, nil
		} else if s.AuthorizationCode == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.AuthorizationCode.GetFromJsonPointerSub(p[1:])
		}
	case "clientCredentials":
		if len(p) == 1 {
			return s.ClientCredentials, nil
		} else if s.ClientCredentials == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.ClientCredentials.GetFromJsonPointerSub(p[1:])
		}
	case "implicit":
		if len(p) == 1 {
			return s.Implicit, nil
		} else if s.Implicit == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Implicit.GetFromJsonPointerSub(p[1:])
		}
	case "password":
		if len(p) == 1 {
			return s.Password, nil
		} else if s.Password == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Password.GetFromJsonPointerSub(p[1:])
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *OpenIdConnectSecurityScheme) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "openIdConnectUrl":
		if len(p) == 1 {
			return s.OpenIdConnectUrl, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "type":
		if len(p) == 1 {
			return s.Type, nil
		} else {
			return nil, errors.New("cannot traverse type openapi.OpenIdConnectSecuritySchemeType")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Operation) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "callbacks":
		if len(p) == 1 {
			return s.Callbacks, nil
		} else if _, exist := s.Callbacks[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Callbacks[p[1]], nil
		} else if s.Callbacks[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Callbacks[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "deprecated":
		if len(p) == 1 {
			return s.Deprecated, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "externalDocs":
		if len(p) == 1 {
			return s.ExternalDocs, nil
		} else if s.ExternalDocs == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.ExternalDocs.GetFromJsonPointerSub(p[1:])
		}
	case "operationId":
		if len(p) == 1 {
			return s.OperationId, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "parameters":
		if len(p) == 1 {
			return s.Parameters, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Parameters) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Parameters), i1)
		} else if len(p) == 2 {
			return s.Parameters[i1], nil
		} else {
			return s.Parameters[i1].GetFromJsonPointerSub(p[2:])
		}
	case "requestBody":
		if len(p) == 1 {
			return s.RequestBody, nil
		} else {
			return s.RequestBody.GetFromJsonPointerSub(p[1:])
		}
	case "responses":
		if len(p) == 1 {
			return s.Responses, nil
		} else if _, exist := s.Responses[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Responses[p[1]], nil
		} else if s.Responses[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Responses[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "security":
		if len(p) == 1 {
			return s.Security, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Security) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Security), i1)
		} else if len(p) == 2 {
			return s.Security[i1], nil
		} else if _, exist := s.Security[i1][p[2]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[2])
		} else if len(p) == 3 {
			return s.Security[i1][p[2]], nil
		} else if i3, err := strconv.Atoi(p[3]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[3])
		} else if i3 < 0 || i3 >= len(s.Security[i1][p[2]]) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Security[i1][p[2]]), i3)
		} else if len(p) == 4 {
			return s.Security[i1][p[2]][i3], nil
		} else {
			return nil, errors.New("cannot traverse type []map[string][]string")
		}
	case "servers":
		if len(p) == 1 {
			return s.Servers, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Servers) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Servers), i1)
		} else if len(p) == 2 {
			return s.Servers[i1], nil
		} else {
			return s.Servers[i1].GetFromJsonPointerSub(p[2:])
		}
	case "summary":
		if len(p) == 1 {
			return s.Summary, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "tags":
		if len(p) == 1 {
			return s.Tags, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Tags) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Tags), i1)
		} else if len(p) == 2 {
			return s.Tags[i1], nil
		} else {
			return nil, errors.New("cannot traverse type []string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Parameter) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "allowEmptyValue":
		if len(p) == 1 {
			return s.AllowEmptyValue, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "allowReserved":
		if len(p) == 1 {
			return s.AllowReserved, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "content":
		if len(p) == 1 {
			return s.Content, nil
		} else if _, exist := s.Content[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Content[p[1]], nil
		} else if s.Content[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Content[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "deprecated":
		if len(p) == 1 {
			return s.Deprecated, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "example":
		if len(p) == 1 {
			return s.Example, nil
		} else {
			return nil, errors.New("cannot traverse type yaml.Node")
		}
	case "examples":
		if len(p) == 1 {
			return s.Examples, nil
		} else if _, exist := s.Examples[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Examples[p[1]], nil
		} else if s.Examples[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Examples[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "explode":
		if len(p) == 1 {
			return s.Explode, nil
		} else {
			return nil, errors.New("cannot traverse type *bool")
		}
	case "in":
		if len(p) == 1 {
			return s.In, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "name":
		if len(p) == 1 {
			return s.Name, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "required":
		if len(p) == 1 {
			return s.Required, nil
		} else {
			return nil, errors.New("cannot traverse type *bool")
		}
	case "schema":
		if len(p) == 1 {
			return s.Schema, nil
		} else {
			return s.Schema.GetFromJsonPointerSub(p[1:])
		}
	case "style":
		if len(p) == 1 {
			return s.Style, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "x-go-name":
		if len(p) == 1 {
			return s.GoName, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *PasswordOAuthFlow) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "refreshUrl":
		if len(p) == 1 {
			return s.RefreshUrl, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "scopes":
		if len(p) == 1 {
			return s.Scopes, nil
		} else if _, exist := s.Scopes[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Scopes[p[1]], nil
		} else {
			return nil, errors.New("cannot traverse type map[string]string")
		}
	case "tokenUrl":
		if len(p) == 1 {
			return s.TokenUrl, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *PathItemBase) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "delete":
		if len(p) == 1 {
			return s.Delete, nil
		} else if s.Delete == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Delete.GetFromJsonPointerSub(p[1:])
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "get":
		if len(p) == 1 {
			return s.Get, nil
		} else if s.Get == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Get.GetFromJsonPointerSub(p[1:])
		}
	case "head":
		if len(p) == 1 {
			return s.Head, nil
		} else if s.Head == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Head.GetFromJsonPointerSub(p[1:])
		}
	case "options":
		if len(p) == 1 {
			return s.Options, nil
		} else if s.Options == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Options.GetFromJsonPointerSub(p[1:])
		}
	case "parameters":
		if len(p) == 1 {
			return s.Parameters, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Parameters) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Parameters), i1)
		} else if len(p) == 2 {
			return s.Parameters[i1], nil
		} else {
			return s.Parameters[i1].GetFromJsonPointerSub(p[2:])
		}
	case "patch":
		if len(p) == 1 {
			return s.Patch, nil
		} else if s.Patch == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Patch.GetFromJsonPointerSub(p[1:])
		}
	case "post":
		if len(p) == 1 {
			return s.Post, nil
		} else if s.Post == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Post.GetFromJsonPointerSub(p[1:])
		}
	case "put":
		if len(p) == 1 {
			return s.Put, nil
		} else if s.Put == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Put.GetFromJsonPointerSub(p[1:])
		}
	case "servers":
		if len(p) == 1 {
			return s.Servers, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Servers) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Servers), i1)
		} else if len(p) == 2 {
			return s.Servers[i1], nil
		} else {
			return s.Servers[i1].GetFromJsonPointerSub(p[2:])
		}
	case "summary":
		if len(p) == 1 {
			return s.Summary, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "trace":
		if len(p) == 1 {
			return s.Trace, nil
		} else if s.Trace == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Trace.GetFromJsonPointerSub(p[1:])
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Reference) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "Path":
		if len(p) == 1 {
			return s.Path, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "Pointer":
		if len(p) == 1 {
			return s.Pointer, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *RequestBody) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "content":
		if len(p) == 1 {
			return s.Content, nil
		} else if _, exist := s.Content[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Content[p[1]], nil
		} else if s.Content[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Content[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "required":
		if len(p) == 1 {
			return s.Required, nil
		} else {
			return nil, errors.New("cannot traverse type *bool")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Response) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "content":
		if len(p) == 1 {
			return s.Content, nil
		} else if _, exist := s.Content[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Content[p[1]], nil
		} else if s.Content[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Content[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "headers":
		if len(p) == 1 {
			return s.Headers, nil
		} else if _, exist := s.Headers[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Headers[p[1]], nil
		} else if s.Headers[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Headers[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "links":
		if len(p) == 1 {
			return s.Links, nil
		} else if _, exist := s.Links[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Links[p[1]], nil
		} else if s.Links[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Links[p[1]].GetFromJsonPointerSub(p[2:])
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Schema) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "additionalProperties":
		if len(p) == 1 {
			return s.AdditionalProperties, nil
		} else {
			return s.AdditionalProperties.GetFromJsonPointerSub(p[1:])
		}
	case "allOf":
		if len(p) == 1 {
			return s.AllOf, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.AllOf) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.AllOf), i1)
		} else if len(p) == 2 {
			return s.AllOf[i1], nil
		} else {
			return s.AllOf[i1].GetFromJsonPointerSub(p[2:])
		}
	case "anyOf":
		if len(p) == 1 {
			return s.AnyOf, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.AnyOf) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.AnyOf), i1)
		} else if len(p) == 2 {
			return s.AnyOf[i1], nil
		} else {
			return s.AnyOf[i1].GetFromJsonPointerSub(p[2:])
		}
	case "default":
		if len(p) == 1 {
			return s.Default, nil
		} else {
			return nil, errors.New("cannot traverse type yaml.Node")
		}
	case "deprecated":
		if len(p) == 1 {
			return s.Deprecated, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "discriminator":
		if len(p) == 1 {
			return s.Discriminator, nil
		} else if s.Discriminator == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Discriminator.GetFromJsonPointerSub(p[1:])
		}
	case "enum":
		if len(p) == 1 {
			return s.Enum, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Enum) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Enum), i1)
		} else if len(p) == 2 {
			return s.Enum[i1], nil
		} else {
			return nil, errors.New("cannot traverse type []yaml.Node")
		}
	case "example":
		if len(p) == 1 {
			return s.Example, nil
		} else {
			return nil, errors.New("cannot traverse type yaml.Node")
		}
	case "exclusiveMaximum":
		if len(p) == 1 {
			return s.ExclusiveMaximum, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "exclusiveMinimum":
		if len(p) == 1 {
			return s.ExclusiveMinimum, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "externalDocs":
		if len(p) == 1 {
			return s.ExternalDocs, nil
		} else if s.ExternalDocs == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.ExternalDocs.GetFromJsonPointerSub(p[1:])
		}
	case "format":
		if len(p) == 1 {
			return s.Format, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "items":
		if len(p) == 1 {
			return s.Items, nil
		} else {
			return s.Items.GetFromJsonPointerSub(p[1:])
		}
	case "maxItems":
		if len(p) == 1 {
			return s.MaxItems, nil
		} else {
			return nil, errors.New("cannot traverse type int")
		}
	case "maxLength":
		if len(p) == 1 {
			return s.MaxLength, nil
		} else {
			return nil, errors.New("cannot traverse type int")
		}
	case "maxProperties":
		if len(p) == 1 {
			return s.MaxProperties, nil
		} else {
			return nil, errors.New("cannot traverse type int")
		}
	case "maximum":
		if len(p) == 1 {
			return s.Maximum, nil
		} else {
			return nil, errors.New("cannot traverse type any")
		}
	case "minItems":
		if len(p) == 1 {
			return s.MinItems, nil
		} else {
			return nil, errors.New("cannot traverse type *int")
		}
	case "minLength":
		if len(p) == 1 {
			return s.MinLength, nil
		} else {
			return nil, errors.New("cannot traverse type int")
		}
	case "minProperties":
		if len(p) == 1 {
			return s.MinProperties, nil
		} else {
			return nil, errors.New("cannot traverse type *int")
		}
	case "minimum":
		if len(p) == 1 {
			return s.Minimum, nil
		} else {
			return nil, errors.New("cannot traverse type any")
		}
	case "multipleOf":
		if len(p) == 1 {
			return s.MultipleOf, nil
		} else {
			return nil, errors.New("cannot traverse type *float64")
		}
	case "not":
		if len(p) == 1 {
			return s.Not, nil
		} else {
			return s.Not.GetFromJsonPointerSub(p[1:])
		}
	case "nullable":
		if len(p) == 1 {
			return s.Nullable, nil
		} else {
			return nil, errors.New("cannot traverse type *bool")
		}
	case "oneOf":
		if len(p) == 1 {
			return s.OneOf, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.OneOf) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.OneOf), i1)
		} else if len(p) == 2 {
			return s.OneOf[i1], nil
		} else {
			return s.OneOf[i1].GetFromJsonPointerSub(p[2:])
		}
	case "pattern":
		if len(p) == 1 {
			return s.Pattern, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "properties":
		if len(p) == 1 {
			return s.Properties, nil
		} else if _, exist := s.Properties[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Properties[p[1]], nil
		} else if s.Properties[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Properties[p[1]].GetFromJsonPointerSub(p[2:])
		}
	case "readOnly":
		if len(p) == 1 {
			return s.ReadOnly, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "required":
		if len(p) == 1 {
			return s.Required, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Required) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Required), i1)
		} else if len(p) == 2 {
			return s.Required[i1], nil
		} else {
			return nil, errors.New("cannot traverse type []string")
		}
	case "title":
		if len(p) == 1 {
			return s.Title, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "type":
		if len(p) == 1 {
			return s.Type, nil
		} else {
			return nil, errors.New("cannot traverse type *openapi.SchemaType")
		}
	case "uniqueItems":
		if len(p) == 1 {
			return s.UniqueItems, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "writeOnly":
		if len(p) == 1 {
			return s.WriteOnly, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "x-go-type":
		if len(p) == 1 {
			return s.GoType, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "x-go-type-import":
		if len(p) == 1 {
			return s.GoTypeImport, nil
		} else if s.GoTypeImport == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.GoTypeImport.GetFromJsonPointerSub(p[1:])
		}
	case "x-go-type-skip-optional-pointer":
		if len(p) == 1 {
			return s.GoTypeSkipOptionalPointer, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "xml":
		if len(p) == 1 {
			return s.Xml, nil
		} else if s.Xml == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Xml.GetFromJsonPointerSub(p[1:])
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Server) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "url":
		if len(p) == 1 {
			return s.Url, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "variables":
		if len(p) == 1 {
			return s.Variables, nil
		} else if _, exist := s.Variables[p[1]]; !exist {
			return nil, fmt.Errorf("key %s is not exist", p[1])
		} else if len(p) == 2 {
			return s.Variables[p[1]], nil
		} else if s.Variables[p[1]] == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.Variables[p[1]].GetFromJsonPointerSub(p[2:])
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *ServerVariable) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "default":
		if len(p) == 1 {
			return s.Default, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	case "enum":
		if len(p) == 1 {
			return s.Enum, nil
		} else if i1, err := strconv.Atoi(p[1]); err != nil {
			return nil, fmt.Errorf("invalid index %s", p[1])
		} else if i1 < 0 || i1 >= len(s.Enum) {
			return nil, fmt.Errorf("invalid index: length = %d, index = %d", len(s.Enum), i1)
		} else if len(p) == 2 {
			return s.Enum[i1], nil
		} else {
			return nil, errors.New("cannot traverse type []string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *Tag) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "externalDocs":
		if len(p) == 1 {
			return s.ExternalDocs, nil
		} else if s.ExternalDocs == nil {
			return nil, errors.New("cannot traverse nil pointer")
		} else {
			return s.ExternalDocs.GetFromJsonPointerSub(p[1:])
		}
	case "name":
		if len(p) == 1 {
			return s.Name, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *XML) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "attribute":
		if len(p) == 1 {
			return s.Attribute, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	case "name":
		if len(p) == 1 {
			return s.Name, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	case "namespace":
		if len(p) == 1 {
			return s.Namespace, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	case "prefix":
		if len(p) == 1 {
			return s.Prefix, nil
		} else {
			return nil, errors.New("cannot traverse type *string")
		}
	case "wrapped":
		if len(p) == 1 {
			return s.Wrapped, nil
		} else {
			return nil, errors.New("cannot traverse type bool")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}

func (s *baseRef) GetFromJsonPointerSub(p jsonPointer) (any, error) {
	switch p[0] {
	case "$ref":
		if len(p) == 1 {
			return s.Ref, nil
		} else {
			return s.Ref.GetFromJsonPointerSub(p[1:])
		}
	case "description":
		if len(p) == 1 {
			return s.Description, nil
		} else {
			return nil, errors.New("cannot traverse type string")
		}
	case "minItems":
		if len(p) == 1 {
			return s.MinItems, nil
		} else {
			return nil, errors.New("cannot traverse type int")
		}
	default:
		return nil, fmt.Errorf("unknown entry %s", p[0])
	}
}
