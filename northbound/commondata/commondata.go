// Package commondata provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.1-0.20240123090344-d326c01d279a DO NOT EDIT.
package commondata

import (
	"encoding/json"
	"fmt"
)

// Defines values for Event.
const (
	FAILEDRESOURCESALLOCATION Event = "FAILED_RESOURCES_ALLOCATION"
	LOSSOFBEARER              Event = "LOSS_OF_BEARER"
	RECOVERYOFBEARER          Event = "RECOVERY_OF_BEARER"
	RELEASEOFBEARER           Event = "RELEASE_OF_BEARER"
	SESSIONTERMINATION        Event = "SESSION_TERMINATION"
	USAGEREPORT               Event = "USAGE_REPORT"
)

// Defines values for ResultReason.
const (
	OTHERREASON       ResultReason = "OTHER_REASON"
	ROAMINGNOTALLOWED ResultReason = "ROAMING_NOT_ALLOWED"
)

// AccumulatedUsage defines model for AccumulatedUsage.
type AccumulatedUsage struct {
	// DownlinkVolume Unsigned integer identifying a volume in units of bytes.
	DownlinkVolume *Volume `json:"downlinkVolume,omitempty"`

	// Duration Unsigned integer identifying a period of time in units of seconds.
	Duration *DurationSec `json:"duration,omitempty"`

	// TotalVolume Unsigned integer identifying a volume in units of bytes.
	TotalVolume *Volume `json:"totalVolume,omitempty"`

	// UplinkVolume Unsigned integer identifying a volume in units of bytes.
	UplinkVolume         *Volume                `json:"uplinkVolume,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Acknowledgement defines model for Acknowledgement.
type Acknowledgement struct {
	// Details A human-readable explanation specific to this successful acknowledgement
	Details              string                 `json:"details"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Bandwidth integer indicating a bandwidth in bits per second.
type Bandwidth = int

// BdtReferenceId string identifying a BDT Reference ID as defined in subclause 5.3.3 of 3GPP TS 29.154.
type BdtReferenceId = string

// BdtReferenceIdRm This data type is defined in the same way as the BdtReferenceId data type, but with the nullable property set to true.
type BdtReferenceIdRm = string

// Binary string with format "binary" as defined in OpenAPI Specification.
type Binary = string

// Bytes String with format "byte" as defined in OpenAPI Specification, i.e, base64-encoded characters.
type Bytes = string

// ConfigResult defines model for ConfigResult.
type ConfigResult struct {
	// ExternalIds Each element indicates an external identifier of the UE.
	ExternalIds []ExternalId `json:"externalIds,omitempty"`

	// Msisdns Each element identifies the MS internal PSTN/ISDN number allocated for the UE.
	Msisdns []Msisdn `json:"msisdns,omitempty"`

	// ResultReason Possible values are - ROAMING_NOT_ALLOWED: Identifies the configuration parameters are not allowed by roaming agreement. - OTHER_REASON: Identifies the configuration parameters are not configured due to other reason.
	ResultReason         ResultReason           `json:"resultReason"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DateTime string with format "date-time" as defined in OpenAPI.
type DateTime = string

// DateTimeRm string with format "date-time" as defined in OpenAPI with "nullable=true" property.
type DateTimeRm = string

// DateTimeRo string with format "date-time" as defined in OpenAPI with "readOnly=true" property.
type DateTimeRo = string

// DayOfWeek integer between and including 1 and 7 denoting a weekday. 1 shall indicate Monday, and the subsequent weekdays shall be indicated with the next higher numbers. 7 shall indicate Sunday.
type DayOfWeek = int

// DurationMin Unsigned integer identifying a period of time in units of minutes.
type DurationMin = int32

// DurationSec Unsigned integer identifying a period of time in units of seconds.
type DurationSec = int

// DurationSecRm Unsigned integer identifying a period of time in units of seconds with "nullable=true" property.
type DurationSecRm = int

// DurationSecRo Unsigned integer identifying a period of time in units of seconds with "readOnly=true" property.
type DurationSecRo = int

// Event Possible values are - SESSION_TERMINATION: Indicates that Rx session is terminated. - LOSS_OF_BEARER : Indicates a loss of a bearer. - RECOVERY_OF_BEARER: Indicates a recovery of a bearer. - RELEASE_OF_BEARER: Indicates a release of a bearer. - USAGE_REPORT: Indicates the usage report event.  - FAILED_RESOURCES_ALLOCATION: Indicates the resource allocation is failed.
type Event string

// EventReport defines model for EventReport.
type EventReport struct {
	AccumulatedUsage *AccumulatedUsage `json:"accumulatedUsage,omitempty"`

	// Event Possible values are - SESSION_TERMINATION: Indicates that Rx session is terminated. - LOSS_OF_BEARER : Indicates a loss of a bearer. - RECOVERY_OF_BEARER: Indicates a recovery of a bearer. - RELEASE_OF_BEARER: Indicates a release of a bearer. - USAGE_REPORT: Indicates the usage report event.  - FAILED_RESOURCES_ALLOCATION: Indicates the resource allocation is failed.
	Event Event `json:"event"`

	// FlowIds Identifies the IP flows that were sent during event subscription
	FlowIds              []int                  `json:"flowIds,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ExternalGroupId string containing a local identifier followed by "@" and a domain identifier. Both the local identifier and the domain identifier shall be encoded as strings that do not contain any "@" characters. See Clauses 4.6.2 and 4.6.3 of 3GPP TS 23.682 for more information.
type ExternalGroupId = string

// ExternalId string containing a local identifier followed by "@" and a domain identifier. Both the local identifier and the domain identifier shall be encoded as strings that do not contain any "@" characters. See Clause 4.6.2 of 3GPP TS 23.682 for more information.
type ExternalId = string

// FlowInfo defines model for FlowInfo.
type FlowInfo struct {
	// FlowDescriptions Indicates the packet filters of the IP flow. Refer to subclause 5.3.8 of 3GPP TS 29.214 for encoding. It shall contain UL and/or DL IP flow description.
	FlowDescriptions []string `json:"flowDescriptions,omitempty"`

	// FlowId Indicates the IP flow.
	FlowId               int                    `json:"flowId"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// InvalidParam defines model for InvalidParam.
type InvalidParam struct {
	// Param Attribute's name encoded as a JSON Pointer, or header's name.
	Param string `json:"param"`

	// Reason A human-readable reason, e.g. "must be a positive integer".
	Reason               *string                `json:"reason,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Ipv4Addr string identifying a Ipv4 address formatted in the "dotted decimal" notation as defined in IETF RFC 1166.
type Ipv4Addr = string

// Ipv4AddrRo string identifying a Ipv4 address formatted in the "dotted decimal" notation as defined in IETF RFC 1166, with "readOnly=true" property.
type Ipv4AddrRo = string

// Ipv6Addr string identifying a Ipv6 address formatted according to clause 4 in IETF RFC 5952. The mixed Ipv4 Ipv6 notation according to clause 5 of IETF RFC 5952 shall not be used.
type Ipv6Addr = string

// Ipv6AddrRo string identifying a Ipv6 address formatted according to clause 4 in IETF RFC 5952, with "readOnly=true" property. The mixed Ipv4 Ipv6 notation according to clause 5 of IETF RFC 5952 shall not be used.
type Ipv6AddrRo = string

// Link string formatted according to IETF RFC 3986 identifying a referenced resource.
type Link = string

// LocationArea defines model for LocationArea.
type LocationArea struct {
	// CellIds Indicates a list of Cell Global Identities of the user which identifies the cell the UE is registered.
	CellIds []string `json:"cellIds,omitempty"`

	// CivicAddresses Identifies a list of civic addresses of the user where the UE is located.
	CivicAddresses []interface{} `json:"civicAddresses,omitempty"`

	// EnodeBIds Indicates a list of eNodeB identities in which the UE is currently located.
	EnodeBIds []string `json:"enodeBIds,omitempty"`

	// GeographicAreas Identifies a list of geographic area of the user where the UE is located.
	GeographicAreas []interface{} `json:"geographicAreas,omitempty"`

	// RoutingAreaIds Identifies a list of Routing Area Identities of the user where the UE is located.
	RoutingAreaIds []string `json:"routingAreaIds,omitempty"`

	// TrackingAreaIds Identifies a list of Tracking Area Identities of the user where the UE is located.
	TrackingAreaIds      []string               `json:"trackingAreaIds,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// LocationArea5G defines model for LocationArea5G.
type LocationArea5G struct {
	// CivicAddresses Identifies a list of civic addresses of the user where the UE is located.
	CivicAddresses *[]interface{} `json:"civicAddresses,omitempty"`

	// GeographicAreas Identifies a list of geographic area of the user where the UE is located.
	GeographicAreas *[]interface{} `json:"geographicAreas,omitempty"`

	// NwAreaInfo Describes a network area information in which the NF service consumer requests the number of UEs. (Original reference TS29554_Npcf_BDTPolicyControl.yaml#/components/schemas/NetworkAreaInfo)
	NwAreaInfo           interface{}            `json:"nwAreaInfo,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Mcc String encoding a Mobile Country Code part of the PLMN, comprising 3 digits, as defined in 3GPP TS 38.413.
type Mcc = string

// Mnc String encoding a Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in 3GPP TS 38.413.
type Mnc = string

// Msisdn string formatted according to subclause 3.3 of 3GPP TS 23.003 that describes an MSISDN.
type Msisdn = string

// NotificationData defines model for NotificationData.
type NotificationData struct {
	// EventReports Contains the reported event and applicable information
	EventReports []EventReport `json:"eventReports"`

	// Transaction string formatted according to IETF RFC 3986 identifying a referenced resource.
	Transaction          Link                   `json:"transaction"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PlmnId defines model for PlmnId.
type PlmnId struct {
	// Mcc String encoding a Mobile Country Code part of the PLMN, comprising 3 digits, as defined in 3GPP TS 38.413.
	Mcc Mcc `json:"mcc"`

	// Mnc String encoding a Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as defined in 3GPP TS 38.413.
	Mnc                  Mnc                    `json:"mnc"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Port Unsigned integer with valid values between 0 and 65535.
type Port = int

// PortRo Unsigned integer with valid values between 0 and 65535, with "readOnly=true" property.
type PortRo = int

// ProblemDetails defines model for ProblemDetails.
type ProblemDetails struct {
	// Cause A machine-readable application error cause specific to this occurrence of the problem. This IE should be present and provide application-related error information, if available.
	Cause *string `json:"cause,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Instance string providing an URI formatted according to IETF RFC 3986.
	Instance *Uri `json:"instance,omitempty"`

	// InvalidParams Description of invalid parameters, for a request rejected due to invalid parameters.
	InvalidParams []InvalidParam `json:"invalidParams,omitempty"`

	// Status The HTTP status code for this occurrence of the problem.
	Status *int `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem type. It should not change from occurrence to occurrence of the problem.
	Title *string `json:"title,omitempty"`

	// Type string providing an URI formatted according to IETF RFC 3986.
	Type                 *Uri                   `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ResourceId string chosen by the SCEF to serve as identifier in a resource URI.
type ResourceId = string

// ResultReason Possible values are - ROAMING_NOT_ALLOWED: Identifies the configuration parameters are not allowed by roaming agreement. - OTHER_REASON: Identifies the configuration parameters are not configured due to other reason.
type ResultReason string

// ScsAsId string that identifies an SCS/AS.
type ScsAsId = string

// SponsorInformation defines model for SponsorInformation.
type SponsorInformation struct {
	// AspId It indicates Application Service Provider ID.
	AspId string `json:"aspId"`

	// SponsorId It indicates Sponsor ID.
	SponsorId            string                 `json:"sponsorId"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// TestNotification defines model for TestNotification.
type TestNotification struct {
	// Subscription string formatted according to IETF RFC 3986 identifying a referenced resource.
	Subscription         Link                   `json:"subscription"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// TimeOfDay String with format partial-time or full-time as defined in subclause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind UTC).
type TimeOfDay = string

// TimeWindow defines model for TimeWindow.
type TimeWindow struct {
	// StartTime string with format "date-time" as defined in OpenAPI.
	StartTime DateTime `json:"startTime"`

	// StopTime string with format "date-time" as defined in OpenAPI.
	StopTime             DateTime               `json:"stopTime"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Uri string providing an URI formatted according to IETF RFC 3986.
type Uri = string

// UsageThreshold defines model for UsageThreshold.
type UsageThreshold struct {
	// DownlinkVolume Unsigned integer identifying a volume in units of bytes.
	DownlinkVolume *Volume `json:"downlinkVolume,omitempty"`

	// Duration Unsigned integer identifying a period of time in units of seconds.
	Duration *DurationSec `json:"duration,omitempty"`

	// TotalVolume Unsigned integer identifying a volume in units of bytes.
	TotalVolume *Volume `json:"totalVolume,omitempty"`

	// UplinkVolume Unsigned integer identifying a volume in units of bytes.
	UplinkVolume         *Volume                `json:"uplinkVolume,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UsageThresholdRm defines model for UsageThresholdRm.
type UsageThresholdRm struct {
	// DownlinkVolume Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	DownlinkVolume *VolumeRm `json:"downlinkVolume"`

	// Duration Unsigned integer identifying a period of time in units of seconds with "nullable=true" property.
	Duration *DurationSecRm `json:"duration"`

	// TotalVolume Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	TotalVolume *VolumeRm `json:"totalVolume"`

	// UplinkVolume Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	UplinkVolume         *VolumeRm              `json:"uplinkVolume"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Volume Unsigned integer identifying a volume in units of bytes.
type Volume = int64

// VolumeRm Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
type VolumeRm = int64

// WebsockNotifConfig defines model for WebsockNotifConfig.
type WebsockNotifConfig struct {
	// RequestWebsocketUri Set by the SCS/AS to indicate that the Websocket delivery is requested.
	RequestWebsocketUri *bool `json:"requestWebsocketUri,omitempty"`

	// WebsocketUri string formatted according to IETF RFC 3986 identifying a referenced resource.
	WebsocketUri         *Link                  `json:"websocketUri,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// N400 defines model for 400.
type N400 = ProblemDetails

// N401 defines model for 401.
type N401 = ProblemDetails

// N403 defines model for 403.
type N403 = ProblemDetails

// N404 defines model for 404.
type N404 = ProblemDetails

// N406 defines model for 406.
type N406 = ProblemDetails

// N409 defines model for 409.
type N409 = ProblemDetails

// N411 defines model for 411.
type N411 = ProblemDetails

// N412 defines model for 412.
type N412 = ProblemDetails

// N413 defines model for 413.
type N413 = ProblemDetails

// N414 defines model for 414.
type N414 = ProblemDetails

// N415 defines model for 415.
type N415 = ProblemDetails

// N429 defines model for 429.
type N429 = ProblemDetails

// N500 defines model for 500.
type N500 = ProblemDetails

// N503 defines model for 503.
type N503 = ProblemDetails

// Getter for additional properties for AccumulatedUsage. Returns the specified
// element and whether it was found
func (a AccumulatedUsage) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccumulatedUsage
func (a *AccumulatedUsage) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccumulatedUsage to handle AdditionalProperties
func (a *AccumulatedUsage) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["downlinkVolume"]; found {
		err = json.Unmarshal(raw, &a.DownlinkVolume)
		if err != nil {
			return fmt.Errorf("error reading 'downlinkVolume': %w", err)
		}
		delete(object, "downlinkVolume")
	}

	if raw, found := object["duration"]; found {
		err = json.Unmarshal(raw, &a.Duration)
		if err != nil {
			return fmt.Errorf("error reading 'duration': %w", err)
		}
		delete(object, "duration")
	}

	if raw, found := object["totalVolume"]; found {
		err = json.Unmarshal(raw, &a.TotalVolume)
		if err != nil {
			return fmt.Errorf("error reading 'totalVolume': %w", err)
		}
		delete(object, "totalVolume")
	}

	if raw, found := object["uplinkVolume"]; found {
		err = json.Unmarshal(raw, &a.UplinkVolume)
		if err != nil {
			return fmt.Errorf("error reading 'uplinkVolume': %w", err)
		}
		delete(object, "uplinkVolume")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccumulatedUsage to handle AdditionalProperties
func (a AccumulatedUsage) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DownlinkVolume != nil {
		object["downlinkVolume"], err = json.Marshal(a.DownlinkVolume)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'downlinkVolume': %w", err)
		}
	}

	if a.Duration != nil {
		object["duration"], err = json.Marshal(a.Duration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'duration': %w", err)
		}
	}

	if a.TotalVolume != nil {
		object["totalVolume"], err = json.Marshal(a.TotalVolume)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'totalVolume': %w", err)
		}
	}

	if a.UplinkVolume != nil {
		object["uplinkVolume"], err = json.Marshal(a.UplinkVolume)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'uplinkVolume': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Acknowledgement. Returns the specified
// element and whether it was found
func (a Acknowledgement) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Acknowledgement
func (a *Acknowledgement) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Acknowledgement to handle AdditionalProperties
func (a *Acknowledgement) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["details"]; found {
		err = json.Unmarshal(raw, &a.Details)
		if err != nil {
			return fmt.Errorf("error reading 'details': %w", err)
		}
		delete(object, "details")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Acknowledgement to handle AdditionalProperties
func (a Acknowledgement) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["details"], err = json.Marshal(a.Details)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'details': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConfigResult. Returns the specified
// element and whether it was found
func (a ConfigResult) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConfigResult
func (a *ConfigResult) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConfigResult to handle AdditionalProperties
func (a *ConfigResult) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["externalIds"]; found {
		err = json.Unmarshal(raw, &a.ExternalIds)
		if err != nil {
			return fmt.Errorf("error reading 'externalIds': %w", err)
		}
		delete(object, "externalIds")
	}

	if raw, found := object["msisdns"]; found {
		err = json.Unmarshal(raw, &a.Msisdns)
		if err != nil {
			return fmt.Errorf("error reading 'msisdns': %w", err)
		}
		delete(object, "msisdns")
	}

	if raw, found := object["resultReason"]; found {
		err = json.Unmarshal(raw, &a.ResultReason)
		if err != nil {
			return fmt.Errorf("error reading 'resultReason': %w", err)
		}
		delete(object, "resultReason")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConfigResult to handle AdditionalProperties
func (a ConfigResult) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.ExternalIds) != 0 {
		object["externalIds"], err = json.Marshal(a.ExternalIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'externalIds': %w", err)
		}
	}

	if len(a.Msisdns) != 0 {
		object["msisdns"], err = json.Marshal(a.Msisdns)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'msisdns': %w", err)
		}
	}

	object["resultReason"], err = json.Marshal(a.ResultReason)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'resultReason': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for EventReport. Returns the specified
// element and whether it was found
func (a EventReport) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for EventReport
func (a *EventReport) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for EventReport to handle AdditionalProperties
func (a *EventReport) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accumulatedUsage"]; found {
		err = json.Unmarshal(raw, &a.AccumulatedUsage)
		if err != nil {
			return fmt.Errorf("error reading 'accumulatedUsage': %w", err)
		}
		delete(object, "accumulatedUsage")
	}

	if raw, found := object["event"]; found {
		err = json.Unmarshal(raw, &a.Event)
		if err != nil {
			return fmt.Errorf("error reading 'event': %w", err)
		}
		delete(object, "event")
	}

	if raw, found := object["flowIds"]; found {
		err = json.Unmarshal(raw, &a.FlowIds)
		if err != nil {
			return fmt.Errorf("error reading 'flowIds': %w", err)
		}
		delete(object, "flowIds")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for EventReport to handle AdditionalProperties
func (a EventReport) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AccumulatedUsage != nil {
		object["accumulatedUsage"], err = json.Marshal(a.AccumulatedUsage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accumulatedUsage': %w", err)
		}
	}

	object["event"], err = json.Marshal(a.Event)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'event': %w", err)
	}

	if len(a.FlowIds) != 0 {
		object["flowIds"], err = json.Marshal(a.FlowIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'flowIds': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for FlowInfo. Returns the specified
// element and whether it was found
func (a FlowInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for FlowInfo
func (a *FlowInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for FlowInfo to handle AdditionalProperties
func (a *FlowInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["flowDescriptions"]; found {
		err = json.Unmarshal(raw, &a.FlowDescriptions)
		if err != nil {
			return fmt.Errorf("error reading 'flowDescriptions': %w", err)
		}
		delete(object, "flowDescriptions")
	}

	if raw, found := object["flowId"]; found {
		err = json.Unmarshal(raw, &a.FlowId)
		if err != nil {
			return fmt.Errorf("error reading 'flowId': %w", err)
		}
		delete(object, "flowId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for FlowInfo to handle AdditionalProperties
func (a FlowInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.FlowDescriptions) != 0 {
		object["flowDescriptions"], err = json.Marshal(a.FlowDescriptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'flowDescriptions': %w", err)
		}
	}

	object["flowId"], err = json.Marshal(a.FlowId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'flowId': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for InvalidParam. Returns the specified
// element and whether it was found
func (a InvalidParam) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for InvalidParam
func (a *InvalidParam) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for InvalidParam to handle AdditionalProperties
func (a *InvalidParam) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["param"]; found {
		err = json.Unmarshal(raw, &a.Param)
		if err != nil {
			return fmt.Errorf("error reading 'param': %w", err)
		}
		delete(object, "param")
	}

	if raw, found := object["reason"]; found {
		err = json.Unmarshal(raw, &a.Reason)
		if err != nil {
			return fmt.Errorf("error reading 'reason': %w", err)
		}
		delete(object, "reason")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for InvalidParam to handle AdditionalProperties
func (a InvalidParam) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["param"], err = json.Marshal(a.Param)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'param': %w", err)
	}

	if a.Reason != nil {
		object["reason"], err = json.Marshal(a.Reason)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reason': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for LocationArea. Returns the specified
// element and whether it was found
func (a LocationArea) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for LocationArea
func (a *LocationArea) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for LocationArea to handle AdditionalProperties
func (a *LocationArea) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cellIds"]; found {
		err = json.Unmarshal(raw, &a.CellIds)
		if err != nil {
			return fmt.Errorf("error reading 'cellIds': %w", err)
		}
		delete(object, "cellIds")
	}

	if raw, found := object["civicAddresses"]; found {
		err = json.Unmarshal(raw, &a.CivicAddresses)
		if err != nil {
			return fmt.Errorf("error reading 'civicAddresses': %w", err)
		}
		delete(object, "civicAddresses")
	}

	if raw, found := object["enodeBIds"]; found {
		err = json.Unmarshal(raw, &a.EnodeBIds)
		if err != nil {
			return fmt.Errorf("error reading 'enodeBIds': %w", err)
		}
		delete(object, "enodeBIds")
	}

	if raw, found := object["geographicAreas"]; found {
		err = json.Unmarshal(raw, &a.GeographicAreas)
		if err != nil {
			return fmt.Errorf("error reading 'geographicAreas': %w", err)
		}
		delete(object, "geographicAreas")
	}

	if raw, found := object["routingAreaIds"]; found {
		err = json.Unmarshal(raw, &a.RoutingAreaIds)
		if err != nil {
			return fmt.Errorf("error reading 'routingAreaIds': %w", err)
		}
		delete(object, "routingAreaIds")
	}

	if raw, found := object["trackingAreaIds"]; found {
		err = json.Unmarshal(raw, &a.TrackingAreaIds)
		if err != nil {
			return fmt.Errorf("error reading 'trackingAreaIds': %w", err)
		}
		delete(object, "trackingAreaIds")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for LocationArea to handle AdditionalProperties
func (a LocationArea) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.CellIds) != 0 {
		object["cellIds"], err = json.Marshal(a.CellIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cellIds': %w", err)
		}
	}

	if len(a.CivicAddresses) != 0 {
		object["civicAddresses"], err = json.Marshal(a.CivicAddresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'civicAddresses': %w", err)
		}
	}

	if len(a.EnodeBIds) != 0 {
		object["enodeBIds"], err = json.Marshal(a.EnodeBIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enodeBIds': %w", err)
		}
	}

	if len(a.GeographicAreas) != 0 {
		object["geographicAreas"], err = json.Marshal(a.GeographicAreas)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'geographicAreas': %w", err)
		}
	}

	if len(a.RoutingAreaIds) != 0 {
		object["routingAreaIds"], err = json.Marshal(a.RoutingAreaIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'routingAreaIds': %w", err)
		}
	}

	if len(a.TrackingAreaIds) != 0 {
		object["trackingAreaIds"], err = json.Marshal(a.TrackingAreaIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'trackingAreaIds': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for LocationArea5G. Returns the specified
// element and whether it was found
func (a LocationArea5G) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for LocationArea5G
func (a *LocationArea5G) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for LocationArea5G to handle AdditionalProperties
func (a *LocationArea5G) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["civicAddresses"]; found {
		err = json.Unmarshal(raw, &a.CivicAddresses)
		if err != nil {
			return fmt.Errorf("error reading 'civicAddresses': %w", err)
		}
		delete(object, "civicAddresses")
	}

	if raw, found := object["geographicAreas"]; found {
		err = json.Unmarshal(raw, &a.GeographicAreas)
		if err != nil {
			return fmt.Errorf("error reading 'geographicAreas': %w", err)
		}
		delete(object, "geographicAreas")
	}

	if raw, found := object["nwAreaInfo"]; found {
		err = json.Unmarshal(raw, &a.NwAreaInfo)
		if err != nil {
			return fmt.Errorf("error reading 'nwAreaInfo': %w", err)
		}
		delete(object, "nwAreaInfo")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for LocationArea5G to handle AdditionalProperties
func (a LocationArea5G) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CivicAddresses != nil {
		object["civicAddresses"], err = json.Marshal(a.CivicAddresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'civicAddresses': %w", err)
		}
	}

	if a.GeographicAreas != nil {
		object["geographicAreas"], err = json.Marshal(a.GeographicAreas)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'geographicAreas': %w", err)
		}
	}

	if a.NwAreaInfo != nil {
		object["nwAreaInfo"], err = json.Marshal(a.NwAreaInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nwAreaInfo': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NotificationData. Returns the specified
// element and whether it was found
func (a NotificationData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NotificationData
func (a *NotificationData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NotificationData to handle AdditionalProperties
func (a *NotificationData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["eventReports"]; found {
		err = json.Unmarshal(raw, &a.EventReports)
		if err != nil {
			return fmt.Errorf("error reading 'eventReports': %w", err)
		}
		delete(object, "eventReports")
	}

	if raw, found := object["transaction"]; found {
		err = json.Unmarshal(raw, &a.Transaction)
		if err != nil {
			return fmt.Errorf("error reading 'transaction': %w", err)
		}
		delete(object, "transaction")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NotificationData to handle AdditionalProperties
func (a NotificationData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["eventReports"], err = json.Marshal(a.EventReports)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'eventReports': %w", err)
	}

	object["transaction"], err = json.Marshal(a.Transaction)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'transaction': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PlmnId. Returns the specified
// element and whether it was found
func (a PlmnId) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PlmnId
func (a *PlmnId) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PlmnId to handle AdditionalProperties
func (a *PlmnId) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["mcc"]; found {
		err = json.Unmarshal(raw, &a.Mcc)
		if err != nil {
			return fmt.Errorf("error reading 'mcc': %w", err)
		}
		delete(object, "mcc")
	}

	if raw, found := object["mnc"]; found {
		err = json.Unmarshal(raw, &a.Mnc)
		if err != nil {
			return fmt.Errorf("error reading 'mnc': %w", err)
		}
		delete(object, "mnc")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PlmnId to handle AdditionalProperties
func (a PlmnId) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["mcc"], err = json.Marshal(a.Mcc)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'mcc': %w", err)
	}

	object["mnc"], err = json.Marshal(a.Mnc)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'mnc': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProblemDetails. Returns the specified
// element and whether it was found
func (a ProblemDetails) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProblemDetails
func (a *ProblemDetails) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProblemDetails to handle AdditionalProperties
func (a *ProblemDetails) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cause"]; found {
		err = json.Unmarshal(raw, &a.Cause)
		if err != nil {
			return fmt.Errorf("error reading 'cause': %w", err)
		}
		delete(object, "cause")
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &a.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
		delete(object, "detail")
	}

	if raw, found := object["instance"]; found {
		err = json.Unmarshal(raw, &a.Instance)
		if err != nil {
			return fmt.Errorf("error reading 'instance': %w", err)
		}
		delete(object, "instance")
	}

	if raw, found := object["invalidParams"]; found {
		err = json.Unmarshal(raw, &a.InvalidParams)
		if err != nil {
			return fmt.Errorf("error reading 'invalidParams': %w", err)
		}
		delete(object, "invalidParams")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProblemDetails to handle AdditionalProperties
func (a ProblemDetails) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Cause != nil {
		object["cause"], err = json.Marshal(a.Cause)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cause': %w", err)
		}
	}

	if a.Detail != nil {
		object["detail"], err = json.Marshal(a.Detail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'detail': %w", err)
		}
	}

	if a.Instance != nil {
		object["instance"], err = json.Marshal(a.Instance)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'instance': %w", err)
		}
	}

	if len(a.InvalidParams) != 0 {
		object["invalidParams"], err = json.Marshal(a.InvalidParams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'invalidParams': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SponsorInformation. Returns the specified
// element and whether it was found
func (a SponsorInformation) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SponsorInformation
func (a *SponsorInformation) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SponsorInformation to handle AdditionalProperties
func (a *SponsorInformation) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["aspId"]; found {
		err = json.Unmarshal(raw, &a.AspId)
		if err != nil {
			return fmt.Errorf("error reading 'aspId': %w", err)
		}
		delete(object, "aspId")
	}

	if raw, found := object["sponsorId"]; found {
		err = json.Unmarshal(raw, &a.SponsorId)
		if err != nil {
			return fmt.Errorf("error reading 'sponsorId': %w", err)
		}
		delete(object, "sponsorId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SponsorInformation to handle AdditionalProperties
func (a SponsorInformation) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["aspId"], err = json.Marshal(a.AspId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'aspId': %w", err)
	}

	object["sponsorId"], err = json.Marshal(a.SponsorId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'sponsorId': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TestNotification. Returns the specified
// element and whether it was found
func (a TestNotification) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TestNotification
func (a *TestNotification) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TestNotification to handle AdditionalProperties
func (a *TestNotification) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["subscription"]; found {
		err = json.Unmarshal(raw, &a.Subscription)
		if err != nil {
			return fmt.Errorf("error reading 'subscription': %w", err)
		}
		delete(object, "subscription")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TestNotification to handle AdditionalProperties
func (a TestNotification) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["subscription"], err = json.Marshal(a.Subscription)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'subscription': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TimeWindow. Returns the specified
// element and whether it was found
func (a TimeWindow) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TimeWindow
func (a *TimeWindow) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TimeWindow to handle AdditionalProperties
func (a *TimeWindow) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["startTime"]; found {
		err = json.Unmarshal(raw, &a.StartTime)
		if err != nil {
			return fmt.Errorf("error reading 'startTime': %w", err)
		}
		delete(object, "startTime")
	}

	if raw, found := object["stopTime"]; found {
		err = json.Unmarshal(raw, &a.StopTime)
		if err != nil {
			return fmt.Errorf("error reading 'stopTime': %w", err)
		}
		delete(object, "stopTime")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TimeWindow to handle AdditionalProperties
func (a TimeWindow) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["startTime"], err = json.Marshal(a.StartTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'startTime': %w", err)
	}

	object["stopTime"], err = json.Marshal(a.StopTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'stopTime': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UsageThreshold. Returns the specified
// element and whether it was found
func (a UsageThreshold) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UsageThreshold
func (a *UsageThreshold) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UsageThreshold to handle AdditionalProperties
func (a *UsageThreshold) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["downlinkVolume"]; found {
		err = json.Unmarshal(raw, &a.DownlinkVolume)
		if err != nil {
			return fmt.Errorf("error reading 'downlinkVolume': %w", err)
		}
		delete(object, "downlinkVolume")
	}

	if raw, found := object["duration"]; found {
		err = json.Unmarshal(raw, &a.Duration)
		if err != nil {
			return fmt.Errorf("error reading 'duration': %w", err)
		}
		delete(object, "duration")
	}

	if raw, found := object["totalVolume"]; found {
		err = json.Unmarshal(raw, &a.TotalVolume)
		if err != nil {
			return fmt.Errorf("error reading 'totalVolume': %w", err)
		}
		delete(object, "totalVolume")
	}

	if raw, found := object["uplinkVolume"]; found {
		err = json.Unmarshal(raw, &a.UplinkVolume)
		if err != nil {
			return fmt.Errorf("error reading 'uplinkVolume': %w", err)
		}
		delete(object, "uplinkVolume")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UsageThreshold to handle AdditionalProperties
func (a UsageThreshold) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DownlinkVolume != nil {
		object["downlinkVolume"], err = json.Marshal(a.DownlinkVolume)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'downlinkVolume': %w", err)
		}
	}

	if a.Duration != nil {
		object["duration"], err = json.Marshal(a.Duration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'duration': %w", err)
		}
	}

	if a.TotalVolume != nil {
		object["totalVolume"], err = json.Marshal(a.TotalVolume)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'totalVolume': %w", err)
		}
	}

	if a.UplinkVolume != nil {
		object["uplinkVolume"], err = json.Marshal(a.UplinkVolume)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'uplinkVolume': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UsageThresholdRm. Returns the specified
// element and whether it was found
func (a UsageThresholdRm) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UsageThresholdRm
func (a *UsageThresholdRm) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UsageThresholdRm to handle AdditionalProperties
func (a *UsageThresholdRm) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["downlinkVolume"]; found {
		err = json.Unmarshal(raw, &a.DownlinkVolume)
		if err != nil {
			return fmt.Errorf("error reading 'downlinkVolume': %w", err)
		}
		delete(object, "downlinkVolume")
	}

	if raw, found := object["duration"]; found {
		err = json.Unmarshal(raw, &a.Duration)
		if err != nil {
			return fmt.Errorf("error reading 'duration': %w", err)
		}
		delete(object, "duration")
	}

	if raw, found := object["totalVolume"]; found {
		err = json.Unmarshal(raw, &a.TotalVolume)
		if err != nil {
			return fmt.Errorf("error reading 'totalVolume': %w", err)
		}
		delete(object, "totalVolume")
	}

	if raw, found := object["uplinkVolume"]; found {
		err = json.Unmarshal(raw, &a.UplinkVolume)
		if err != nil {
			return fmt.Errorf("error reading 'uplinkVolume': %w", err)
		}
		delete(object, "uplinkVolume")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UsageThresholdRm to handle AdditionalProperties
func (a UsageThresholdRm) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["downlinkVolume"], err = json.Marshal(a.DownlinkVolume)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'downlinkVolume': %w", err)
	}

	object["duration"], err = json.Marshal(a.Duration)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'duration': %w", err)
	}

	object["totalVolume"], err = json.Marshal(a.TotalVolume)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'totalVolume': %w", err)
	}

	object["uplinkVolume"], err = json.Marshal(a.UplinkVolume)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'uplinkVolume': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for WebsockNotifConfig. Returns the specified
// element and whether it was found
func (a WebsockNotifConfig) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for WebsockNotifConfig
func (a *WebsockNotifConfig) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for WebsockNotifConfig to handle AdditionalProperties
func (a *WebsockNotifConfig) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["requestWebsocketUri"]; found {
		err = json.Unmarshal(raw, &a.RequestWebsocketUri)
		if err != nil {
			return fmt.Errorf("error reading 'requestWebsocketUri': %w", err)
		}
		delete(object, "requestWebsocketUri")
	}

	if raw, found := object["websocketUri"]; found {
		err = json.Unmarshal(raw, &a.WebsocketUri)
		if err != nil {
			return fmt.Errorf("error reading 'websocketUri': %w", err)
		}
		delete(object, "websocketUri")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for WebsockNotifConfig to handle AdditionalProperties
func (a WebsockNotifConfig) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.RequestWebsocketUri != nil {
		object["requestWebsocketUri"], err = json.Marshal(a.RequestWebsocketUri)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'requestWebsocketUri': %w", err)
		}
	}

	if a.WebsocketUri != nil {
		object["websocketUri"], err = json.Marshal(a.WebsocketUri)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'websocketUri': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

type N307ResponseHeaders struct {
	Location string
}
type N307Response struct {
	Headers N307ResponseHeaders
}

type N308ResponseHeaders struct {
	Location string
}
type N308Response struct {
	Headers N308ResponseHeaders
}

type N400ApplicationProblemPlusJSONResponse ProblemDetails

type N401ApplicationProblemPlusJSONResponse ProblemDetails

type N403ApplicationProblemPlusJSONResponse ProblemDetails

type N404ApplicationProblemPlusJSONResponse ProblemDetails

type N406ApplicationProblemPlusJSONResponse ProblemDetails

type N409ApplicationProblemPlusJSONResponse ProblemDetails

type N411ApplicationProblemPlusJSONResponse ProblemDetails

type N412ApplicationProblemPlusJSONResponse ProblemDetails

type N413ApplicationProblemPlusJSONResponse ProblemDetails

type N414ApplicationProblemPlusJSONResponse ProblemDetails

type N415ApplicationProblemPlusJSONResponse ProblemDetails

type N429ApplicationProblemPlusJSONResponse ProblemDetails

type N500ApplicationProblemPlusJSONResponse ProblemDetails

type N503ApplicationProblemPlusJSONResponse ProblemDetails

type DefaultResponse struct {
}
