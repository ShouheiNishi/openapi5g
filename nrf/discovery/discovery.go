// Package discovery provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package discovery

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	externalRef0 "github.com/ShouheiNishi/openapi5g/amf/communication"
	externalRef1 "github.com/ShouheiNishi/openapi5g/commondata"
	externalRef2 "github.com/ShouheiNishi/openapi5g/nrf/management"
	externalRef3 "github.com/ShouheiNishi/openapi5g/udm/sdm"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

const (
	OAuth2ClientCredentialsScopes = "oAuth2ClientCredentials.Scopes"
)

// NFProfile Information of an NF Instance discovered by the NRF
type NFProfile struct {
	// AmfInfo Information of an AMF NF Instance
	AmfInfo     *externalRef2.AmfInfo            `json:"amfInfo,omitempty"`
	AmfInfoList *map[string]externalRef2.AmfInfo `json:"amfInfoList,omitempty"`

	// AusfInfo Information of an AUSF NF Instance
	AusfInfo     *externalRef2.AusfInfo            `json:"ausfInfo,omitempty"`
	AusfInfoList *map[string]externalRef2.AusfInfo `json:"ausfInfoList,omitempty"`

	// BsfInfo Information of a BSF NF Instance
	BsfInfo     *externalRef2.BsfInfo            `json:"bsfInfo,omitempty"`
	BsfInfoList *map[string]externalRef2.BsfInfo `json:"bsfInfoList,omitempty"`
	Capacity    *int                             `json:"capacity,omitempty"`

	// ChfInfo Information of a CHF NF Instance
	ChfInfo                          *externalRef2.ChfInfo                           `json:"chfInfo,omitempty"`
	ChfInfoList                      *map[string]externalRef2.ChfInfo                `json:"chfInfoList,omitempty"`
	CustomInfo                       *map[string]interface{}                         `json:"customInfo,omitempty"`
	DefaultNotificationSubscriptions *[]externalRef2.DefaultNotificationSubscription `json:"defaultNotificationSubscriptions,omitempty"`

	// Fqdn Fully Qualified Domain Name
	Fqdn *externalRef2.Fqdn `json:"fqdn,omitempty"`

	// GmlcInfo Information of a GMLC NF Instance
	GmlcInfo      *externalRef2.GmlcInfo           `json:"gmlcInfo,omitempty"`
	HssInfoList   *map[string]externalRef2.HssInfo `json:"hssInfoList,omitempty"`
	Ipv4Addresses []externalRef1.Ipv4Addr          `json:"ipv4Addresses,omitempty"`
	Ipv6Addresses []externalRef1.Ipv6Addr          `json:"ipv6Addresses,omitempty"`
	LcHSupportInd *bool                            `json:"lcHSupportInd,omitempty"`

	// LmfInfo Information of an LMF NF Instance
	LmfInfo       *externalRef2.LmfInfo  `json:"lmfInfo,omitempty"`
	Load          *int                   `json:"load,omitempty"`
	LoadTimeStamp *externalRef1.DateTime `json:"loadTimeStamp,omitempty"`
	Locality      *string                `json:"locality,omitempty"`

	// NefInfo Information of an NEF NF Instance
	NefInfo              *externalRef2.NefInfo     `json:"nefInfo,omitempty"`
	NfInstanceId         externalRef1.NfInstanceId `json:"nfInstanceId"`
	NfInstanceName       *string                   `json:"nfInstanceName,omitempty"`
	NfServiceList        *map[string]NFService     `json:"nfServiceList,omitempty"`
	NfServicePersistence *bool                     `json:"nfServicePersistence,omitempty"`
	// Deprecated:
	NfServices            []NFService                       `json:"nfServices,omitempty"`
	NfSetIdList           []externalRef1.NfSetId            `json:"nfSetIdList,omitempty"`
	NfSetRecoveryTimeList *map[string]externalRef1.DateTime `json:"nfSetRecoveryTimeList,omitempty"`

	// NfStatus Status of a given NF Instance stored in NRF
	NfStatus externalRef2.NFStatus `json:"nfStatus"`

	// NfType NF types known to NRF
	NfType  externalRef2.NFType `json:"nfType"`
	NsiList []string            `json:"nsiList,omitempty"`

	// NwdafInfo Information of a NWDAF NF Instance
	NwdafInfo      *externalRef2.NwdafInfo `json:"nwdafInfo,omitempty"`
	OlcHSupportInd *bool                   `json:"olcHSupportInd,omitempty"`

	// PcfInfo Information of a PCF NF Instance
	PcfInfo           *externalRef2.PcfInfo              `json:"pcfInfo,omitempty"`
	PcfInfoList       *map[string]externalRef2.PcfInfo   `json:"pcfInfoList,omitempty"`
	PcscfInfoList     *map[string]externalRef2.PcscfInfo `json:"pcscfInfoList,omitempty"`
	PerPlmnSnssaiList []externalRef2.PlmnSnssai          `json:"perPlmnSnssaiList,omitempty"`
	PlmnList          []externalRef1.PlmnId              `json:"plmnList,omitempty"`
	Priority          *int                               `json:"priority,omitempty"`
	RecoveryTime      *externalRef1.DateTime             `json:"recoveryTime,omitempty"`
	SNssais           []externalRef1.ExtSnssai           `json:"sNssais,omitempty"`
	ScpDomains        []string                           `json:"scpDomains,omitempty"`

	// ScpInfo Information of an SCP Instance
	ScpInfo                    *externalRef2.ScpInfo             `json:"scpInfo,omitempty"`
	ServiceSetRecoveryTimeList *map[string]externalRef1.DateTime `json:"serviceSetRecoveryTimeList,omitempty"`
	ServingScope               []string                          `json:"servingScope,omitempty"`

	// SmfInfo Information of an SMF NF Instance
	SmfInfo     *externalRef2.SmfInfo            `json:"smfInfo,omitempty"`
	SmfInfoList *map[string]externalRef2.SmfInfo `json:"smfInfoList,omitempty"`
	SnpnList    []externalRef1.PlmnIdNid         `json:"snpnList,omitempty"`

	// UdmInfo Information of an UDM NF Instance
	UdmInfo     *externalRef2.UdmInfo            `json:"udmInfo,omitempty"`
	UdmInfoList *map[string]externalRef2.UdmInfo `json:"udmInfoList,omitempty"`

	// UdrInfo Information of an UDR NF Instance
	UdrInfo     *externalRef2.UdrInfo            `json:"udrInfo,omitempty"`
	UdrInfoList *map[string]externalRef2.UdrInfo `json:"udrInfoList,omitempty"`

	// UdsfInfo Information related to UDSF
	UdsfInfo     *externalRef2.UdsfInfo            `json:"udsfInfo,omitempty"`
	UdsfInfoList *map[string]externalRef2.UdsfInfo `json:"udsfInfoList,omitempty"`

	// UpfInfo Information of an UPF NF Instance
	UpfInfo              *externalRef2.UpfInfo            `json:"upfInfo,omitempty"`
	UpfInfoList          *map[string]externalRef2.UpfInfo `json:"upfInfoList,omitempty"`
	AdditionalProperties map[string]interface{}           `json:"-"`
}

// NFService Information of a given NF Service Instance; it is part of the NFProfile of an NF Instance discovered by the NRF
type NFService struct {
	AllowedOperationsPerNfInstance   *map[string][]string                           `json:"allowedOperationsPerNfInstance,omitempty"`
	AllowedOperationsPerNfType       *map[string][]string                           `json:"allowedOperationsPerNfType,omitempty"`
	ApiPrefix                        *string                                        `json:"apiPrefix,omitempty"`
	Capacity                         *int                                           `json:"capacity,omitempty"`
	DefaultNotificationSubscriptions []externalRef2.DefaultNotificationSubscription `json:"defaultNotificationSubscriptions,omitempty"`

	// Fqdn Fully Qualified Domain Name
	Fqdn               *externalRef2.Fqdn            `json:"fqdn,omitempty"`
	IpEndPoints        []externalRef2.IpEndPoint     `json:"ipEndPoints,omitempty"`
	Load               *int                          `json:"load,omitempty"`
	LoadTimeStamp      *externalRef1.DateTime        `json:"loadTimeStamp,omitempty"`
	NfServiceSetIdList []externalRef1.NfServiceSetId `json:"nfServiceSetIdList,omitempty"`

	// NfServiceStatus Status of a given NF Service Instance of an NF Instance stored in NRF
	NfServiceStatus   externalRef2.NFServiceStatus `json:"nfServiceStatus"`
	Oauth2Required    *bool                        `json:"oauth2Required,omitempty"`
	PerPlmnSnssaiList []externalRef2.PlmnSnssai    `json:"perPlmnSnssaiList,omitempty"`
	Priority          *int                         `json:"priority,omitempty"`
	RecoveryTime      *externalRef1.DateTime       `json:"recoveryTime,omitempty"`
	SNssais           []externalRef1.ExtSnssai     `json:"sNssais,omitempty"`
	Scheme            externalRef1.UriScheme       `json:"scheme"`
	ServiceInstanceId string                       `json:"serviceInstanceId"`

	// ServiceName Service names known to NRF
	ServiceName                     externalRef2.ServiceName                         `json:"serviceName"`
	SupportedFeatures               *externalRef1.SupportedFeatures                  `json:"supportedFeatures,omitempty"`
	SupportedVendorSpecificFeatures *map[string][]externalRef2.VendorSpecificFeature `json:"supportedVendorSpecificFeatures,omitempty"`

	// VendorId Vendor ID of the NF Service instance (Private Enterprise Number assigned by IANA)
	VendorId             externalRef2.VendorId           `json:"vendorId,omitempty"`
	Versions             []externalRef2.NFServiceVersion `json:"versions"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// PreferredSearch Contains information on whether the returned NFProfiles match the preferred query parameters
type PreferredSearch struct {
	OtherApiVersionsInd          *bool                  `json:"otherApiVersionsInd,omitempty"`
	OtherLocalityInd             *bool                  `json:"otherLocalityInd,omitempty"`
	PreferredApiVersionsMatchInd *bool                  `json:"preferredApiVersionsMatchInd,omitempty"`
	PreferredFullPlmnMatchInd    *bool                  `json:"preferredFullPlmnMatchInd,omitempty"`
	PreferredLocalityMatchInd    *bool                  `json:"preferredLocalityMatchInd,omitempty"`
	PreferredTaiMatchInd         *bool                  `json:"preferredTaiMatchInd,omitempty"`
	AdditionalProperties         map[string]interface{} `json:"-"`
}

// SearchResult Contains the list of NF Profiles returned in a Discovery response
type SearchResult struct {
	NfInstances          []NFProfile                     `json:"nfInstances"`
	NrfSupportedFeatures *externalRef1.SupportedFeatures `json:"nrfSupportedFeatures,omitempty"`
	NumNfInstComplete    *externalRef1.Uint32            `json:"numNfInstComplete,omitempty"`

	// PreferredSearch Contains information on whether the returned NFProfiles match the preferred query parameters
	PreferredSearch      *PreferredSearch       `json:"preferredSearch,omitempty"`
	SearchId             *string                `json:"searchId,omitempty"`
	ValidityPeriod       *int                   `json:"validityPeriod,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// StoredSearchResult Contains a complete search result (i.e. a number of discovered NF Instances), stored by NRF as a consequence of a prior search result
type StoredSearchResult struct {
	NfInstances          []NFProfile            `json:"nfInstances"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SearchId defines model for searchId.
type SearchId = string

// N200 Contains a complete search result (i.e. a number of discovered NF Instances), stored by NRF as a consequence of a prior search result
type N200 = StoredSearchResult

// SearchNFInstancesParams defines parameters for SearchNFInstances.
type SearchNFInstancesParams struct {
	// TargetNfType Type of the target NF
	TargetNfType externalRef2.NFType `form:"target-nf-type" json:"target-nf-type"`

	// RequesterNfType Type of the requester NF
	RequesterNfType externalRef2.NFType `form:"requester-nf-type" json:"requester-nf-type"`

	// RequesterNfInstanceId NfInstanceId of the requester NF
	RequesterNfInstanceId *externalRef1.NfInstanceId `form:"requester-nf-instance-id,omitempty" json:"requester-nf-instance-id,omitempty"`

	// ServiceNames Names of the services offered by the NF
	ServiceNames *[]externalRef2.ServiceName `form:"service-names,omitempty" json:"service-names,omitempty"`

	// RequesterNfInstanceFqdn FQDN of the requester NF
	RequesterNfInstanceFqdn *externalRef2.Fqdn `form:"requester-nf-instance-fqdn,omitempty" json:"requester-nf-instance-fqdn,omitempty"`

	// TargetPlmnList Id of the PLMN of the target NF
	TargetPlmnList *[]externalRef1.PlmnId `form:"target-plmn-list,omitempty" json:"target-plmn-list,omitempty"`

	// RequesterPlmnList Id of the PLMN where the NF issuing the Discovery request is located
	RequesterPlmnList *[]externalRef1.PlmnId `form:"requester-plmn-list,omitempty" json:"requester-plmn-list,omitempty"`

	// TargetNfInstanceId Identity of the NF instance being discovered
	TargetNfInstanceId *externalRef1.NfInstanceId `form:"target-nf-instance-id,omitempty" json:"target-nf-instance-id,omitempty"`

	// TargetNfFqdn FQDN of the NF instance being discovered
	TargetNfFqdn *externalRef2.Fqdn `form:"target-nf-fqdn,omitempty" json:"target-nf-fqdn,omitempty"`

	// HnrfUri Uri of the home NRF
	HnrfUri *externalRef1.Uri `form:"hnrf-uri,omitempty" json:"hnrf-uri,omitempty"`

	// Snssais Slice info of the target NF
	Snssais *[]externalRef1.Snssai `form:"snssais,omitempty" json:"snssais,omitempty"`

	// RequesterSnssais Slice info of the requester NF
	RequesterSnssais *[]externalRef1.Snssai `form:"requester-snssais,omitempty" json:"requester-snssais,omitempty"`

	// PlmnSpecificSnssaiList PLMN specific Slice info of the target NF
	PlmnSpecificSnssaiList *[]externalRef2.PlmnSnssai `form:"plmn-specific-snssai-list,omitempty" json:"plmn-specific-snssai-list,omitempty"`

	// RequesterPlmnSpecificSnssaiList PLMN-specific slice info of the NF issuing the Discovery request
	RequesterPlmnSpecificSnssaiList *[]externalRef2.PlmnSnssai `form:"requester-plmn-specific-snssai-list,omitempty" json:"requester-plmn-specific-snssai-list,omitempty"`

	// Dnn Dnn supported by the BSF, SMF or UPF
	Dnn *externalRef1.Dnn `form:"dnn,omitempty" json:"dnn,omitempty"`

	// NsiList NSI IDs that are served by the services being discovered
	NsiList        *[]string `form:"nsi-list,omitempty" json:"nsi-list,omitempty"`
	SmfServingArea *string   `form:"smf-serving-area,omitempty" json:"smf-serving-area,omitempty"`

	// Tai Tracking Area Identity
	Tai *externalRef1.Tai `form:"tai,omitempty" json:"tai,omitempty"`

	// AmfRegionId AMF Region Identity
	AmfRegionId *externalRef1.AmfRegionId `form:"amf-region-id,omitempty" json:"amf-region-id,omitempty"`

	// AmfSetId AMF Set Identity
	AmfSetId *externalRef1.AmfSetId `form:"amf-set-id,omitempty" json:"amf-set-id,omitempty"`

	// Guami Guami used to search for an appropriate AMF
	Guami *externalRef1.Guami `form:"guami,omitempty" json:"guami,omitempty"`

	// Supi SUPI of the user
	Supi *externalRef1.Supi `form:"supi,omitempty" json:"supi,omitempty"`

	// UeIpv4Address IPv4 address of the UE
	UeIpv4Address *externalRef1.Ipv4Addr `form:"ue-ipv4-address,omitempty" json:"ue-ipv4-address,omitempty"`

	// IpDomain IP domain of the UE, which supported by BSF
	IpDomain *string `form:"ip-domain,omitempty" json:"ip-domain,omitempty"`

	// UeIpv6Prefix IPv6 prefix of the UE
	UeIpv6Prefix *externalRef1.Ipv6Prefix `form:"ue-ipv6-prefix,omitempty" json:"ue-ipv6-prefix,omitempty"`

	// PgwInd Combined PGW-C and SMF or a standalone SMF
	PgwInd *bool `form:"pgw-ind,omitempty" json:"pgw-ind,omitempty"`

	// Pgw PGW FQDN of a combined PGW-C and SMF
	Pgw *externalRef2.Fqdn `form:"pgw,omitempty" json:"pgw,omitempty"`

	// Gpsi GPSI of the user
	Gpsi *externalRef1.Gpsi `form:"gpsi,omitempty" json:"gpsi,omitempty"`

	// ExternalGroupIdentity external group identifier of the user
	ExternalGroupIdentity *externalRef3.ExtGroupId `form:"external-group-identity,omitempty" json:"external-group-identity,omitempty"`

	// InternalGroupIdentity internal group identifier of the user
	InternalGroupIdentity *externalRef1.GroupId `form:"internal-group-identity,omitempty" json:"internal-group-identity,omitempty"`

	// PfdData PFD data
	PfdData *externalRef2.PfdData `form:"pfd-data,omitempty" json:"pfd-data,omitempty"`

	// DataSet data set supported by the NF
	DataSet *externalRef2.DataSetId `form:"data-set,omitempty" json:"data-set,omitempty"`

	// RoutingIndicator routing indicator in SUCI
	RoutingIndicator *string `form:"routing-indicator,omitempty" json:"routing-indicator,omitempty"`

	// GroupIdList Group IDs of the NFs being discovered
	GroupIdList *[]externalRef1.NfGroupId `form:"group-id-list,omitempty" json:"group-id-list,omitempty"`

	// DnaiList Data network access identifiers of the NFs being discovered
	DnaiList *[]externalRef1.Dnai `form:"dnai-list,omitempty" json:"dnai-list,omitempty"`

	// PduSessionTypes list of PDU Session Type required to be supported by the target NF
	PduSessionTypes *[]externalRef1.PduSessionType `form:"pdu-session-types,omitempty" json:"pdu-session-types,omitempty"`

	// EventIdList Analytics event(s) requested to be supported by the Nnwdaf_AnalyticsInfo service
	EventIdList *[]string `form:"event-id-list,omitempty" json:"event-id-list,omitempty"`

	// NwdafEventList Analytics event(s) requested to be supported by the Nnwdaf_EventsSubscription service.
	NwdafEventList *[]string `form:"nwdaf-event-list,omitempty" json:"nwdaf-event-list,omitempty"`

	// SupportedFeatures Features required to be supported by the target NF
	SupportedFeatures *externalRef1.SupportedFeatures `form:"supported-features,omitempty" json:"supported-features,omitempty"`

	// UpfIwkEpsInd UPF supporting interworking with EPS or not
	UpfIwkEpsInd *bool `form:"upf-iwk-eps-ind,omitempty" json:"upf-iwk-eps-ind,omitempty"`

	// ChfSupportedPlmn PLMN ID supported by a CHF
	ChfSupportedPlmn *externalRef1.PlmnId `form:"chf-supported-plmn,omitempty" json:"chf-supported-plmn,omitempty"`

	// PreferredLocality preferred target NF location
	PreferredLocality *string `form:"preferred-locality,omitempty" json:"preferred-locality,omitempty"`

	// AccessType AccessType supported by the target NF
	AccessType *externalRef1.AccessType `form:"access-type,omitempty" json:"access-type,omitempty"`

	// Limit Maximum number of NFProfiles to return in the response
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// RequiredFeatures Features required to be supported by the target NF
	RequiredFeatures *[]externalRef1.SupportedFeatures `form:"required-features,omitempty" json:"required-features,omitempty"`

	// ComplexQuery the complex query condition expression
	ComplexQuery *externalRef1.ComplexQuery `form:"complex-query,omitempty" json:"complex-query,omitempty"`

	// MaxPayloadSize Maximum payload size of the response expressed in kilo octets
	MaxPayloadSize *int `form:"max-payload-size,omitempty" json:"max-payload-size,omitempty"`

	// MaxPayloadSizeExt Extended query for maximum payload size of the response expressed in kilo octets
	MaxPayloadSizeExt *int `form:"max-payload-size-ext,omitempty" json:"max-payload-size-ext,omitempty"`

	// AtsssCapability ATSSS Capability
	AtsssCapability *externalRef1.AtsssCapability `form:"atsss-capability,omitempty" json:"atsss-capability,omitempty"`

	// UpfUeIpAddrInd UPF supporting allocating UE IP addresses/prefixes
	UpfUeIpAddrInd *bool `form:"upf-ue-ip-addr-ind,omitempty" json:"upf-ue-ip-addr-ind,omitempty"`

	// ClientType Requested client type served by the NF
	ClientType *string `form:"client-type,omitempty" json:"client-type,omitempty"`

	// LmfId LMF identification to be discovered
	LmfId *string `form:"lmf-id,omitempty" json:"lmf-id,omitempty"`

	// AnNodeType Requested AN node type served by the NF
	AnNodeType *externalRef2.AnNodeType `form:"an-node-type,omitempty" json:"an-node-type,omitempty"`

	// RatType Requested RAT type served by the NF
	RatType *externalRef1.RatType `form:"rat-type,omitempty" json:"rat-type,omitempty"`

	// PreferredTai preferred Tracking Area Identity
	PreferredTai *externalRef1.Tai `form:"preferred-tai,omitempty" json:"preferred-tai,omitempty"`

	// PreferredNfInstances preferred NF Instances
	PreferredNfInstances *[]externalRef1.NfInstanceId `form:"preferred-nf-instances,omitempty" json:"preferred-nf-instances,omitempty"`

	// TargetSnpn Target SNPN Identity
	TargetSnpn *externalRef1.PlmnIdNid `form:"target-snpn,omitempty" json:"target-snpn,omitempty"`

	// RequesterSnpnList SNPN ID(s) of the NF instance issuing the Discovery request
	RequesterSnpnList *[]externalRef1.PlmnIdNid `form:"requester-snpn-list,omitempty" json:"requester-snpn-list,omitempty"`

	// AfEeData NEF exposured by the AF
	AfEeData *externalRef2.AfEventExposureData `form:"af-ee-data,omitempty" json:"af-ee-data,omitempty"`

	// WAgfInfo UPF collocated with W-AGF
	WAgfInfo *externalRef2.WAgfInfo `form:"w-agf-info,omitempty" json:"w-agf-info,omitempty"`

	// TngfInfo UPF collocated with TNGF
	TngfInfo *externalRef2.TngfInfo `form:"tngf-info,omitempty" json:"tngf-info,omitempty"`

	// TwifInfo UPF collocated with TWIF
	TwifInfo *externalRef2.TwifInfo `form:"twif-info,omitempty" json:"twif-info,omitempty"`

	// TargetNfSetId Target NF Set ID
	TargetNfSetId *externalRef1.NfSetId `form:"target-nf-set-id,omitempty" json:"target-nf-set-id,omitempty"`

	// TargetNfServiceSetId Target NF Service Set ID
	TargetNfServiceSetId *externalRef1.NfServiceSetId `form:"target-nf-service-set-id,omitempty" json:"target-nf-service-set-id,omitempty"`

	// NefId NEF ID
	NefId *externalRef2.NefId `form:"nef-id,omitempty" json:"nef-id,omitempty"`

	// NotificationType Notification Type
	NotificationType *externalRef2.NotificationType `form:"notification-type,omitempty" json:"notification-type,omitempty"`

	// N1MsgClass N1 Message Class
	N1MsgClass *externalRef0.N1MessageClass `form:"n1-msg-class,omitempty" json:"n1-msg-class,omitempty"`

	// N2InfoClass N2 Information Class
	N2InfoClass *externalRef0.N2InformationClass `form:"n2-info-class,omitempty" json:"n2-info-class,omitempty"`

	// ServingScope areas that can be served by the target NF
	ServingScope *[]string `form:"serving-scope,omitempty" json:"serving-scope,omitempty"`

	// Imsi IMSI of the requester UE to search for an appropriate NF (e.g. HSS)
	Imsi *string `form:"imsi,omitempty" json:"imsi,omitempty"`

	// ImsPrivateIdentity IMPI of the requester UE to search for a target HSS
	ImsPrivateIdentity *string `form:"ims-private-identity,omitempty" json:"ims-private-identity,omitempty"`

	// ImsPublicIdentity IMS Public Identity of the requester UE to search for a target HSS
	ImsPublicIdentity *string `form:"ims-public-identity,omitempty" json:"ims-public-identity,omitempty"`

	// Msisdn MSISDN of the requester UE to search for a target HSS
	Msisdn *string `form:"msisdn,omitempty" json:"msisdn,omitempty"`

	// PreferredApiVersions Preferred API version of the services to be discovered
	PreferredApiVersions *map[string]string `form:"preferred-api-versions,omitempty" json:"preferred-api-versions,omitempty"`

	// V2xSupportInd PCF supports V2X
	V2xSupportInd *bool `form:"v2x-support-ind,omitempty" json:"v2x-support-ind,omitempty"`

	// RedundantGtpu UPF supports redundant gtp-u to be discovered
	RedundantGtpu *bool `form:"redundant-gtpu,omitempty" json:"redundant-gtpu,omitempty"`

	// RedundantTransport UPF supports redundant transport path to be discovered
	RedundantTransport *bool `form:"redundant-transport,omitempty" json:"redundant-transport,omitempty"`

	// Ipups UPF which is configured for IPUPS functionality to be discovered
	Ipups *bool `form:"ipups,omitempty" json:"ipups,omitempty"`

	// ScpDomainList SCP domains the target SCP belongs to
	ScpDomainList *[]string `form:"scp-domain-list,omitempty" json:"scp-domain-list,omitempty"`

	// AddressDomain Address domain reachable through the SCP
	AddressDomain *externalRef2.Fqdn `form:"address-domain,omitempty" json:"address-domain,omitempty"`

	// Ipv4Addr IPv4 address reachable through the SCP
	Ipv4Addr *externalRef1.Ipv4Addr `form:"ipv4-addr,omitempty" json:"ipv4-addr,omitempty"`

	// Ipv6Prefix IPv6 prefix reachable through the SCP
	Ipv6Prefix *externalRef1.Ipv6Prefix `form:"ipv6-prefix,omitempty" json:"ipv6-prefix,omitempty"`

	// ServedNfSetId NF Set ID served by the SCP
	ServedNfSetId *externalRef1.NfSetId `form:"served-nf-set-id,omitempty" json:"served-nf-set-id,omitempty"`

	// RemotePlmnId Id of the PLMN reachable through the SCP
	RemotePlmnId *externalRef1.PlmnId `form:"remote-plmn-id,omitempty" json:"remote-plmn-id,omitempty"`

	// DataForwarding UPF Instance(s) configured for data forwarding are requested
	DataForwarding *bool `form:"data-forwarding,omitempty" json:"data-forwarding,omitempty"`

	// PreferredFullPlmn NF Instance(s) serving the full PLMN are preferred
	PreferredFullPlmn *bool `form:"preferred-full-plmn,omitempty" json:"preferred-full-plmn,omitempty"`

	// RequesterFeatures Features supported by the NF Service Consumer that is invoking the Nnrf_NFDiscovery service
	RequesterFeatures *externalRef1.SupportedFeatures `form:"requester-features,omitempty" json:"requester-features,omitempty"`

	// RealmId realm-id to search for an appropriate UDSF
	RealmId *string `form:"realm-id,omitempty" json:"realm-id,omitempty"`

	// StorageId storage-id to search for an appropriate UDSF
	StorageId *string `form:"storage-id,omitempty" json:"storage-id,omitempty"`

	// VsmfSupportInd V-SMF capability supported by the target NF instance(s)
	VsmfSupportInd *bool `form:"vsmf-support-ind,omitempty" json:"vsmf-support-ind,omitempty"`

	// GmlcNumber The GMLC Number supported by the GMLC
	GmlcNumber *string `form:"gmlc-number,omitempty" json:"gmlc-number,omitempty"`

	// AcceptEncoding Accept-Encoding, described in IETF RFC 7231
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// IfNoneMatch Validator for conditional requests, as described in IETF RFC 7232, 3.2
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// RetrieveStoredSearchParams defines parameters for RetrieveStoredSearch.
type RetrieveStoredSearchParams struct {
	// AcceptEncoding Accept-Encoding, described in IETF RFC 7231
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`
}

// RetrieveCompleteSearchParams defines parameters for RetrieveCompleteSearch.
type RetrieveCompleteSearchParams struct {
	// AcceptEncoding Accept-Encoding, described in IETF RFC 7231
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`
}

// Getter for additional properties for NFProfile. Returns the specified
// element and whether it was found
func (a NFProfile) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NFProfile
func (a *NFProfile) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NFProfile to handle AdditionalProperties
func (a *NFProfile) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["amfInfo"]; found {
		err = json.Unmarshal(raw, &a.AmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'amfInfo': %w", err)
		}
		delete(object, "amfInfo")
	}

	if raw, found := object["amfInfoList"]; found {
		err = json.Unmarshal(raw, &a.AmfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'amfInfoList': %w", err)
		}
		delete(object, "amfInfoList")
	}

	if raw, found := object["ausfInfo"]; found {
		err = json.Unmarshal(raw, &a.AusfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'ausfInfo': %w", err)
		}
		delete(object, "ausfInfo")
	}

	if raw, found := object["ausfInfoList"]; found {
		err = json.Unmarshal(raw, &a.AusfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'ausfInfoList': %w", err)
		}
		delete(object, "ausfInfoList")
	}

	if raw, found := object["bsfInfo"]; found {
		err = json.Unmarshal(raw, &a.BsfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'bsfInfo': %w", err)
		}
		delete(object, "bsfInfo")
	}

	if raw, found := object["bsfInfoList"]; found {
		err = json.Unmarshal(raw, &a.BsfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'bsfInfoList': %w", err)
		}
		delete(object, "bsfInfoList")
	}

	if raw, found := object["capacity"]; found {
		err = json.Unmarshal(raw, &a.Capacity)
		if err != nil {
			return fmt.Errorf("error reading 'capacity': %w", err)
		}
		delete(object, "capacity")
	}

	if raw, found := object["chfInfo"]; found {
		err = json.Unmarshal(raw, &a.ChfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'chfInfo': %w", err)
		}
		delete(object, "chfInfo")
	}

	if raw, found := object["chfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ChfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'chfInfoList': %w", err)
		}
		delete(object, "chfInfoList")
	}

	if raw, found := object["customInfo"]; found {
		err = json.Unmarshal(raw, &a.CustomInfo)
		if err != nil {
			return fmt.Errorf("error reading 'customInfo': %w", err)
		}
		delete(object, "customInfo")
	}

	if raw, found := object["defaultNotificationSubscriptions"]; found {
		err = json.Unmarshal(raw, &a.DefaultNotificationSubscriptions)
		if err != nil {
			return fmt.Errorf("error reading 'defaultNotificationSubscriptions': %w", err)
		}
		delete(object, "defaultNotificationSubscriptions")
	}

	if raw, found := object["fqdn"]; found {
		err = json.Unmarshal(raw, &a.Fqdn)
		if err != nil {
			return fmt.Errorf("error reading 'fqdn': %w", err)
		}
		delete(object, "fqdn")
	}

	if raw, found := object["gmlcInfo"]; found {
		err = json.Unmarshal(raw, &a.GmlcInfo)
		if err != nil {
			return fmt.Errorf("error reading 'gmlcInfo': %w", err)
		}
		delete(object, "gmlcInfo")
	}

	if raw, found := object["hssInfoList"]; found {
		err = json.Unmarshal(raw, &a.HssInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'hssInfoList': %w", err)
		}
		delete(object, "hssInfoList")
	}

	if raw, found := object["ipv4Addresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv4Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4Addresses': %w", err)
		}
		delete(object, "ipv4Addresses")
	}

	if raw, found := object["ipv6Addresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv6Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6Addresses': %w", err)
		}
		delete(object, "ipv6Addresses")
	}

	if raw, found := object["lcHSupportInd"]; found {
		err = json.Unmarshal(raw, &a.LcHSupportInd)
		if err != nil {
			return fmt.Errorf("error reading 'lcHSupportInd': %w", err)
		}
		delete(object, "lcHSupportInd")
	}

	if raw, found := object["lmfInfo"]; found {
		err = json.Unmarshal(raw, &a.LmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'lmfInfo': %w", err)
		}
		delete(object, "lmfInfo")
	}

	if raw, found := object["load"]; found {
		err = json.Unmarshal(raw, &a.Load)
		if err != nil {
			return fmt.Errorf("error reading 'load': %w", err)
		}
		delete(object, "load")
	}

	if raw, found := object["loadTimeStamp"]; found {
		err = json.Unmarshal(raw, &a.LoadTimeStamp)
		if err != nil {
			return fmt.Errorf("error reading 'loadTimeStamp': %w", err)
		}
		delete(object, "loadTimeStamp")
	}

	if raw, found := object["locality"]; found {
		err = json.Unmarshal(raw, &a.Locality)
		if err != nil {
			return fmt.Errorf("error reading 'locality': %w", err)
		}
		delete(object, "locality")
	}

	if raw, found := object["nefInfo"]; found {
		err = json.Unmarshal(raw, &a.NefInfo)
		if err != nil {
			return fmt.Errorf("error reading 'nefInfo': %w", err)
		}
		delete(object, "nefInfo")
	}

	if raw, found := object["nfInstanceId"]; found {
		err = json.Unmarshal(raw, &a.NfInstanceId)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstanceId': %w", err)
		}
		delete(object, "nfInstanceId")
	}

	if raw, found := object["nfInstanceName"]; found {
		err = json.Unmarshal(raw, &a.NfInstanceName)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstanceName': %w", err)
		}
		delete(object, "nfInstanceName")
	}

	if raw, found := object["nfServiceList"]; found {
		err = json.Unmarshal(raw, &a.NfServiceList)
		if err != nil {
			return fmt.Errorf("error reading 'nfServiceList': %w", err)
		}
		delete(object, "nfServiceList")
	}

	if raw, found := object["nfServicePersistence"]; found {
		err = json.Unmarshal(raw, &a.NfServicePersistence)
		if err != nil {
			return fmt.Errorf("error reading 'nfServicePersistence': %w", err)
		}
		delete(object, "nfServicePersistence")
	}

	if raw, found := object["nfServices"]; found {
		err = json.Unmarshal(raw, &a.NfServices)
		if err != nil {
			return fmt.Errorf("error reading 'nfServices': %w", err)
		}
		delete(object, "nfServices")
	}

	if raw, found := object["nfSetIdList"]; found {
		err = json.Unmarshal(raw, &a.NfSetIdList)
		if err != nil {
			return fmt.Errorf("error reading 'nfSetIdList': %w", err)
		}
		delete(object, "nfSetIdList")
	}

	if raw, found := object["nfSetRecoveryTimeList"]; found {
		err = json.Unmarshal(raw, &a.NfSetRecoveryTimeList)
		if err != nil {
			return fmt.Errorf("error reading 'nfSetRecoveryTimeList': %w", err)
		}
		delete(object, "nfSetRecoveryTimeList")
	}

	if raw, found := object["nfStatus"]; found {
		err = json.Unmarshal(raw, &a.NfStatus)
		if err != nil {
			return fmt.Errorf("error reading 'nfStatus': %w", err)
		}
		delete(object, "nfStatus")
	}

	if raw, found := object["nfType"]; found {
		err = json.Unmarshal(raw, &a.NfType)
		if err != nil {
			return fmt.Errorf("error reading 'nfType': %w", err)
		}
		delete(object, "nfType")
	}

	if raw, found := object["nsiList"]; found {
		err = json.Unmarshal(raw, &a.NsiList)
		if err != nil {
			return fmt.Errorf("error reading 'nsiList': %w", err)
		}
		delete(object, "nsiList")
	}

	if raw, found := object["nwdafInfo"]; found {
		err = json.Unmarshal(raw, &a.NwdafInfo)
		if err != nil {
			return fmt.Errorf("error reading 'nwdafInfo': %w", err)
		}
		delete(object, "nwdafInfo")
	}

	if raw, found := object["olcHSupportInd"]; found {
		err = json.Unmarshal(raw, &a.OlcHSupportInd)
		if err != nil {
			return fmt.Errorf("error reading 'olcHSupportInd': %w", err)
		}
		delete(object, "olcHSupportInd")
	}

	if raw, found := object["pcfInfo"]; found {
		err = json.Unmarshal(raw, &a.PcfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'pcfInfo': %w", err)
		}
		delete(object, "pcfInfo")
	}

	if raw, found := object["pcfInfoList"]; found {
		err = json.Unmarshal(raw, &a.PcfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'pcfInfoList': %w", err)
		}
		delete(object, "pcfInfoList")
	}

	if raw, found := object["pcscfInfoList"]; found {
		err = json.Unmarshal(raw, &a.PcscfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'pcscfInfoList': %w", err)
		}
		delete(object, "pcscfInfoList")
	}

	if raw, found := object["perPlmnSnssaiList"]; found {
		err = json.Unmarshal(raw, &a.PerPlmnSnssaiList)
		if err != nil {
			return fmt.Errorf("error reading 'perPlmnSnssaiList': %w", err)
		}
		delete(object, "perPlmnSnssaiList")
	}

	if raw, found := object["plmnList"]; found {
		err = json.Unmarshal(raw, &a.PlmnList)
		if err != nil {
			return fmt.Errorf("error reading 'plmnList': %w", err)
		}
		delete(object, "plmnList")
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &a.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
		delete(object, "priority")
	}

	if raw, found := object["recoveryTime"]; found {
		err = json.Unmarshal(raw, &a.RecoveryTime)
		if err != nil {
			return fmt.Errorf("error reading 'recoveryTime': %w", err)
		}
		delete(object, "recoveryTime")
	}

	if raw, found := object["sNssais"]; found {
		err = json.Unmarshal(raw, &a.SNssais)
		if err != nil {
			return fmt.Errorf("error reading 'sNssais': %w", err)
		}
		delete(object, "sNssais")
	}

	if raw, found := object["scpDomains"]; found {
		err = json.Unmarshal(raw, &a.ScpDomains)
		if err != nil {
			return fmt.Errorf("error reading 'scpDomains': %w", err)
		}
		delete(object, "scpDomains")
	}

	if raw, found := object["scpInfo"]; found {
		err = json.Unmarshal(raw, &a.ScpInfo)
		if err != nil {
			return fmt.Errorf("error reading 'scpInfo': %w", err)
		}
		delete(object, "scpInfo")
	}

	if raw, found := object["serviceSetRecoveryTimeList"]; found {
		err = json.Unmarshal(raw, &a.ServiceSetRecoveryTimeList)
		if err != nil {
			return fmt.Errorf("error reading 'serviceSetRecoveryTimeList': %w", err)
		}
		delete(object, "serviceSetRecoveryTimeList")
	}

	if raw, found := object["servingScope"]; found {
		err = json.Unmarshal(raw, &a.ServingScope)
		if err != nil {
			return fmt.Errorf("error reading 'servingScope': %w", err)
		}
		delete(object, "servingScope")
	}

	if raw, found := object["smfInfo"]; found {
		err = json.Unmarshal(raw, &a.SmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'smfInfo': %w", err)
		}
		delete(object, "smfInfo")
	}

	if raw, found := object["smfInfoList"]; found {
		err = json.Unmarshal(raw, &a.SmfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'smfInfoList': %w", err)
		}
		delete(object, "smfInfoList")
	}

	if raw, found := object["snpnList"]; found {
		err = json.Unmarshal(raw, &a.SnpnList)
		if err != nil {
			return fmt.Errorf("error reading 'snpnList': %w", err)
		}
		delete(object, "snpnList")
	}

	if raw, found := object["udmInfo"]; found {
		err = json.Unmarshal(raw, &a.UdmInfo)
		if err != nil {
			return fmt.Errorf("error reading 'udmInfo': %w", err)
		}
		delete(object, "udmInfo")
	}

	if raw, found := object["udmInfoList"]; found {
		err = json.Unmarshal(raw, &a.UdmInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'udmInfoList': %w", err)
		}
		delete(object, "udmInfoList")
	}

	if raw, found := object["udrInfo"]; found {
		err = json.Unmarshal(raw, &a.UdrInfo)
		if err != nil {
			return fmt.Errorf("error reading 'udrInfo': %w", err)
		}
		delete(object, "udrInfo")
	}

	if raw, found := object["udrInfoList"]; found {
		err = json.Unmarshal(raw, &a.UdrInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'udrInfoList': %w", err)
		}
		delete(object, "udrInfoList")
	}

	if raw, found := object["udsfInfo"]; found {
		err = json.Unmarshal(raw, &a.UdsfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'udsfInfo': %w", err)
		}
		delete(object, "udsfInfo")
	}

	if raw, found := object["udsfInfoList"]; found {
		err = json.Unmarshal(raw, &a.UdsfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'udsfInfoList': %w", err)
		}
		delete(object, "udsfInfoList")
	}

	if raw, found := object["upfInfo"]; found {
		err = json.Unmarshal(raw, &a.UpfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'upfInfo': %w", err)
		}
		delete(object, "upfInfo")
	}

	if raw, found := object["upfInfoList"]; found {
		err = json.Unmarshal(raw, &a.UpfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'upfInfoList': %w", err)
		}
		delete(object, "upfInfoList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NFProfile to handle AdditionalProperties
func (a NFProfile) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AmfInfo != nil {
		object["amfInfo"], err = json.Marshal(a.AmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'amfInfo': %w", err)
		}
	}

	if a.AmfInfoList != nil {
		object["amfInfoList"], err = json.Marshal(a.AmfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'amfInfoList': %w", err)
		}
	}

	if a.AusfInfo != nil {
		object["ausfInfo"], err = json.Marshal(a.AusfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ausfInfo': %w", err)
		}
	}

	if a.AusfInfoList != nil {
		object["ausfInfoList"], err = json.Marshal(a.AusfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ausfInfoList': %w", err)
		}
	}

	if a.BsfInfo != nil {
		object["bsfInfo"], err = json.Marshal(a.BsfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bsfInfo': %w", err)
		}
	}

	if a.BsfInfoList != nil {
		object["bsfInfoList"], err = json.Marshal(a.BsfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bsfInfoList': %w", err)
		}
	}

	if a.Capacity != nil {
		object["capacity"], err = json.Marshal(a.Capacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capacity': %w", err)
		}
	}

	if a.ChfInfo != nil {
		object["chfInfo"], err = json.Marshal(a.ChfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'chfInfo': %w", err)
		}
	}

	if a.ChfInfoList != nil {
		object["chfInfoList"], err = json.Marshal(a.ChfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'chfInfoList': %w", err)
		}
	}

	if a.CustomInfo != nil {
		object["customInfo"], err = json.Marshal(a.CustomInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'customInfo': %w", err)
		}
	}

	if a.DefaultNotificationSubscriptions != nil {
		object["defaultNotificationSubscriptions"], err = json.Marshal(a.DefaultNotificationSubscriptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'defaultNotificationSubscriptions': %w", err)
		}
	}

	if a.Fqdn != nil {
		object["fqdn"], err = json.Marshal(a.Fqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fqdn': %w", err)
		}
	}

	if a.GmlcInfo != nil {
		object["gmlcInfo"], err = json.Marshal(a.GmlcInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gmlcInfo': %w", err)
		}
	}

	if a.HssInfoList != nil {
		object["hssInfoList"], err = json.Marshal(a.HssInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hssInfoList': %w", err)
		}
	}

	if len(a.Ipv4Addresses) != 0 {
		object["ipv4Addresses"], err = json.Marshal(a.Ipv4Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4Addresses': %w", err)
		}
	}

	if len(a.Ipv6Addresses) != 0 {
		object["ipv6Addresses"], err = json.Marshal(a.Ipv6Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6Addresses': %w", err)
		}
	}

	if a.LcHSupportInd != nil {
		object["lcHSupportInd"], err = json.Marshal(a.LcHSupportInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lcHSupportInd': %w", err)
		}
	}

	if a.LmfInfo != nil {
		object["lmfInfo"], err = json.Marshal(a.LmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lmfInfo': %w", err)
		}
	}

	if a.Load != nil {
		object["load"], err = json.Marshal(a.Load)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'load': %w", err)
		}
	}

	if a.LoadTimeStamp != nil {
		object["loadTimeStamp"], err = json.Marshal(a.LoadTimeStamp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'loadTimeStamp': %w", err)
		}
	}

	if a.Locality != nil {
		object["locality"], err = json.Marshal(a.Locality)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'locality': %w", err)
		}
	}

	if a.NefInfo != nil {
		object["nefInfo"], err = json.Marshal(a.NefInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nefInfo': %w", err)
		}
	}

	object["nfInstanceId"], err = json.Marshal(a.NfInstanceId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfInstanceId': %w", err)
	}

	if a.NfInstanceName != nil {
		object["nfInstanceName"], err = json.Marshal(a.NfInstanceName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfInstanceName': %w", err)
		}
	}

	if a.NfServiceList != nil {
		object["nfServiceList"], err = json.Marshal(a.NfServiceList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServiceList': %w", err)
		}
	}

	if a.NfServicePersistence != nil {
		object["nfServicePersistence"], err = json.Marshal(a.NfServicePersistence)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServicePersistence': %w", err)
		}
	}

	if len(a.NfServices) != 0 {
		object["nfServices"], err = json.Marshal(a.NfServices)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServices': %w", err)
		}
	}

	if len(a.NfSetIdList) != 0 {
		object["nfSetIdList"], err = json.Marshal(a.NfSetIdList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfSetIdList': %w", err)
		}
	}

	if a.NfSetRecoveryTimeList != nil {
		object["nfSetRecoveryTimeList"], err = json.Marshal(a.NfSetRecoveryTimeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfSetRecoveryTimeList': %w", err)
		}
	}

	object["nfStatus"], err = json.Marshal(a.NfStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfStatus': %w", err)
	}

	object["nfType"], err = json.Marshal(a.NfType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfType': %w", err)
	}

	if len(a.NsiList) != 0 {
		object["nsiList"], err = json.Marshal(a.NsiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nsiList': %w", err)
		}
	}

	if a.NwdafInfo != nil {
		object["nwdafInfo"], err = json.Marshal(a.NwdafInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nwdafInfo': %w", err)
		}
	}

	if a.OlcHSupportInd != nil {
		object["olcHSupportInd"], err = json.Marshal(a.OlcHSupportInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'olcHSupportInd': %w", err)
		}
	}

	if a.PcfInfo != nil {
		object["pcfInfo"], err = json.Marshal(a.PcfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pcfInfo': %w", err)
		}
	}

	if a.PcfInfoList != nil {
		object["pcfInfoList"], err = json.Marshal(a.PcfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pcfInfoList': %w", err)
		}
	}

	if a.PcscfInfoList != nil {
		object["pcscfInfoList"], err = json.Marshal(a.PcscfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pcscfInfoList': %w", err)
		}
	}

	if len(a.PerPlmnSnssaiList) != 0 {
		object["perPlmnSnssaiList"], err = json.Marshal(a.PerPlmnSnssaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'perPlmnSnssaiList': %w", err)
		}
	}

	if len(a.PlmnList) != 0 {
		object["plmnList"], err = json.Marshal(a.PlmnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'plmnList': %w", err)
		}
	}

	if a.Priority != nil {
		object["priority"], err = json.Marshal(a.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	if a.RecoveryTime != nil {
		object["recoveryTime"], err = json.Marshal(a.RecoveryTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recoveryTime': %w", err)
		}
	}

	if len(a.SNssais) != 0 {
		object["sNssais"], err = json.Marshal(a.SNssais)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sNssais': %w", err)
		}
	}

	if len(a.ScpDomains) != 0 {
		object["scpDomains"], err = json.Marshal(a.ScpDomains)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpDomains': %w", err)
		}
	}

	if a.ScpInfo != nil {
		object["scpInfo"], err = json.Marshal(a.ScpInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpInfo': %w", err)
		}
	}

	if a.ServiceSetRecoveryTimeList != nil {
		object["serviceSetRecoveryTimeList"], err = json.Marshal(a.ServiceSetRecoveryTimeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'serviceSetRecoveryTimeList': %w", err)
		}
	}

	if len(a.ServingScope) != 0 {
		object["servingScope"], err = json.Marshal(a.ServingScope)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingScope': %w", err)
		}
	}

	if a.SmfInfo != nil {
		object["smfInfo"], err = json.Marshal(a.SmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'smfInfo': %w", err)
		}
	}

	if a.SmfInfoList != nil {
		object["smfInfoList"], err = json.Marshal(a.SmfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'smfInfoList': %w", err)
		}
	}

	if len(a.SnpnList) != 0 {
		object["snpnList"], err = json.Marshal(a.SnpnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'snpnList': %w", err)
		}
	}

	if a.UdmInfo != nil {
		object["udmInfo"], err = json.Marshal(a.UdmInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udmInfo': %w", err)
		}
	}

	if a.UdmInfoList != nil {
		object["udmInfoList"], err = json.Marshal(a.UdmInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udmInfoList': %w", err)
		}
	}

	if a.UdrInfo != nil {
		object["udrInfo"], err = json.Marshal(a.UdrInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udrInfo': %w", err)
		}
	}

	if a.UdrInfoList != nil {
		object["udrInfoList"], err = json.Marshal(a.UdrInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udrInfoList': %w", err)
		}
	}

	if a.UdsfInfo != nil {
		object["udsfInfo"], err = json.Marshal(a.UdsfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udsfInfo': %w", err)
		}
	}

	if a.UdsfInfoList != nil {
		object["udsfInfoList"], err = json.Marshal(a.UdsfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udsfInfoList': %w", err)
		}
	}

	if a.UpfInfo != nil {
		object["upfInfo"], err = json.Marshal(a.UpfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upfInfo': %w", err)
		}
	}

	if a.UpfInfoList != nil {
		object["upfInfoList"], err = json.Marshal(a.UpfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upfInfoList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NFService. Returns the specified
// element and whether it was found
func (a NFService) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NFService
func (a *NFService) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NFService to handle AdditionalProperties
func (a *NFService) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allowedOperationsPerNfInstance"]; found {
		err = json.Unmarshal(raw, &a.AllowedOperationsPerNfInstance)
		if err != nil {
			return fmt.Errorf("error reading 'allowedOperationsPerNfInstance': %w", err)
		}
		delete(object, "allowedOperationsPerNfInstance")
	}

	if raw, found := object["allowedOperationsPerNfType"]; found {
		err = json.Unmarshal(raw, &a.AllowedOperationsPerNfType)
		if err != nil {
			return fmt.Errorf("error reading 'allowedOperationsPerNfType': %w", err)
		}
		delete(object, "allowedOperationsPerNfType")
	}

	if raw, found := object["apiPrefix"]; found {
		err = json.Unmarshal(raw, &a.ApiPrefix)
		if err != nil {
			return fmt.Errorf("error reading 'apiPrefix': %w", err)
		}
		delete(object, "apiPrefix")
	}

	if raw, found := object["capacity"]; found {
		err = json.Unmarshal(raw, &a.Capacity)
		if err != nil {
			return fmt.Errorf("error reading 'capacity': %w", err)
		}
		delete(object, "capacity")
	}

	if raw, found := object["defaultNotificationSubscriptions"]; found {
		err = json.Unmarshal(raw, &a.DefaultNotificationSubscriptions)
		if err != nil {
			return fmt.Errorf("error reading 'defaultNotificationSubscriptions': %w", err)
		}
		delete(object, "defaultNotificationSubscriptions")
	}

	if raw, found := object["fqdn"]; found {
		err = json.Unmarshal(raw, &a.Fqdn)
		if err != nil {
			return fmt.Errorf("error reading 'fqdn': %w", err)
		}
		delete(object, "fqdn")
	}

	if raw, found := object["ipEndPoints"]; found {
		err = json.Unmarshal(raw, &a.IpEndPoints)
		if err != nil {
			return fmt.Errorf("error reading 'ipEndPoints': %w", err)
		}
		delete(object, "ipEndPoints")
	}

	if raw, found := object["load"]; found {
		err = json.Unmarshal(raw, &a.Load)
		if err != nil {
			return fmt.Errorf("error reading 'load': %w", err)
		}
		delete(object, "load")
	}

	if raw, found := object["loadTimeStamp"]; found {
		err = json.Unmarshal(raw, &a.LoadTimeStamp)
		if err != nil {
			return fmt.Errorf("error reading 'loadTimeStamp': %w", err)
		}
		delete(object, "loadTimeStamp")
	}

	if raw, found := object["nfServiceSetIdList"]; found {
		err = json.Unmarshal(raw, &a.NfServiceSetIdList)
		if err != nil {
			return fmt.Errorf("error reading 'nfServiceSetIdList': %w", err)
		}
		delete(object, "nfServiceSetIdList")
	}

	if raw, found := object["nfServiceStatus"]; found {
		err = json.Unmarshal(raw, &a.NfServiceStatus)
		if err != nil {
			return fmt.Errorf("error reading 'nfServiceStatus': %w", err)
		}
		delete(object, "nfServiceStatus")
	}

	if raw, found := object["oauth2Required"]; found {
		err = json.Unmarshal(raw, &a.Oauth2Required)
		if err != nil {
			return fmt.Errorf("error reading 'oauth2Required': %w", err)
		}
		delete(object, "oauth2Required")
	}

	if raw, found := object["perPlmnSnssaiList"]; found {
		err = json.Unmarshal(raw, &a.PerPlmnSnssaiList)
		if err != nil {
			return fmt.Errorf("error reading 'perPlmnSnssaiList': %w", err)
		}
		delete(object, "perPlmnSnssaiList")
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &a.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
		delete(object, "priority")
	}

	if raw, found := object["recoveryTime"]; found {
		err = json.Unmarshal(raw, &a.RecoveryTime)
		if err != nil {
			return fmt.Errorf("error reading 'recoveryTime': %w", err)
		}
		delete(object, "recoveryTime")
	}

	if raw, found := object["sNssais"]; found {
		err = json.Unmarshal(raw, &a.SNssais)
		if err != nil {
			return fmt.Errorf("error reading 'sNssais': %w", err)
		}
		delete(object, "sNssais")
	}

	if raw, found := object["scheme"]; found {
		err = json.Unmarshal(raw, &a.Scheme)
		if err != nil {
			return fmt.Errorf("error reading 'scheme': %w", err)
		}
		delete(object, "scheme")
	}

	if raw, found := object["serviceInstanceId"]; found {
		err = json.Unmarshal(raw, &a.ServiceInstanceId)
		if err != nil {
			return fmt.Errorf("error reading 'serviceInstanceId': %w", err)
		}
		delete(object, "serviceInstanceId")
	}

	if raw, found := object["serviceName"]; found {
		err = json.Unmarshal(raw, &a.ServiceName)
		if err != nil {
			return fmt.Errorf("error reading 'serviceName': %w", err)
		}
		delete(object, "serviceName")
	}

	if raw, found := object["supportedFeatures"]; found {
		err = json.Unmarshal(raw, &a.SupportedFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'supportedFeatures': %w", err)
		}
		delete(object, "supportedFeatures")
	}

	if raw, found := object["supportedVendorSpecificFeatures"]; found {
		err = json.Unmarshal(raw, &a.SupportedVendorSpecificFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'supportedVendorSpecificFeatures': %w", err)
		}
		delete(object, "supportedVendorSpecificFeatures")
	}

	if raw, found := object["vendorId"]; found {
		err = json.Unmarshal(raw, &a.VendorId)
		if err != nil {
			return fmt.Errorf("error reading 'vendorId': %w", err)
		}
		delete(object, "vendorId")
	}

	if raw, found := object["versions"]; found {
		err = json.Unmarshal(raw, &a.Versions)
		if err != nil {
			return fmt.Errorf("error reading 'versions': %w", err)
		}
		delete(object, "versions")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NFService to handle AdditionalProperties
func (a NFService) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowedOperationsPerNfInstance != nil {
		object["allowedOperationsPerNfInstance"], err = json.Marshal(a.AllowedOperationsPerNfInstance)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedOperationsPerNfInstance': %w", err)
		}
	}

	if a.AllowedOperationsPerNfType != nil {
		object["allowedOperationsPerNfType"], err = json.Marshal(a.AllowedOperationsPerNfType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedOperationsPerNfType': %w", err)
		}
	}

	if a.ApiPrefix != nil {
		object["apiPrefix"], err = json.Marshal(a.ApiPrefix)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'apiPrefix': %w", err)
		}
	}

	if a.Capacity != nil {
		object["capacity"], err = json.Marshal(a.Capacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capacity': %w", err)
		}
	}

	if len(a.DefaultNotificationSubscriptions) != 0 {
		object["defaultNotificationSubscriptions"], err = json.Marshal(a.DefaultNotificationSubscriptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'defaultNotificationSubscriptions': %w", err)
		}
	}

	if a.Fqdn != nil {
		object["fqdn"], err = json.Marshal(a.Fqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fqdn': %w", err)
		}
	}

	if len(a.IpEndPoints) != 0 {
		object["ipEndPoints"], err = json.Marshal(a.IpEndPoints)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipEndPoints': %w", err)
		}
	}

	if a.Load != nil {
		object["load"], err = json.Marshal(a.Load)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'load': %w", err)
		}
	}

	if a.LoadTimeStamp != nil {
		object["loadTimeStamp"], err = json.Marshal(a.LoadTimeStamp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'loadTimeStamp': %w", err)
		}
	}

	if len(a.NfServiceSetIdList) != 0 {
		object["nfServiceSetIdList"], err = json.Marshal(a.NfServiceSetIdList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServiceSetIdList': %w", err)
		}
	}

	object["nfServiceStatus"], err = json.Marshal(a.NfServiceStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfServiceStatus': %w", err)
	}

	if a.Oauth2Required != nil {
		object["oauth2Required"], err = json.Marshal(a.Oauth2Required)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'oauth2Required': %w", err)
		}
	}

	if len(a.PerPlmnSnssaiList) != 0 {
		object["perPlmnSnssaiList"], err = json.Marshal(a.PerPlmnSnssaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'perPlmnSnssaiList': %w", err)
		}
	}

	if a.Priority != nil {
		object["priority"], err = json.Marshal(a.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	if a.RecoveryTime != nil {
		object["recoveryTime"], err = json.Marshal(a.RecoveryTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recoveryTime': %w", err)
		}
	}

	if len(a.SNssais) != 0 {
		object["sNssais"], err = json.Marshal(a.SNssais)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sNssais': %w", err)
		}
	}

	object["scheme"], err = json.Marshal(a.Scheme)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'scheme': %w", err)
	}

	object["serviceInstanceId"], err = json.Marshal(a.ServiceInstanceId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'serviceInstanceId': %w", err)
	}

	object["serviceName"], err = json.Marshal(a.ServiceName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'serviceName': %w", err)
	}

	if a.SupportedFeatures != nil {
		object["supportedFeatures"], err = json.Marshal(a.SupportedFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supportedFeatures': %w", err)
		}
	}

	if a.SupportedVendorSpecificFeatures != nil {
		object["supportedVendorSpecificFeatures"], err = json.Marshal(a.SupportedVendorSpecificFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supportedVendorSpecificFeatures': %w", err)
		}
	}

	if len(a.VendorId) != 0 {
		object["vendorId"], err = json.Marshal(a.VendorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vendorId': %w", err)
		}
	}

	object["versions"], err = json.Marshal(a.Versions)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'versions': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PreferredSearch. Returns the specified
// element and whether it was found
func (a PreferredSearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PreferredSearch
func (a *PreferredSearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PreferredSearch to handle AdditionalProperties
func (a *PreferredSearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["otherApiVersionsInd"]; found {
		err = json.Unmarshal(raw, &a.OtherApiVersionsInd)
		if err != nil {
			return fmt.Errorf("error reading 'otherApiVersionsInd': %w", err)
		}
		delete(object, "otherApiVersionsInd")
	}

	if raw, found := object["otherLocalityInd"]; found {
		err = json.Unmarshal(raw, &a.OtherLocalityInd)
		if err != nil {
			return fmt.Errorf("error reading 'otherLocalityInd': %w", err)
		}
		delete(object, "otherLocalityInd")
	}

	if raw, found := object["preferredApiVersionsMatchInd"]; found {
		err = json.Unmarshal(raw, &a.PreferredApiVersionsMatchInd)
		if err != nil {
			return fmt.Errorf("error reading 'preferredApiVersionsMatchInd': %w", err)
		}
		delete(object, "preferredApiVersionsMatchInd")
	}

	if raw, found := object["preferredFullPlmnMatchInd"]; found {
		err = json.Unmarshal(raw, &a.PreferredFullPlmnMatchInd)
		if err != nil {
			return fmt.Errorf("error reading 'preferredFullPlmnMatchInd': %w", err)
		}
		delete(object, "preferredFullPlmnMatchInd")
	}

	if raw, found := object["preferredLocalityMatchInd"]; found {
		err = json.Unmarshal(raw, &a.PreferredLocalityMatchInd)
		if err != nil {
			return fmt.Errorf("error reading 'preferredLocalityMatchInd': %w", err)
		}
		delete(object, "preferredLocalityMatchInd")
	}

	if raw, found := object["preferredTaiMatchInd"]; found {
		err = json.Unmarshal(raw, &a.PreferredTaiMatchInd)
		if err != nil {
			return fmt.Errorf("error reading 'preferredTaiMatchInd': %w", err)
		}
		delete(object, "preferredTaiMatchInd")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PreferredSearch to handle AdditionalProperties
func (a PreferredSearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.OtherApiVersionsInd != nil {
		object["otherApiVersionsInd"], err = json.Marshal(a.OtherApiVersionsInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'otherApiVersionsInd': %w", err)
		}
	}

	if a.OtherLocalityInd != nil {
		object["otherLocalityInd"], err = json.Marshal(a.OtherLocalityInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'otherLocalityInd': %w", err)
		}
	}

	if a.PreferredApiVersionsMatchInd != nil {
		object["preferredApiVersionsMatchInd"], err = json.Marshal(a.PreferredApiVersionsMatchInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preferredApiVersionsMatchInd': %w", err)
		}
	}

	if a.PreferredFullPlmnMatchInd != nil {
		object["preferredFullPlmnMatchInd"], err = json.Marshal(a.PreferredFullPlmnMatchInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preferredFullPlmnMatchInd': %w", err)
		}
	}

	if a.PreferredLocalityMatchInd != nil {
		object["preferredLocalityMatchInd"], err = json.Marshal(a.PreferredLocalityMatchInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preferredLocalityMatchInd': %w", err)
		}
	}

	if a.PreferredTaiMatchInd != nil {
		object["preferredTaiMatchInd"], err = json.Marshal(a.PreferredTaiMatchInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preferredTaiMatchInd': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SearchResult. Returns the specified
// element and whether it was found
func (a SearchResult) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SearchResult
func (a *SearchResult) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SearchResult to handle AdditionalProperties
func (a *SearchResult) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nfInstances"]; found {
		err = json.Unmarshal(raw, &a.NfInstances)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstances': %w", err)
		}
		delete(object, "nfInstances")
	}

	if raw, found := object["nrfSupportedFeatures"]; found {
		err = json.Unmarshal(raw, &a.NrfSupportedFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'nrfSupportedFeatures': %w", err)
		}
		delete(object, "nrfSupportedFeatures")
	}

	if raw, found := object["numNfInstComplete"]; found {
		err = json.Unmarshal(raw, &a.NumNfInstComplete)
		if err != nil {
			return fmt.Errorf("error reading 'numNfInstComplete': %w", err)
		}
		delete(object, "numNfInstComplete")
	}

	if raw, found := object["preferredSearch"]; found {
		err = json.Unmarshal(raw, &a.PreferredSearch)
		if err != nil {
			return fmt.Errorf("error reading 'preferredSearch': %w", err)
		}
		delete(object, "preferredSearch")
	}

	if raw, found := object["searchId"]; found {
		err = json.Unmarshal(raw, &a.SearchId)
		if err != nil {
			return fmt.Errorf("error reading 'searchId': %w", err)
		}
		delete(object, "searchId")
	}

	if raw, found := object["validityPeriod"]; found {
		err = json.Unmarshal(raw, &a.ValidityPeriod)
		if err != nil {
			return fmt.Errorf("error reading 'validityPeriod': %w", err)
		}
		delete(object, "validityPeriod")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SearchResult to handle AdditionalProperties
func (a SearchResult) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nfInstances"], err = json.Marshal(a.NfInstances)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfInstances': %w", err)
	}

	if a.NrfSupportedFeatures != nil {
		object["nrfSupportedFeatures"], err = json.Marshal(a.NrfSupportedFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nrfSupportedFeatures': %w", err)
		}
	}

	if a.NumNfInstComplete != nil {
		object["numNfInstComplete"], err = json.Marshal(a.NumNfInstComplete)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'numNfInstComplete': %w", err)
		}
	}

	if a.PreferredSearch != nil {
		object["preferredSearch"], err = json.Marshal(a.PreferredSearch)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preferredSearch': %w", err)
		}
	}

	if a.SearchId != nil {
		object["searchId"], err = json.Marshal(a.SearchId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'searchId': %w", err)
		}
	}

	if a.ValidityPeriod != nil {
		object["validityPeriod"], err = json.Marshal(a.ValidityPeriod)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'validityPeriod': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StoredSearchResult. Returns the specified
// element and whether it was found
func (a StoredSearchResult) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StoredSearchResult
func (a *StoredSearchResult) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StoredSearchResult to handle AdditionalProperties
func (a *StoredSearchResult) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nfInstances"]; found {
		err = json.Unmarshal(raw, &a.NfInstances)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstances': %w", err)
		}
		delete(object, "nfInstances")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StoredSearchResult to handle AdditionalProperties
func (a StoredSearchResult) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nfInstances"], err = json.Marshal(a.NfInstances)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfInstances': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SearchNFInstances request
	SearchNFInstances(ctx context.Context, params *SearchNFInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveStoredSearch request
	RetrieveStoredSearch(ctx context.Context, searchId SearchId, params *RetrieveStoredSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveCompleteSearch request
	RetrieveCompleteSearch(ctx context.Context, searchId SearchId, params *RetrieveCompleteSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SearchNFInstances(ctx context.Context, params *SearchNFInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchNFInstancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveStoredSearch(ctx context.Context, searchId SearchId, params *RetrieveStoredSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveStoredSearchRequest(c.Server, searchId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveCompleteSearch(ctx context.Context, searchId SearchId, params *RetrieveCompleteSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveCompleteSearchRequest(c.Server, searchId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSearchNFInstancesRequest generates requests for SearchNFInstances
func NewSearchNFInstancesRequest(server string, params *SearchNFInstancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nf-instances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-nf-type", runtime.ParamLocationQuery, params.TargetNfType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester-nf-type", runtime.ParamLocationQuery, params.RequesterNfType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RequesterNfInstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester-nf-instance-id", runtime.ParamLocationQuery, *params.RequesterNfInstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServiceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "service-names", runtime.ParamLocationQuery, *params.ServiceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequesterNfInstanceFqdn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester-nf-instance-fqdn", runtime.ParamLocationQuery, *params.RequesterNfInstanceFqdn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetPlmnList != nil {

			if queryParamBuf, err := json.Marshal(*params.TargetPlmnList); err != nil {
				return nil, err
			} else {
				queryValues.Add("target-plmn-list", string(queryParamBuf))
			}

		}

		if params.RequesterPlmnList != nil {

			if queryParamBuf, err := json.Marshal(*params.RequesterPlmnList); err != nil {
				return nil, err
			} else {
				queryValues.Add("requester-plmn-list", string(queryParamBuf))
			}

		}

		if params.TargetNfInstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-nf-instance-id", runtime.ParamLocationQuery, *params.TargetNfInstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetNfFqdn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-nf-fqdn", runtime.ParamLocationQuery, *params.TargetNfFqdn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HnrfUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hnrf-uri", runtime.ParamLocationQuery, *params.HnrfUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Snssais != nil {

			if queryParamBuf, err := json.Marshal(*params.Snssais); err != nil {
				return nil, err
			} else {
				queryValues.Add("snssais", string(queryParamBuf))
			}

		}

		if params.RequesterSnssais != nil {

			if queryParamBuf, err := json.Marshal(*params.RequesterSnssais); err != nil {
				return nil, err
			} else {
				queryValues.Add("requester-snssais", string(queryParamBuf))
			}

		}

		if params.PlmnSpecificSnssaiList != nil {

			if queryParamBuf, err := json.Marshal(*params.PlmnSpecificSnssaiList); err != nil {
				return nil, err
			} else {
				queryValues.Add("plmn-specific-snssai-list", string(queryParamBuf))
			}

		}

		if params.RequesterPlmnSpecificSnssaiList != nil {

			if queryParamBuf, err := json.Marshal(*params.RequesterPlmnSpecificSnssaiList); err != nil {
				return nil, err
			} else {
				queryValues.Add("requester-plmn-specific-snssai-list", string(queryParamBuf))
			}

		}

		if params.Dnn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dnn", runtime.ParamLocationQuery, *params.Dnn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NsiList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "nsi-list", runtime.ParamLocationQuery, *params.NsiList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SmfServingArea != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "smf-serving-area", runtime.ParamLocationQuery, *params.SmfServingArea); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tai != nil {

			if queryParamBuf, err := json.Marshal(*params.Tai); err != nil {
				return nil, err
			} else {
				queryValues.Add("tai", string(queryParamBuf))
			}

		}

		if params.AmfRegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amf-region-id", runtime.ParamLocationQuery, *params.AmfRegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AmfSetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amf-set-id", runtime.ParamLocationQuery, *params.AmfSetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Guami != nil {

			if queryParamBuf, err := json.Marshal(*params.Guami); err != nil {
				return nil, err
			} else {
				queryValues.Add("guami", string(queryParamBuf))
			}

		}

		if params.Supi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supi", runtime.ParamLocationQuery, *params.Supi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UeIpv4Address != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ue-ipv4-address", runtime.ParamLocationQuery, *params.UeIpv4Address); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpDomain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ip-domain", runtime.ParamLocationQuery, *params.IpDomain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UeIpv6Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ue-ipv6-prefix", runtime.ParamLocationQuery, *params.UeIpv6Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PgwInd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pgw-ind", runtime.ParamLocationQuery, *params.PgwInd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pgw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pgw", runtime.ParamLocationQuery, *params.Pgw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Gpsi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gpsi", runtime.ParamLocationQuery, *params.Gpsi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalGroupIdentity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "external-group-identity", runtime.ParamLocationQuery, *params.ExternalGroupIdentity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InternalGroupIdentity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "internal-group-identity", runtime.ParamLocationQuery, *params.InternalGroupIdentity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PfdData != nil {

			if queryParamBuf, err := json.Marshal(*params.PfdData); err != nil {
				return nil, err
			} else {
				queryValues.Add("pfd-data", string(queryParamBuf))
			}

		}

		if params.DataSet != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data-set", runtime.ParamLocationQuery, *params.DataSet); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoutingIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routing-indicator", runtime.ParamLocationQuery, *params.RoutingIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupIdList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group-id-list", runtime.ParamLocationQuery, *params.GroupIdList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DnaiList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dnai-list", runtime.ParamLocationQuery, *params.DnaiList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PduSessionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pdu-session-types", runtime.ParamLocationQuery, *params.PduSessionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIdList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "event-id-list", runtime.ParamLocationQuery, *params.EventIdList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NwdafEventList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "nwdaf-event-list", runtime.ParamLocationQuery, *params.NwdafEventList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SupportedFeatures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supported-features", runtime.ParamLocationQuery, *params.SupportedFeatures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpfIwkEpsInd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upf-iwk-eps-ind", runtime.ParamLocationQuery, *params.UpfIwkEpsInd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChfSupportedPlmn != nil {

			if queryParamBuf, err := json.Marshal(*params.ChfSupportedPlmn); err != nil {
				return nil, err
			} else {
				queryValues.Add("chf-supported-plmn", string(queryParamBuf))
			}

		}

		if params.PreferredLocality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferred-locality", runtime.ParamLocationQuery, *params.PreferredLocality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccessType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access-type", runtime.ParamLocationQuery, *params.AccessType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequiredFeatures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "required-features", runtime.ParamLocationQuery, *params.RequiredFeatures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ComplexQuery != nil {

			if queryParamBuf, err := json.Marshal(*params.ComplexQuery); err != nil {
				return nil, err
			} else {
				queryValues.Add("complex-query", string(queryParamBuf))
			}

		}

		if params.MaxPayloadSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max-payload-size", runtime.ParamLocationQuery, *params.MaxPayloadSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxPayloadSizeExt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max-payload-size-ext", runtime.ParamLocationQuery, *params.MaxPayloadSizeExt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AtsssCapability != nil {

			if queryParamBuf, err := json.Marshal(*params.AtsssCapability); err != nil {
				return nil, err
			} else {
				queryValues.Add("atsss-capability", string(queryParamBuf))
			}

		}

		if params.UpfUeIpAddrInd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upf-ue-ip-addr-ind", runtime.ParamLocationQuery, *params.UpfUeIpAddrInd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientType != nil {

			if queryParamBuf, err := json.Marshal(*params.ClientType); err != nil {
				return nil, err
			} else {
				queryValues.Add("client-type", string(queryParamBuf))
			}

		}

		if params.LmfId != nil {

			if queryParamBuf, err := json.Marshal(*params.LmfId); err != nil {
				return nil, err
			} else {
				queryValues.Add("lmf-id", string(queryParamBuf))
			}

		}

		if params.AnNodeType != nil {

			if queryParamBuf, err := json.Marshal(*params.AnNodeType); err != nil {
				return nil, err
			} else {
				queryValues.Add("an-node-type", string(queryParamBuf))
			}

		}

		if params.RatType != nil {

			if queryParamBuf, err := json.Marshal(*params.RatType); err != nil {
				return nil, err
			} else {
				queryValues.Add("rat-type", string(queryParamBuf))
			}

		}

		if params.PreferredTai != nil {

			if queryParamBuf, err := json.Marshal(*params.PreferredTai); err != nil {
				return nil, err
			} else {
				queryValues.Add("preferred-tai", string(queryParamBuf))
			}

		}

		if params.PreferredNfInstances != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preferred-nf-instances", runtime.ParamLocationQuery, *params.PreferredNfInstances); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetSnpn != nil {

			if queryParamBuf, err := json.Marshal(*params.TargetSnpn); err != nil {
				return nil, err
			} else {
				queryValues.Add("target-snpn", string(queryParamBuf))
			}

		}

		if params.RequesterSnpnList != nil {

			if queryParamBuf, err := json.Marshal(*params.RequesterSnpnList); err != nil {
				return nil, err
			} else {
				queryValues.Add("requester-snpn-list", string(queryParamBuf))
			}

		}

		if params.AfEeData != nil {

			if queryParamBuf, err := json.Marshal(*params.AfEeData); err != nil {
				return nil, err
			} else {
				queryValues.Add("af-ee-data", string(queryParamBuf))
			}

		}

		if params.WAgfInfo != nil {

			if queryParamBuf, err := json.Marshal(*params.WAgfInfo); err != nil {
				return nil, err
			} else {
				queryValues.Add("w-agf-info", string(queryParamBuf))
			}

		}

		if params.TngfInfo != nil {

			if queryParamBuf, err := json.Marshal(*params.TngfInfo); err != nil {
				return nil, err
			} else {
				queryValues.Add("tngf-info", string(queryParamBuf))
			}

		}

		if params.TwifInfo != nil {

			if queryParamBuf, err := json.Marshal(*params.TwifInfo); err != nil {
				return nil, err
			} else {
				queryValues.Add("twif-info", string(queryParamBuf))
			}

		}

		if params.TargetNfSetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-nf-set-id", runtime.ParamLocationQuery, *params.TargetNfSetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetNfServiceSetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-nf-service-set-id", runtime.ParamLocationQuery, *params.TargetNfServiceSetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NefId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nef-id", runtime.ParamLocationQuery, *params.NefId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotificationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification-type", runtime.ParamLocationQuery, *params.NotificationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.N1MsgClass != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "n1-msg-class", runtime.ParamLocationQuery, *params.N1MsgClass); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.N2InfoClass != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "n2-info-class", runtime.ParamLocationQuery, *params.N2InfoClass); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServingScope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "serving-scope", runtime.ParamLocationQuery, *params.ServingScope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Imsi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imsi", runtime.ParamLocationQuery, *params.Imsi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImsPrivateIdentity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ims-private-identity", runtime.ParamLocationQuery, *params.ImsPrivateIdentity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImsPublicIdentity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ims-public-identity", runtime.ParamLocationQuery, *params.ImsPublicIdentity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Msisdn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "msisdn", runtime.ParamLocationQuery, *params.Msisdn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreferredApiVersions != nil {

			if queryParamBuf, err := json.Marshal(*params.PreferredApiVersions); err != nil {
				return nil, err
			} else {
				queryValues.Add("preferred-api-versions", string(queryParamBuf))
			}

		}

		if params.V2xSupportInd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "v2x-support-ind", runtime.ParamLocationQuery, *params.V2xSupportInd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RedundantGtpu != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redundant-gtpu", runtime.ParamLocationQuery, *params.RedundantGtpu); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RedundantTransport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redundant-transport", runtime.ParamLocationQuery, *params.RedundantTransport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ipups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipups", runtime.ParamLocationQuery, *params.Ipups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScpDomainList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scp-domain-list", runtime.ParamLocationQuery, *params.ScpDomainList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddressDomain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address-domain", runtime.ParamLocationQuery, *params.AddressDomain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ipv4Addr != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipv4-addr", runtime.ParamLocationQuery, *params.Ipv4Addr); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ipv6Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipv6-prefix", runtime.ParamLocationQuery, *params.Ipv6Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServedNfSetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "served-nf-set-id", runtime.ParamLocationQuery, *params.ServedNfSetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemotePlmnId != nil {

			if queryParamBuf, err := json.Marshal(*params.RemotePlmnId); err != nil {
				return nil, err
			} else {
				queryValues.Add("remote-plmn-id", string(queryParamBuf))
			}

		}

		if params.DataForwarding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data-forwarding", runtime.ParamLocationQuery, *params.DataForwarding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreferredFullPlmn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferred-full-plmn", runtime.ParamLocationQuery, *params.PreferredFullPlmn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequesterFeatures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester-features", runtime.ParamLocationQuery, *params.RequesterFeatures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RealmId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "realm-id", runtime.ParamLocationQuery, *params.RealmId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage-id", runtime.ParamLocationQuery, *params.StorageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VsmfSupportInd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vsmf-support-ind", runtime.ParamLocationQuery, *params.VsmfSupportInd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GmlcNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gmlc-number", runtime.ParamLocationQuery, *params.GmlcNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptEncoding != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, *params.AcceptEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Encoding", headerParam0)
		}

		if params.IfNoneMatch != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-None-Match", headerParam1)
		}

	}

	return req, nil
}

// NewRetrieveStoredSearchRequest generates requests for RetrieveStoredSearch
func NewRetrieveStoredSearchRequest(server string, searchId SearchId, params *RetrieveStoredSearchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "searchId", runtime.ParamLocationPath, searchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptEncoding != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, *params.AcceptEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Encoding", headerParam0)
		}

	}

	return req, nil
}

// NewRetrieveCompleteSearchRequest generates requests for RetrieveCompleteSearch
func NewRetrieveCompleteSearchRequest(server string, searchId SearchId, params *RetrieveCompleteSearchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "searchId", runtime.ParamLocationPath, searchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searches/%s/complete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptEncoding != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, *params.AcceptEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Encoding", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SearchNFInstancesWithResponse request
	SearchNFInstancesWithResponse(ctx context.Context, params *SearchNFInstancesParams, reqEditors ...RequestEditorFn) (*SearchNFInstancesResponse, error)

	// RetrieveStoredSearchWithResponse request
	RetrieveStoredSearchWithResponse(ctx context.Context, searchId SearchId, params *RetrieveStoredSearchParams, reqEditors ...RequestEditorFn) (*RetrieveStoredSearchResponse, error)

	// RetrieveCompleteSearchWithResponse request
	RetrieveCompleteSearchWithResponse(ctx context.Context, searchId SearchId, params *RetrieveCompleteSearchParams, reqEditors ...RequestEditorFn) (*RetrieveCompleteSearchResponse, error)
}

type SearchNFInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SearchResult
	JSON307                   *externalRef1.RedirectResponse
	JSON308                   *externalRef1.RedirectResponse
	ApplicationproblemJSON400 *externalRef1.N400
	ApplicationproblemJSON401 *externalRef1.N401
	ApplicationproblemJSON403 *externalRef1.N403
	ApplicationproblemJSON404 *externalRef1.N404
	ApplicationproblemJSON411 *externalRef1.N411
	ApplicationproblemJSON413 *externalRef1.N413
	ApplicationproblemJSON415 *externalRef1.N415
	ApplicationproblemJSON429 *externalRef1.N429
	ApplicationproblemJSON500 *externalRef1.N500
	ApplicationproblemJSON501 *externalRef1.N501
	ApplicationproblemJSON503 *externalRef1.N503
}

// Status returns HTTPResponse.Status
func (r SearchNFInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchNFInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveStoredSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200
	JSON307      *externalRef1.RedirectResponse
	JSON308      *externalRef1.RedirectResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveStoredSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveStoredSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveCompleteSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200
	JSON307      *externalRef1.RedirectResponse
	JSON308      *externalRef1.RedirectResponse
}

// Status returns HTTPResponse.Status
func (r RetrieveCompleteSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveCompleteSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SearchNFInstancesWithResponse request returning *SearchNFInstancesResponse
func (c *ClientWithResponses) SearchNFInstancesWithResponse(ctx context.Context, params *SearchNFInstancesParams, reqEditors ...RequestEditorFn) (*SearchNFInstancesResponse, error) {
	rsp, err := c.SearchNFInstances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchNFInstancesResponse(rsp)
}

// RetrieveStoredSearchWithResponse request returning *RetrieveStoredSearchResponse
func (c *ClientWithResponses) RetrieveStoredSearchWithResponse(ctx context.Context, searchId SearchId, params *RetrieveStoredSearchParams, reqEditors ...RequestEditorFn) (*RetrieveStoredSearchResponse, error) {
	rsp, err := c.RetrieveStoredSearch(ctx, searchId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveStoredSearchResponse(rsp)
}

// RetrieveCompleteSearchWithResponse request returning *RetrieveCompleteSearchResponse
func (c *ClientWithResponses) RetrieveCompleteSearchWithResponse(ctx context.Context, searchId SearchId, params *RetrieveCompleteSearchParams, reqEditors ...RequestEditorFn) (*RetrieveCompleteSearchResponse, error) {
	rsp, err := c.RetrieveCompleteSearch(ctx, searchId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveCompleteSearchResponse(rsp)
}

// ParseSearchNFInstancesResponse parses an HTTP response from a SearchNFInstancesWithResponse call
func ParseSearchNFInstancesResponse(rsp *http.Response) (*SearchNFInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchNFInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef1.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef1.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef1.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef1.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef1.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef1.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef1.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef1.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef1.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseRetrieveStoredSearchResponse parses an HTTP response from a RetrieveStoredSearchWithResponse call
func ParseRetrieveStoredSearchResponse(rsp *http.Response) (*RetrieveStoredSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveStoredSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef1.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef1.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	}

	return response, nil
}

// ParseRetrieveCompleteSearchResponse parses an HTTP response from a RetrieveCompleteSearchWithResponse call
func ParseRetrieveCompleteSearchResponse(rsp *http.Response) (*RetrieveCompleteSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveCompleteSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef1.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef1.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Search a collection of NF Instances
	// (GET /nf-instances)
	SearchNFInstances(c *gin.Context, params SearchNFInstancesParams)

	// (GET /searches/{searchId})
	RetrieveStoredSearch(c *gin.Context, searchId SearchId, params RetrieveStoredSearchParams)

	// (GET /searches/{searchId}/complete)
	RetrieveCompleteSearch(c *gin.Context, searchId SearchId, params RetrieveCompleteSearchParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// SearchNFInstances operation middleware
func (siw *ServerInterfaceWrapper) SearchNFInstances(c *gin.Context) {

	var err error

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-disc"})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchNFInstancesParams

	// ------------- Required query parameter "target-nf-type" -------------

	if paramValue := c.Query("target-nf-type"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument target-nf-type is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "target-nf-type", c.Request.URL.Query(), &params.TargetNfType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter target-nf-type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "requester-nf-type" -------------

	if paramValue := c.Query("requester-nf-type"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument requester-nf-type is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "requester-nf-type", c.Request.URL.Query(), &params.RequesterNfType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter requester-nf-type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "requester-nf-instance-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "requester-nf-instance-id", c.Request.URL.Query(), &params.RequesterNfInstanceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter requester-nf-instance-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "service-names" -------------

	err = runtime.BindQueryParameter("form", false, false, "service-names", c.Request.URL.Query(), &params.ServiceNames)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service-names: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "requester-nf-instance-fqdn" -------------

	err = runtime.BindQueryParameter("form", true, false, "requester-nf-instance-fqdn", c.Request.URL.Query(), &params.RequesterNfInstanceFqdn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter requester-nf-instance-fqdn: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "target-plmn-list" -------------

	if paramValue := c.Query("target-plmn-list"); paramValue != "" {

		var value []externalRef1.PlmnId
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'target-plmn-list' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.TargetPlmnList = &value

	}

	// ------------- Optional query parameter "requester-plmn-list" -------------

	if paramValue := c.Query("requester-plmn-list"); paramValue != "" {

		var value []externalRef1.PlmnId
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'requester-plmn-list' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RequesterPlmnList = &value

	}

	// ------------- Optional query parameter "target-nf-instance-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "target-nf-instance-id", c.Request.URL.Query(), &params.TargetNfInstanceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter target-nf-instance-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "target-nf-fqdn" -------------

	err = runtime.BindQueryParameter("form", true, false, "target-nf-fqdn", c.Request.URL.Query(), &params.TargetNfFqdn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter target-nf-fqdn: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "hnrf-uri" -------------

	err = runtime.BindQueryParameter("form", true, false, "hnrf-uri", c.Request.URL.Query(), &params.HnrfUri)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter hnrf-uri: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "snssais" -------------

	if paramValue := c.Query("snssais"); paramValue != "" {

		var value []externalRef1.Snssai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'snssais' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.Snssais = &value

	}

	// ------------- Optional query parameter "requester-snssais" -------------

	if paramValue := c.Query("requester-snssais"); paramValue != "" {

		var value []externalRef1.Snssai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'requester-snssais' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RequesterSnssais = &value

	}

	// ------------- Optional query parameter "plmn-specific-snssai-list" -------------

	if paramValue := c.Query("plmn-specific-snssai-list"); paramValue != "" {

		var value []externalRef2.PlmnSnssai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'plmn-specific-snssai-list' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.PlmnSpecificSnssaiList = &value

	}

	// ------------- Optional query parameter "requester-plmn-specific-snssai-list" -------------

	if paramValue := c.Query("requester-plmn-specific-snssai-list"); paramValue != "" {

		var value []externalRef2.PlmnSnssai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'requester-plmn-specific-snssai-list' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RequesterPlmnSpecificSnssaiList = &value

	}

	// ------------- Optional query parameter "dnn" -------------

	err = runtime.BindQueryParameter("form", true, false, "dnn", c.Request.URL.Query(), &params.Dnn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter dnn: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "nsi-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "nsi-list", c.Request.URL.Query(), &params.NsiList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nsi-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "smf-serving-area" -------------

	err = runtime.BindQueryParameter("form", true, false, "smf-serving-area", c.Request.URL.Query(), &params.SmfServingArea)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter smf-serving-area: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tai" -------------

	if paramValue := c.Query("tai"); paramValue != "" {

		var value externalRef1.Tai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'tai' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.Tai = &value

	}

	// ------------- Optional query parameter "amf-region-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "amf-region-id", c.Request.URL.Query(), &params.AmfRegionId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter amf-region-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amf-set-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "amf-set-id", c.Request.URL.Query(), &params.AmfSetId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter amf-set-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "guami" -------------

	if paramValue := c.Query("guami"); paramValue != "" {

		var value externalRef1.Guami
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'guami' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.Guami = &value

	}

	// ------------- Optional query parameter "supi" -------------

	err = runtime.BindQueryParameter("form", true, false, "supi", c.Request.URL.Query(), &params.Supi)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter supi: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ue-ipv4-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "ue-ipv4-address", c.Request.URL.Query(), &params.UeIpv4Address)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ue-ipv4-address: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ip-domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "ip-domain", c.Request.URL.Query(), &params.IpDomain)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ip-domain: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ue-ipv6-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "ue-ipv6-prefix", c.Request.URL.Query(), &params.UeIpv6Prefix)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ue-ipv6-prefix: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pgw-ind" -------------

	err = runtime.BindQueryParameter("form", true, false, "pgw-ind", c.Request.URL.Query(), &params.PgwInd)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pgw-ind: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pgw" -------------

	err = runtime.BindQueryParameter("form", true, false, "pgw", c.Request.URL.Query(), &params.Pgw)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pgw: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "gpsi" -------------

	err = runtime.BindQueryParameter("form", true, false, "gpsi", c.Request.URL.Query(), &params.Gpsi)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter gpsi: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "external-group-identity" -------------

	err = runtime.BindQueryParameter("form", true, false, "external-group-identity", c.Request.URL.Query(), &params.ExternalGroupIdentity)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter external-group-identity: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "internal-group-identity" -------------

	err = runtime.BindQueryParameter("form", true, false, "internal-group-identity", c.Request.URL.Query(), &params.InternalGroupIdentity)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter internal-group-identity: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pfd-data" -------------

	if paramValue := c.Query("pfd-data"); paramValue != "" {

		var value externalRef2.PfdData
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'pfd-data' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.PfdData = &value

	}

	// ------------- Optional query parameter "data-set" -------------

	err = runtime.BindQueryParameter("form", true, false, "data-set", c.Request.URL.Query(), &params.DataSet)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter data-set: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "routing-indicator" -------------

	err = runtime.BindQueryParameter("form", true, false, "routing-indicator", c.Request.URL.Query(), &params.RoutingIndicator)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter routing-indicator: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "group-id-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "group-id-list", c.Request.URL.Query(), &params.GroupIdList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter group-id-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "dnai-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "dnai-list", c.Request.URL.Query(), &params.DnaiList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter dnai-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pdu-session-types" -------------

	err = runtime.BindQueryParameter("form", false, false, "pdu-session-types", c.Request.URL.Query(), &params.PduSessionTypes)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pdu-session-types: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "event-id-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "event-id-list", c.Request.URL.Query(), &params.EventIdList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter event-id-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "nwdaf-event-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "nwdaf-event-list", c.Request.URL.Query(), &params.NwdafEventList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nwdaf-event-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "supported-features" -------------

	err = runtime.BindQueryParameter("form", true, false, "supported-features", c.Request.URL.Query(), &params.SupportedFeatures)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter supported-features: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "upf-iwk-eps-ind" -------------

	err = runtime.BindQueryParameter("form", true, false, "upf-iwk-eps-ind", c.Request.URL.Query(), &params.UpfIwkEpsInd)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter upf-iwk-eps-ind: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "chf-supported-plmn" -------------

	if paramValue := c.Query("chf-supported-plmn"); paramValue != "" {

		var value externalRef1.PlmnId
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'chf-supported-plmn' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.ChfSupportedPlmn = &value

	}

	// ------------- Optional query parameter "preferred-locality" -------------

	err = runtime.BindQueryParameter("form", true, false, "preferred-locality", c.Request.URL.Query(), &params.PreferredLocality)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter preferred-locality: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "access-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "access-type", c.Request.URL.Query(), &params.AccessType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter access-type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "required-features" -------------

	err = runtime.BindQueryParameter("form", false, false, "required-features", c.Request.URL.Query(), &params.RequiredFeatures)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter required-features: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "complex-query" -------------

	if paramValue := c.Query("complex-query"); paramValue != "" {

		var value externalRef1.ComplexQuery
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'complex-query' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.ComplexQuery = &value

	}

	// ------------- Optional query parameter "max-payload-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-payload-size", c.Request.URL.Query(), &params.MaxPayloadSize)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter max-payload-size: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "max-payload-size-ext" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-payload-size-ext", c.Request.URL.Query(), &params.MaxPayloadSizeExt)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter max-payload-size-ext: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "atsss-capability" -------------

	if paramValue := c.Query("atsss-capability"); paramValue != "" {

		var value externalRef1.AtsssCapability
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'atsss-capability' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.AtsssCapability = &value

	}

	// ------------- Optional query parameter "upf-ue-ip-addr-ind" -------------

	err = runtime.BindQueryParameter("form", true, false, "upf-ue-ip-addr-ind", c.Request.URL.Query(), &params.UpfUeIpAddrInd)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter upf-ue-ip-addr-ind: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "client-type" -------------

	if paramValue := c.Query("client-type"); paramValue != "" {

		var value string
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'client-type' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.ClientType = &value

	}

	// ------------- Optional query parameter "lmf-id" -------------

	if paramValue := c.Query("lmf-id"); paramValue != "" {

		var value string
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'lmf-id' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.LmfId = &value

	}

	// ------------- Optional query parameter "an-node-type" -------------

	if paramValue := c.Query("an-node-type"); paramValue != "" {

		var value externalRef2.AnNodeType
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'an-node-type' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.AnNodeType = &value

	}

	// ------------- Optional query parameter "rat-type" -------------

	if paramValue := c.Query("rat-type"); paramValue != "" {

		var value externalRef1.RatType
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'rat-type' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RatType = &value

	}

	// ------------- Optional query parameter "preferred-tai" -------------

	if paramValue := c.Query("preferred-tai"); paramValue != "" {

		var value externalRef1.Tai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'preferred-tai' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.PreferredTai = &value

	}

	// ------------- Optional query parameter "preferred-nf-instances" -------------

	err = runtime.BindQueryParameter("form", false, false, "preferred-nf-instances", c.Request.URL.Query(), &params.PreferredNfInstances)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter preferred-nf-instances: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "target-snpn" -------------

	if paramValue := c.Query("target-snpn"); paramValue != "" {

		var value externalRef1.PlmnIdNid
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'target-snpn' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.TargetSnpn = &value

	}

	// ------------- Optional query parameter "requester-snpn-list" -------------

	if paramValue := c.Query("requester-snpn-list"); paramValue != "" {

		var value []externalRef1.PlmnIdNid
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'requester-snpn-list' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RequesterSnpnList = &value

	}

	// ------------- Optional query parameter "af-ee-data" -------------

	if paramValue := c.Query("af-ee-data"); paramValue != "" {

		var value externalRef2.AfEventExposureData
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'af-ee-data' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.AfEeData = &value

	}

	// ------------- Optional query parameter "w-agf-info" -------------

	if paramValue := c.Query("w-agf-info"); paramValue != "" {

		var value externalRef2.WAgfInfo
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'w-agf-info' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.WAgfInfo = &value

	}

	// ------------- Optional query parameter "tngf-info" -------------

	if paramValue := c.Query("tngf-info"); paramValue != "" {

		var value externalRef2.TngfInfo
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'tngf-info' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.TngfInfo = &value

	}

	// ------------- Optional query parameter "twif-info" -------------

	if paramValue := c.Query("twif-info"); paramValue != "" {

		var value externalRef2.TwifInfo
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'twif-info' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.TwifInfo = &value

	}

	// ------------- Optional query parameter "target-nf-set-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "target-nf-set-id", c.Request.URL.Query(), &params.TargetNfSetId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter target-nf-set-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "target-nf-service-set-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "target-nf-service-set-id", c.Request.URL.Query(), &params.TargetNfServiceSetId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter target-nf-service-set-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "nef-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "nef-id", c.Request.URL.Query(), &params.NefId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nef-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "notification-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "notification-type", c.Request.URL.Query(), &params.NotificationType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter notification-type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "n1-msg-class" -------------

	err = runtime.BindQueryParameter("form", true, false, "n1-msg-class", c.Request.URL.Query(), &params.N1MsgClass)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter n1-msg-class: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "n2-info-class" -------------

	err = runtime.BindQueryParameter("form", true, false, "n2-info-class", c.Request.URL.Query(), &params.N2InfoClass)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter n2-info-class: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "serving-scope" -------------

	err = runtime.BindQueryParameter("form", false, false, "serving-scope", c.Request.URL.Query(), &params.ServingScope)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter serving-scope: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "imsi" -------------

	err = runtime.BindQueryParameter("form", true, false, "imsi", c.Request.URL.Query(), &params.Imsi)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter imsi: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ims-private-identity" -------------

	err = runtime.BindQueryParameter("form", true, false, "ims-private-identity", c.Request.URL.Query(), &params.ImsPrivateIdentity)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ims-private-identity: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ims-public-identity" -------------

	err = runtime.BindQueryParameter("form", true, false, "ims-public-identity", c.Request.URL.Query(), &params.ImsPublicIdentity)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ims-public-identity: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "msisdn" -------------

	err = runtime.BindQueryParameter("form", true, false, "msisdn", c.Request.URL.Query(), &params.Msisdn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter msisdn: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "preferred-api-versions" -------------

	if paramValue := c.Query("preferred-api-versions"); paramValue != "" {

		var value map[string]string
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'preferred-api-versions' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.PreferredApiVersions = &value

	}

	// ------------- Optional query parameter "v2x-support-ind" -------------

	err = runtime.BindQueryParameter("form", true, false, "v2x-support-ind", c.Request.URL.Query(), &params.V2xSupportInd)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter v2x-support-ind: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "redundant-gtpu" -------------

	err = runtime.BindQueryParameter("form", true, false, "redundant-gtpu", c.Request.URL.Query(), &params.RedundantGtpu)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter redundant-gtpu: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "redundant-transport" -------------

	err = runtime.BindQueryParameter("form", true, false, "redundant-transport", c.Request.URL.Query(), &params.RedundantTransport)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter redundant-transport: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ipups" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipups", c.Request.URL.Query(), &params.Ipups)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ipups: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "scp-domain-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "scp-domain-list", c.Request.URL.Query(), &params.ScpDomainList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter scp-domain-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "address-domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-domain", c.Request.URL.Query(), &params.AddressDomain)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter address-domain: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ipv4-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipv4-addr", c.Request.URL.Query(), &params.Ipv4Addr)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ipv4-addr: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ipv6-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipv6-prefix", c.Request.URL.Query(), &params.Ipv6Prefix)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ipv6-prefix: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "served-nf-set-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "served-nf-set-id", c.Request.URL.Query(), &params.ServedNfSetId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter served-nf-set-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "remote-plmn-id" -------------

	if paramValue := c.Query("remote-plmn-id"); paramValue != "" {

		var value externalRef1.PlmnId
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'remote-plmn-id' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RemotePlmnId = &value

	}

	// ------------- Optional query parameter "data-forwarding" -------------

	err = runtime.BindQueryParameter("form", true, false, "data-forwarding", c.Request.URL.Query(), &params.DataForwarding)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter data-forwarding: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "preferred-full-plmn" -------------

	err = runtime.BindQueryParameter("form", true, false, "preferred-full-plmn", c.Request.URL.Query(), &params.PreferredFullPlmn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter preferred-full-plmn: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "requester-features" -------------

	err = runtime.BindQueryParameter("form", true, false, "requester-features", c.Request.URL.Query(), &params.RequesterFeatures)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter requester-features: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "realm-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "realm-id", c.Request.URL.Query(), &params.RealmId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter realm-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "storage-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "storage-id", c.Request.URL.Query(), &params.StorageId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter storage-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "vsmf-support-ind" -------------

	err = runtime.BindQueryParameter("form", true, false, "vsmf-support-ind", c.Request.URL.Query(), &params.VsmfSupportInd)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter vsmf-support-ind: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "gmlc-number" -------------

	err = runtime.BindQueryParameter("form", true, false, "gmlc-number", c.Request.URL.Query(), &params.GmlcNumber)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter gmlc-number: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, valueList[0], &AcceptEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter If-None-Match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SearchNFInstances(c, params)
}

// RetrieveStoredSearch operation middleware
func (siw *ServerInterfaceWrapper) RetrieveStoredSearch(c *gin.Context) {

	var err error

	// ------------- Path parameter "searchId" -------------
	var searchId SearchId

	err = runtime.BindStyledParameter("simple", false, "searchId", c.Param("searchId"), &searchId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter searchId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-disc"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveStoredSearchParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, valueList[0], &AcceptEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RetrieveStoredSearch(c, searchId, params)
}

// RetrieveCompleteSearch operation middleware
func (siw *ServerInterfaceWrapper) RetrieveCompleteSearch(c *gin.Context) {

	var err error

	// ------------- Path parameter "searchId" -------------
	var searchId SearchId

	err = runtime.BindStyledParameter("simple", false, "searchId", c.Param("searchId"), &searchId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter searchId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-disc"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveCompleteSearchParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, valueList[0], &AcceptEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RetrieveCompleteSearch(c, searchId, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/nf-instances", wrapper.SearchNFInstances)
	router.GET(options.BaseURL+"/searches/:searchId", wrapper.RetrieveStoredSearch)
	router.GET(options.BaseURL+"/searches/:searchId/complete", wrapper.RetrieveCompleteSearch)
}

type N200ResponseHeaders struct {
	CacheControl    string
	ContentEncoding string
	ETag            string
}
type N200JSONResponse struct {
	Body StoredSearchResult

	Headers N200ResponseHeaders
}

type SearchNFInstancesRequestObject struct {
	Params SearchNFInstancesParams
}

type SearchNFInstancesResponseObject interface {
	VisitSearchNFInstancesResponse(w http.ResponseWriter) error
}

type SearchNFInstances200ResponseHeaders struct {
	CacheControl    string
	ContentEncoding string
	ETag            string
}

type SearchNFInstances200JSONResponse struct {
	Body    SearchResult
	Headers SearchNFInstances200ResponseHeaders
}

func (response SearchNFInstances200JSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Encoding", fmt.Sprint(response.Headers.ContentEncoding))
	w.Header().Set("ETag", fmt.Sprint(response.Headers.ETag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type SearchNFInstances307ResponseHeaders struct {
	Location string
}

type SearchNFInstances307JSONResponse struct {
	Body    externalRef1.RedirectResponse
	Headers SearchNFInstances307ResponseHeaders
}

func (response SearchNFInstances307JSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type SearchNFInstances308ResponseHeaders struct {
	Location string
}

type SearchNFInstances308JSONResponse struct {
	Body    externalRef1.RedirectResponse
	Headers SearchNFInstances308ResponseHeaders
}

func (response SearchNFInstances308JSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type SearchNFInstances400ApplicationProblemPlusJSONResponse struct {
	externalRef1.N400ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances400ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstances401ApplicationProblemPlusJSONResponse struct {
	externalRef1.N401ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances401ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstances403ApplicationProblemPlusJSONResponse struct {
	externalRef1.N403ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances403ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstances404ApplicationProblemPlusJSONResponse struct {
	externalRef1.N404ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances404ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstances406Response externalRef1.N406Response

func (response SearchNFInstances406Response) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.WriteHeader(406)
	return nil
}

type SearchNFInstances411ApplicationProblemPlusJSONResponse struct {
	externalRef1.N411ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances411ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstances413ApplicationProblemPlusJSONResponse struct {
	externalRef1.N413ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances413ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstances415ApplicationProblemPlusJSONResponse struct {
	externalRef1.N415ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances415ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstances429ApplicationProblemPlusJSONResponse struct {
	externalRef1.N429ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances429ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstances500ApplicationProblemPlusJSONResponse struct {
	externalRef1.N500ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances500ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstances501ApplicationProblemPlusJSONResponse struct {
	externalRef1.N501ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances501ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstances503ApplicationProblemPlusJSONResponse struct {
	externalRef1.N503ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances503ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type SearchNFInstancesdefaultResponse struct {
	StatusCode int
}

func (response SearchNFInstancesdefaultResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.WriteHeader(response.StatusCode)
	return nil
}

type RetrieveStoredSearchRequestObject struct {
	SearchId SearchId `json:"searchId"`
	Params   RetrieveStoredSearchParams
}

type RetrieveStoredSearchResponseObject interface {
	VisitRetrieveStoredSearchResponse(w http.ResponseWriter) error
}

type RetrieveStoredSearch200JSONResponse struct{ N200JSONResponse }

func (response RetrieveStoredSearch200JSONResponse) VisitRetrieveStoredSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Encoding", fmt.Sprint(response.Headers.ContentEncoding))
	w.Header().Set("ETag", fmt.Sprint(response.Headers.ETag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveStoredSearch307ResponseHeaders struct {
	Location string
}

type RetrieveStoredSearch307JSONResponse struct {
	Body    externalRef1.RedirectResponse
	Headers RetrieveStoredSearch307ResponseHeaders
}

func (response RetrieveStoredSearch307JSONResponse) VisitRetrieveStoredSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveStoredSearch308ResponseHeaders struct {
	Location string
}

type RetrieveStoredSearch308JSONResponse struct {
	Body    externalRef1.RedirectResponse
	Headers RetrieveStoredSearch308ResponseHeaders
}

func (response RetrieveStoredSearch308JSONResponse) VisitRetrieveStoredSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveCompleteSearchRequestObject struct {
	SearchId SearchId `json:"searchId"`
	Params   RetrieveCompleteSearchParams
}

type RetrieveCompleteSearchResponseObject interface {
	VisitRetrieveCompleteSearchResponse(w http.ResponseWriter) error
}

type RetrieveCompleteSearch200JSONResponse struct{ N200JSONResponse }

func (response RetrieveCompleteSearch200JSONResponse) VisitRetrieveCompleteSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Encoding", fmt.Sprint(response.Headers.ContentEncoding))
	w.Header().Set("ETag", fmt.Sprint(response.Headers.ETag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveCompleteSearch307ResponseHeaders struct {
	Location string
}

type RetrieveCompleteSearch307JSONResponse struct {
	Body    externalRef1.RedirectResponse
	Headers RetrieveCompleteSearch307ResponseHeaders
}

func (response RetrieveCompleteSearch307JSONResponse) VisitRetrieveCompleteSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveCompleteSearch308ResponseHeaders struct {
	Location string
}

type RetrieveCompleteSearch308JSONResponse struct {
	Body    externalRef1.RedirectResponse
	Headers RetrieveCompleteSearch308ResponseHeaders
}

func (response RetrieveCompleteSearch308JSONResponse) VisitRetrieveCompleteSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Search a collection of NF Instances
	// (GET /nf-instances)
	SearchNFInstances(ctx context.Context, request SearchNFInstancesRequestObject) (SearchNFInstancesResponseObject, error)

	// (GET /searches/{searchId})
	RetrieveStoredSearch(ctx context.Context, request RetrieveStoredSearchRequestObject) (RetrieveStoredSearchResponseObject, error)

	// (GET /searches/{searchId}/complete)
	RetrieveCompleteSearch(ctx context.Context, request RetrieveCompleteSearchRequestObject) (RetrieveCompleteSearchResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// SearchNFInstances operation middleware
func (sh *strictHandler) SearchNFInstances(ctx *gin.Context, params SearchNFInstancesParams) {
	var request SearchNFInstancesRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SearchNFInstances(ctx, request.(SearchNFInstancesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SearchNFInstances")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(SearchNFInstancesResponseObject); ok {
		if err := validResponse.VisitSearchNFInstancesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// RetrieveStoredSearch operation middleware
func (sh *strictHandler) RetrieveStoredSearch(ctx *gin.Context, searchId SearchId, params RetrieveStoredSearchParams) {
	var request RetrieveStoredSearchRequestObject

	request.SearchId = searchId
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RetrieveStoredSearch(ctx, request.(RetrieveStoredSearchRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RetrieveStoredSearch")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(RetrieveStoredSearchResponseObject); ok {
		if err := validResponse.VisitRetrieveStoredSearchResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// RetrieveCompleteSearch operation middleware
func (sh *strictHandler) RetrieveCompleteSearch(ctx *gin.Context, searchId SearchId, params RetrieveCompleteSearchParams) {
	var request RetrieveCompleteSearchRequestObject

	request.SearchId = searchId
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RetrieveCompleteSearch(ctx, request.(RetrieveCompleteSearchRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RetrieveCompleteSearch")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(RetrieveCompleteSearchResponseObject); ok {
		if err := validResponse.VisitRetrieveCompleteSearchResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}
