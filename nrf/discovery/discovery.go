// Package discovery provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.1-0.20240123090344-d326c01d279a DO NOT EDIT.
package discovery

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	externalRef0 "github.com/ShouheiNishi/openapi5g/models"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

const (
	OAuth2ClientCredentialsScopes = "oAuth2ClientCredentials.Scopes"
)

// SearchId defines model for searchId.
type SearchId = string

// N200 Contains a complete search result (i.e. a number of discovered NF Instances), stored by NRF as a consequence of a prior search result (Original definition in TS29510_Nnrf_NFDiscovery.yaml#/components/schemas/StoredSearchResult)
type N200 = externalRef0.StoredSearchResult

// SearchNFInstancesParams defines parameters for SearchNFInstances.
type SearchNFInstancesParams struct {
	// TargetNfType Type of the target NF
	TargetNfType externalRef0.NFType `form:"target-nf-type" json:"target-nf-type"`

	// RequesterNfType Type of the requester NF
	RequesterNfType externalRef0.NFType `form:"requester-nf-type" json:"requester-nf-type"`

	// RequesterNfInstanceId NfInstanceId of the requester NF
	RequesterNfInstanceId *externalRef0.NfInstanceId `form:"requester-nf-instance-id,omitempty" json:"requester-nf-instance-id,omitempty"`

	// ServiceNames Names of the services offered by the NF
	ServiceNames *[]externalRef0.ServiceName `form:"service-names,omitempty" json:"service-names,omitempty"`

	// RequesterNfInstanceFqdn FQDN of the requester NF
	RequesterNfInstanceFqdn *externalRef0.Fqdn `form:"requester-nf-instance-fqdn,omitempty" json:"requester-nf-instance-fqdn,omitempty"`

	// TargetPlmnList Id of the PLMN of the target NF
	TargetPlmnList *[]externalRef0.PlmnId `form:"target-plmn-list,omitempty" json:"target-plmn-list,omitempty"`

	// RequesterPlmnList Id of the PLMN where the NF issuing the Discovery request is located
	RequesterPlmnList *[]externalRef0.PlmnId `form:"requester-plmn-list,omitempty" json:"requester-plmn-list,omitempty"`

	// TargetNfInstanceId Identity of the NF instance being discovered
	TargetNfInstanceId *externalRef0.NfInstanceId `form:"target-nf-instance-id,omitempty" json:"target-nf-instance-id,omitempty"`

	// TargetNfFqdn FQDN of the NF instance being discovered
	TargetNfFqdn *externalRef0.Fqdn `form:"target-nf-fqdn,omitempty" json:"target-nf-fqdn,omitempty"`

	// HnrfUri Uri of the home NRF
	HnrfUri *externalRef0.Uri `form:"hnrf-uri,omitempty" json:"hnrf-uri,omitempty"`

	// Snssais Slice info of the target NF
	Snssais *[]externalRef0.Snssai `form:"snssais,omitempty" json:"snssais,omitempty"`

	// RequesterSnssais Slice info of the requester NF
	RequesterSnssais *[]externalRef0.Snssai `form:"requester-snssais,omitempty" json:"requester-snssais,omitempty"`

	// PlmnSpecificSnssaiList PLMN specific Slice info of the target NF
	PlmnSpecificSnssaiList *[]externalRef0.PlmnSnssai `form:"plmn-specific-snssai-list,omitempty" json:"plmn-specific-snssai-list,omitempty"`

	// RequesterPlmnSpecificSnssaiList PLMN-specific slice info of the NF issuing the Discovery request
	RequesterPlmnSpecificSnssaiList *[]externalRef0.PlmnSnssai `form:"requester-plmn-specific-snssai-list,omitempty" json:"requester-plmn-specific-snssai-list,omitempty"`

	// Dnn Dnn supported by the BSF, SMF or UPF
	Dnn *externalRef0.Dnn `form:"dnn,omitempty" json:"dnn,omitempty"`

	// NsiList NSI IDs that are served by the services being discovered
	NsiList        *[]string `form:"nsi-list,omitempty" json:"nsi-list,omitempty"`
	SmfServingArea *string   `form:"smf-serving-area,omitempty" json:"smf-serving-area,omitempty"`

	// Tai Tracking Area Identity
	Tai *externalRef0.Tai `form:"tai,omitempty" json:"tai,omitempty"`

	// AmfRegionId AMF Region Identity
	AmfRegionId *externalRef0.AmfRegionId `form:"amf-region-id,omitempty" json:"amf-region-id,omitempty"`

	// AmfSetId AMF Set Identity
	AmfSetId *externalRef0.AmfSetId `form:"amf-set-id,omitempty" json:"amf-set-id,omitempty"`

	// Guami Guami used to search for an appropriate AMF
	Guami *externalRef0.Guami `form:"guami,omitempty" json:"guami,omitempty"`

	// Supi SUPI of the user
	Supi *externalRef0.Supi `form:"supi,omitempty" json:"supi,omitempty"`

	// UeIpv4Address IPv4 address of the UE
	UeIpv4Address *externalRef0.Ipv4Addr `form:"ue-ipv4-address,omitempty" json:"ue-ipv4-address,omitempty"`

	// IpDomain IP domain of the UE, which supported by BSF
	IpDomain *string `form:"ip-domain,omitempty" json:"ip-domain,omitempty"`

	// UeIpv6Prefix IPv6 prefix of the UE
	UeIpv6Prefix *externalRef0.Ipv6Prefix `form:"ue-ipv6-prefix,omitempty" json:"ue-ipv6-prefix,omitempty"`

	// PgwInd Combined PGW-C and SMF or a standalone SMF
	PgwInd *bool `form:"pgw-ind,omitempty" json:"pgw-ind,omitempty"`

	// Pgw PGW FQDN of a combined PGW-C and SMF
	Pgw *externalRef0.Fqdn `form:"pgw,omitempty" json:"pgw,omitempty"`

	// Gpsi GPSI of the user
	Gpsi *externalRef0.Gpsi `form:"gpsi,omitempty" json:"gpsi,omitempty"`

	// ExternalGroupIdentity external group identifier of the user
	ExternalGroupIdentity *externalRef0.ExtGroupId `form:"external-group-identity,omitempty" json:"external-group-identity,omitempty"`

	// InternalGroupIdentity internal group identifier of the user
	InternalGroupIdentity *externalRef0.GroupId `form:"internal-group-identity,omitempty" json:"internal-group-identity,omitempty"`

	// PfdData PFD data
	PfdData *externalRef0.NrfPfdData `form:"pfd-data,omitempty" json:"pfd-data,omitempty"`

	// DataSet data set supported by the NF
	DataSet *externalRef0.DataSetId `form:"data-set,omitempty" json:"data-set,omitempty"`

	// RoutingIndicator routing indicator in SUCI
	RoutingIndicator *string `form:"routing-indicator,omitempty" json:"routing-indicator,omitempty"`

	// GroupIdList Group IDs of the NFs being discovered
	GroupIdList *[]externalRef0.NfGroupId `form:"group-id-list,omitempty" json:"group-id-list,omitempty"`

	// DnaiList Data network access identifiers of the NFs being discovered
	DnaiList *[]externalRef0.Dnai `form:"dnai-list,omitempty" json:"dnai-list,omitempty"`

	// PduSessionTypes list of PDU Session Type required to be supported by the target NF
	PduSessionTypes *[]externalRef0.PduSessionType `form:"pdu-session-types,omitempty" json:"pdu-session-types,omitempty"`

	// EventIdList Analytics event(s) requested to be supported by the Nnwdaf_AnalyticsInfo service
	EventIdList *[]string `form:"event-id-list,omitempty" json:"event-id-list,omitempty"`

	// NwdafEventList Analytics event(s) requested to be supported by the Nnwdaf_EventsSubscription service.
	NwdafEventList *[]string `form:"nwdaf-event-list,omitempty" json:"nwdaf-event-list,omitempty"`

	// SupportedFeatures Features required to be supported by the target NF
	SupportedFeatures *externalRef0.SupportedFeatures `form:"supported-features,omitempty" json:"supported-features,omitempty"`

	// UpfIwkEpsInd UPF supporting interworking with EPS or not
	UpfIwkEpsInd *bool `form:"upf-iwk-eps-ind,omitempty" json:"upf-iwk-eps-ind,omitempty"`

	// ChfSupportedPlmn PLMN ID supported by a CHF
	ChfSupportedPlmn *externalRef0.PlmnId `form:"chf-supported-plmn,omitempty" json:"chf-supported-plmn,omitempty"`

	// PreferredLocality preferred target NF location
	PreferredLocality *string `form:"preferred-locality,omitempty" json:"preferred-locality,omitempty"`

	// AccessType AccessType supported by the target NF
	AccessType *externalRef0.AccessType `form:"access-type,omitempty" json:"access-type,omitempty"`

	// Limit Maximum number of NFProfiles to return in the response
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// RequiredFeatures Features required to be supported by the target NF
	RequiredFeatures *[]externalRef0.SupportedFeatures `form:"required-features,omitempty" json:"required-features,omitempty"`

	// ComplexQuery the complex query condition expression
	ComplexQuery *externalRef0.ComplexQuery `form:"complex-query,omitempty" json:"complex-query,omitempty"`

	// MaxPayloadSize Maximum payload size of the response expressed in kilo octets
	MaxPayloadSize *int `form:"max-payload-size,omitempty" json:"max-payload-size,omitempty"`

	// MaxPayloadSizeExt Extended query for maximum payload size of the response expressed in kilo octets
	MaxPayloadSizeExt *int `form:"max-payload-size-ext,omitempty" json:"max-payload-size-ext,omitempty"`

	// AtsssCapability ATSSS Capability
	AtsssCapability *externalRef0.AtsssCapability `form:"atsss-capability,omitempty" json:"atsss-capability,omitempty"`

	// UpfUeIpAddrInd UPF supporting allocating UE IP addresses/prefixes
	UpfUeIpAddrInd *bool `form:"upf-ue-ip-addr-ind,omitempty" json:"upf-ue-ip-addr-ind,omitempty"`

	// ClientType Requested client type served by the NF
	ClientType *string `form:"client-type,omitempty" json:"client-type,omitempty"`

	// LmfId LMF identification to be discovered
	LmfId *string `form:"lmf-id,omitempty" json:"lmf-id,omitempty"`

	// AnNodeType Requested AN node type served by the NF
	AnNodeType *externalRef0.AnNodeType `form:"an-node-type,omitempty" json:"an-node-type,omitempty"`

	// RatType Requested RAT type served by the NF
	RatType *externalRef0.RatType `form:"rat-type,omitempty" json:"rat-type,omitempty"`

	// PreferredTai preferred Tracking Area Identity
	PreferredTai *externalRef0.Tai `form:"preferred-tai,omitempty" json:"preferred-tai,omitempty"`

	// PreferredNfInstances preferred NF Instances
	PreferredNfInstances *[]externalRef0.NfInstanceId `form:"preferred-nf-instances,omitempty" json:"preferred-nf-instances,omitempty"`

	// TargetSnpn Target SNPN Identity
	TargetSnpn *externalRef0.PlmnIdNid `form:"target-snpn,omitempty" json:"target-snpn,omitempty"`

	// RequesterSnpnList SNPN ID(s) of the NF instance issuing the Discovery request
	RequesterSnpnList *[]externalRef0.PlmnIdNid `form:"requester-snpn-list,omitempty" json:"requester-snpn-list,omitempty"`

	// AfEeData NEF exposured by the AF
	AfEeData *externalRef0.AfEventExposureData `form:"af-ee-data,omitempty" json:"af-ee-data,omitempty"`

	// WAgfInfo UPF collocated with W-AGF
	WAgfInfo *externalRef0.WAgfInfo `form:"w-agf-info,omitempty" json:"w-agf-info,omitempty"`

	// TngfInfo UPF collocated with TNGF
	TngfInfo *externalRef0.TngfInfo `form:"tngf-info,omitempty" json:"tngf-info,omitempty"`

	// TwifInfo UPF collocated with TWIF
	TwifInfo *externalRef0.TwifInfo `form:"twif-info,omitempty" json:"twif-info,omitempty"`

	// TargetNfSetId Target NF Set ID
	TargetNfSetId *externalRef0.NfSetId `form:"target-nf-set-id,omitempty" json:"target-nf-set-id,omitempty"`

	// TargetNfServiceSetId Target NF Service Set ID
	TargetNfServiceSetId *externalRef0.NfServiceSetId `form:"target-nf-service-set-id,omitempty" json:"target-nf-service-set-id,omitempty"`

	// NefId NEF ID
	NefId *externalRef0.NefId `form:"nef-id,omitempty" json:"nef-id,omitempty"`

	// NotificationType Notification Type
	NotificationType *externalRef0.NotificationType `form:"notification-type,omitempty" json:"notification-type,omitempty"`

	// N1MsgClass N1 Message Class
	N1MsgClass *externalRef0.N1MessageClass `form:"n1-msg-class,omitempty" json:"n1-msg-class,omitempty"`

	// N2InfoClass N2 Information Class
	N2InfoClass *externalRef0.N2InformationClass `form:"n2-info-class,omitempty" json:"n2-info-class,omitempty"`

	// ServingScope areas that can be served by the target NF
	ServingScope *[]string `form:"serving-scope,omitempty" json:"serving-scope,omitempty"`

	// Imsi IMSI of the requester UE to search for an appropriate NF (e.g. HSS)
	Imsi *string `form:"imsi,omitempty" json:"imsi,omitempty"`

	// ImsPrivateIdentity IMPI of the requester UE to search for a target HSS
	ImsPrivateIdentity *string `form:"ims-private-identity,omitempty" json:"ims-private-identity,omitempty"`

	// ImsPublicIdentity IMS Public Identity of the requester UE to search for a target HSS
	ImsPublicIdentity *string `form:"ims-public-identity,omitempty" json:"ims-public-identity,omitempty"`

	// Msisdn MSISDN of the requester UE to search for a target HSS
	Msisdn *string `form:"msisdn,omitempty" json:"msisdn,omitempty"`

	// PreferredApiVersions Preferred API version of the services to be discovered
	PreferredApiVersions *map[string]string `form:"preferred-api-versions,omitempty" json:"preferred-api-versions,omitempty"`

	// V2xSupportInd PCF supports V2X
	V2xSupportInd *bool `form:"v2x-support-ind,omitempty" json:"v2x-support-ind,omitempty"`

	// RedundantGtpu UPF supports redundant gtp-u to be discovered
	RedundantGtpu *bool `form:"redundant-gtpu,omitempty" json:"redundant-gtpu,omitempty"`

	// RedundantTransport UPF supports redundant transport path to be discovered
	RedundantTransport *bool `form:"redundant-transport,omitempty" json:"redundant-transport,omitempty"`

	// Ipups UPF which is configured for IPUPS functionality to be discovered
	Ipups *bool `form:"ipups,omitempty" json:"ipups,omitempty"`

	// ScpDomainList SCP domains the target SCP belongs to
	ScpDomainList *[]string `form:"scp-domain-list,omitempty" json:"scp-domain-list,omitempty"`

	// AddressDomain Address domain reachable through the SCP
	AddressDomain *externalRef0.Fqdn `form:"address-domain,omitempty" json:"address-domain,omitempty"`

	// Ipv4Addr IPv4 address reachable through the SCP
	Ipv4Addr *externalRef0.Ipv4Addr `form:"ipv4-addr,omitempty" json:"ipv4-addr,omitempty"`

	// Ipv6Prefix IPv6 prefix reachable through the SCP
	Ipv6Prefix *externalRef0.Ipv6Prefix `form:"ipv6-prefix,omitempty" json:"ipv6-prefix,omitempty"`

	// ServedNfSetId NF Set ID served by the SCP
	ServedNfSetId *externalRef0.NfSetId `form:"served-nf-set-id,omitempty" json:"served-nf-set-id,omitempty"`

	// RemotePlmnId Id of the PLMN reachable through the SCP
	RemotePlmnId *externalRef0.PlmnId `form:"remote-plmn-id,omitempty" json:"remote-plmn-id,omitempty"`

	// DataForwarding UPF Instance(s) configured for data forwarding are requested
	DataForwarding *bool `form:"data-forwarding,omitempty" json:"data-forwarding,omitempty"`

	// PreferredFullPlmn NF Instance(s) serving the full PLMN are preferred
	PreferredFullPlmn *bool `form:"preferred-full-plmn,omitempty" json:"preferred-full-plmn,omitempty"`

	// RequesterFeatures Features supported by the NF Service Consumer that is invoking the Nnrf_NFDiscovery service
	RequesterFeatures *externalRef0.SupportedFeatures `form:"requester-features,omitempty" json:"requester-features,omitempty"`

	// RealmId realm-id to search for an appropriate UDSF
	RealmId *string `form:"realm-id,omitempty" json:"realm-id,omitempty"`

	// StorageId storage-id to search for an appropriate UDSF
	StorageId *string `form:"storage-id,omitempty" json:"storage-id,omitempty"`

	// VsmfSupportInd V-SMF capability supported by the target NF instance(s)
	VsmfSupportInd *bool `form:"vsmf-support-ind,omitempty" json:"vsmf-support-ind,omitempty"`

	// GmlcNumber The GMLC Number supported by the GMLC
	GmlcNumber *string `form:"gmlc-number,omitempty" json:"gmlc-number,omitempty"`

	// AcceptEncoding Accept-Encoding, described in IETF RFC 7231
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// IfNoneMatch Validator for conditional requests, as described in IETF RFC 7232, 3.2
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// RetrieveStoredSearchParams defines parameters for RetrieveStoredSearch.
type RetrieveStoredSearchParams struct {
	// AcceptEncoding Accept-Encoding, described in IETF RFC 7231
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`
}

// RetrieveCompleteSearchParams defines parameters for RetrieveCompleteSearch.
type RetrieveCompleteSearchParams struct {
	// AcceptEncoding Accept-Encoding, described in IETF RFC 7231
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SearchNFInstances request
	SearchNFInstances(ctx context.Context, params *SearchNFInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveStoredSearch request
	RetrieveStoredSearch(ctx context.Context, searchId SearchId, params *RetrieveStoredSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveCompleteSearch request
	RetrieveCompleteSearch(ctx context.Context, searchId SearchId, params *RetrieveCompleteSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SearchNFInstances(ctx context.Context, params *SearchNFInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchNFInstancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveStoredSearch(ctx context.Context, searchId SearchId, params *RetrieveStoredSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveStoredSearchRequest(c.Server, searchId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveCompleteSearch(ctx context.Context, searchId SearchId, params *RetrieveCompleteSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveCompleteSearchRequest(c.Server, searchId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSearchNFInstancesRequest generates requests for SearchNFInstances
func NewSearchNFInstancesRequest(server string, params *SearchNFInstancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nf-instances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-nf-type", runtime.ParamLocationQuery, params.TargetNfType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester-nf-type", runtime.ParamLocationQuery, params.RequesterNfType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RequesterNfInstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester-nf-instance-id", runtime.ParamLocationQuery, *params.RequesterNfInstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServiceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "service-names", runtime.ParamLocationQuery, *params.ServiceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequesterNfInstanceFqdn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester-nf-instance-fqdn", runtime.ParamLocationQuery, *params.RequesterNfInstanceFqdn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetPlmnList != nil {

			if queryParamBuf, err := json.Marshal(*params.TargetPlmnList); err != nil {
				return nil, err
			} else {
				queryValues.Add("target-plmn-list", string(queryParamBuf))
			}

		}

		if params.RequesterPlmnList != nil {

			if queryParamBuf, err := json.Marshal(*params.RequesterPlmnList); err != nil {
				return nil, err
			} else {
				queryValues.Add("requester-plmn-list", string(queryParamBuf))
			}

		}

		if params.TargetNfInstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-nf-instance-id", runtime.ParamLocationQuery, *params.TargetNfInstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetNfFqdn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-nf-fqdn", runtime.ParamLocationQuery, *params.TargetNfFqdn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HnrfUri != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hnrf-uri", runtime.ParamLocationQuery, *params.HnrfUri); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Snssais != nil {

			if queryParamBuf, err := json.Marshal(*params.Snssais); err != nil {
				return nil, err
			} else {
				queryValues.Add("snssais", string(queryParamBuf))
			}

		}

		if params.RequesterSnssais != nil {

			if queryParamBuf, err := json.Marshal(*params.RequesterSnssais); err != nil {
				return nil, err
			} else {
				queryValues.Add("requester-snssais", string(queryParamBuf))
			}

		}

		if params.PlmnSpecificSnssaiList != nil {

			if queryParamBuf, err := json.Marshal(*params.PlmnSpecificSnssaiList); err != nil {
				return nil, err
			} else {
				queryValues.Add("plmn-specific-snssai-list", string(queryParamBuf))
			}

		}

		if params.RequesterPlmnSpecificSnssaiList != nil {

			if queryParamBuf, err := json.Marshal(*params.RequesterPlmnSpecificSnssaiList); err != nil {
				return nil, err
			} else {
				queryValues.Add("requester-plmn-specific-snssai-list", string(queryParamBuf))
			}

		}

		if params.Dnn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dnn", runtime.ParamLocationQuery, *params.Dnn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NsiList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "nsi-list", runtime.ParamLocationQuery, *params.NsiList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SmfServingArea != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "smf-serving-area", runtime.ParamLocationQuery, *params.SmfServingArea); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tai != nil {

			if queryParamBuf, err := json.Marshal(*params.Tai); err != nil {
				return nil, err
			} else {
				queryValues.Add("tai", string(queryParamBuf))
			}

		}

		if params.AmfRegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amf-region-id", runtime.ParamLocationQuery, *params.AmfRegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AmfSetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amf-set-id", runtime.ParamLocationQuery, *params.AmfSetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Guami != nil {

			if queryParamBuf, err := json.Marshal(*params.Guami); err != nil {
				return nil, err
			} else {
				queryValues.Add("guami", string(queryParamBuf))
			}

		}

		if params.Supi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supi", runtime.ParamLocationQuery, *params.Supi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UeIpv4Address != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ue-ipv4-address", runtime.ParamLocationQuery, *params.UeIpv4Address); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IpDomain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ip-domain", runtime.ParamLocationQuery, *params.IpDomain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UeIpv6Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ue-ipv6-prefix", runtime.ParamLocationQuery, *params.UeIpv6Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PgwInd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pgw-ind", runtime.ParamLocationQuery, *params.PgwInd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pgw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pgw", runtime.ParamLocationQuery, *params.Pgw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Gpsi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gpsi", runtime.ParamLocationQuery, *params.Gpsi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExternalGroupIdentity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "external-group-identity", runtime.ParamLocationQuery, *params.ExternalGroupIdentity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InternalGroupIdentity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "internal-group-identity", runtime.ParamLocationQuery, *params.InternalGroupIdentity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PfdData != nil {

			if queryParamBuf, err := json.Marshal(*params.PfdData); err != nil {
				return nil, err
			} else {
				queryValues.Add("pfd-data", string(queryParamBuf))
			}

		}

		if params.DataSet != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data-set", runtime.ParamLocationQuery, *params.DataSet); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoutingIndicator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "routing-indicator", runtime.ParamLocationQuery, *params.RoutingIndicator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupIdList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group-id-list", runtime.ParamLocationQuery, *params.GroupIdList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DnaiList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "dnai-list", runtime.ParamLocationQuery, *params.DnaiList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PduSessionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "pdu-session-types", runtime.ParamLocationQuery, *params.PduSessionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventIdList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "event-id-list", runtime.ParamLocationQuery, *params.EventIdList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NwdafEventList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "nwdaf-event-list", runtime.ParamLocationQuery, *params.NwdafEventList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SupportedFeatures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supported-features", runtime.ParamLocationQuery, *params.SupportedFeatures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpfIwkEpsInd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upf-iwk-eps-ind", runtime.ParamLocationQuery, *params.UpfIwkEpsInd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChfSupportedPlmn != nil {

			if queryParamBuf, err := json.Marshal(*params.ChfSupportedPlmn); err != nil {
				return nil, err
			} else {
				queryValues.Add("chf-supported-plmn", string(queryParamBuf))
			}

		}

		if params.PreferredLocality != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferred-locality", runtime.ParamLocationQuery, *params.PreferredLocality); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccessType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access-type", runtime.ParamLocationQuery, *params.AccessType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequiredFeatures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "required-features", runtime.ParamLocationQuery, *params.RequiredFeatures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ComplexQuery != nil {

			if queryParamBuf, err := json.Marshal(*params.ComplexQuery); err != nil {
				return nil, err
			} else {
				queryValues.Add("complex-query", string(queryParamBuf))
			}

		}

		if params.MaxPayloadSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max-payload-size", runtime.ParamLocationQuery, *params.MaxPayloadSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxPayloadSizeExt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max-payload-size-ext", runtime.ParamLocationQuery, *params.MaxPayloadSizeExt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AtsssCapability != nil {

			if queryParamBuf, err := json.Marshal(*params.AtsssCapability); err != nil {
				return nil, err
			} else {
				queryValues.Add("atsss-capability", string(queryParamBuf))
			}

		}

		if params.UpfUeIpAddrInd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upf-ue-ip-addr-ind", runtime.ParamLocationQuery, *params.UpfUeIpAddrInd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientType != nil {

			if queryParamBuf, err := json.Marshal(*params.ClientType); err != nil {
				return nil, err
			} else {
				queryValues.Add("client-type", string(queryParamBuf))
			}

		}

		if params.LmfId != nil {

			if queryParamBuf, err := json.Marshal(*params.LmfId); err != nil {
				return nil, err
			} else {
				queryValues.Add("lmf-id", string(queryParamBuf))
			}

		}

		if params.AnNodeType != nil {

			if queryParamBuf, err := json.Marshal(*params.AnNodeType); err != nil {
				return nil, err
			} else {
				queryValues.Add("an-node-type", string(queryParamBuf))
			}

		}

		if params.RatType != nil {

			if queryParamBuf, err := json.Marshal(*params.RatType); err != nil {
				return nil, err
			} else {
				queryValues.Add("rat-type", string(queryParamBuf))
			}

		}

		if params.PreferredTai != nil {

			if queryParamBuf, err := json.Marshal(*params.PreferredTai); err != nil {
				return nil, err
			} else {
				queryValues.Add("preferred-tai", string(queryParamBuf))
			}

		}

		if params.PreferredNfInstances != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preferred-nf-instances", runtime.ParamLocationQuery, *params.PreferredNfInstances); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetSnpn != nil {

			if queryParamBuf, err := json.Marshal(*params.TargetSnpn); err != nil {
				return nil, err
			} else {
				queryValues.Add("target-snpn", string(queryParamBuf))
			}

		}

		if params.RequesterSnpnList != nil {

			if queryParamBuf, err := json.Marshal(*params.RequesterSnpnList); err != nil {
				return nil, err
			} else {
				queryValues.Add("requester-snpn-list", string(queryParamBuf))
			}

		}

		if params.AfEeData != nil {

			if queryParamBuf, err := json.Marshal(*params.AfEeData); err != nil {
				return nil, err
			} else {
				queryValues.Add("af-ee-data", string(queryParamBuf))
			}

		}

		if params.WAgfInfo != nil {

			if queryParamBuf, err := json.Marshal(*params.WAgfInfo); err != nil {
				return nil, err
			} else {
				queryValues.Add("w-agf-info", string(queryParamBuf))
			}

		}

		if params.TngfInfo != nil {

			if queryParamBuf, err := json.Marshal(*params.TngfInfo); err != nil {
				return nil, err
			} else {
				queryValues.Add("tngf-info", string(queryParamBuf))
			}

		}

		if params.TwifInfo != nil {

			if queryParamBuf, err := json.Marshal(*params.TwifInfo); err != nil {
				return nil, err
			} else {
				queryValues.Add("twif-info", string(queryParamBuf))
			}

		}

		if params.TargetNfSetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-nf-set-id", runtime.ParamLocationQuery, *params.TargetNfSetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetNfServiceSetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target-nf-service-set-id", runtime.ParamLocationQuery, *params.TargetNfServiceSetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NefId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nef-id", runtime.ParamLocationQuery, *params.NefId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NotificationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "notification-type", runtime.ParamLocationQuery, *params.NotificationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.N1MsgClass != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "n1-msg-class", runtime.ParamLocationQuery, *params.N1MsgClass); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.N2InfoClass != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "n2-info-class", runtime.ParamLocationQuery, *params.N2InfoClass); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServingScope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "serving-scope", runtime.ParamLocationQuery, *params.ServingScope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Imsi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "imsi", runtime.ParamLocationQuery, *params.Imsi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImsPrivateIdentity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ims-private-identity", runtime.ParamLocationQuery, *params.ImsPrivateIdentity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ImsPublicIdentity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ims-public-identity", runtime.ParamLocationQuery, *params.ImsPublicIdentity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Msisdn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "msisdn", runtime.ParamLocationQuery, *params.Msisdn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreferredApiVersions != nil {

			if queryParamBuf, err := json.Marshal(*params.PreferredApiVersions); err != nil {
				return nil, err
			} else {
				queryValues.Add("preferred-api-versions", string(queryParamBuf))
			}

		}

		if params.V2xSupportInd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "v2x-support-ind", runtime.ParamLocationQuery, *params.V2xSupportInd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RedundantGtpu != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redundant-gtpu", runtime.ParamLocationQuery, *params.RedundantGtpu); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RedundantTransport != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redundant-transport", runtime.ParamLocationQuery, *params.RedundantTransport); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ipups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipups", runtime.ParamLocationQuery, *params.Ipups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScpDomainList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scp-domain-list", runtime.ParamLocationQuery, *params.ScpDomainList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddressDomain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address-domain", runtime.ParamLocationQuery, *params.AddressDomain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ipv4Addr != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipv4-addr", runtime.ParamLocationQuery, *params.Ipv4Addr); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ipv6Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ipv6-prefix", runtime.ParamLocationQuery, *params.Ipv6Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ServedNfSetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "served-nf-set-id", runtime.ParamLocationQuery, *params.ServedNfSetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemotePlmnId != nil {

			if queryParamBuf, err := json.Marshal(*params.RemotePlmnId); err != nil {
				return nil, err
			} else {
				queryValues.Add("remote-plmn-id", string(queryParamBuf))
			}

		}

		if params.DataForwarding != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data-forwarding", runtime.ParamLocationQuery, *params.DataForwarding); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreferredFullPlmn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preferred-full-plmn", runtime.ParamLocationQuery, *params.PreferredFullPlmn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RequesterFeatures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester-features", runtime.ParamLocationQuery, *params.RequesterFeatures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RealmId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "realm-id", runtime.ParamLocationQuery, *params.RealmId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storage-id", runtime.ParamLocationQuery, *params.StorageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VsmfSupportInd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vsmf-support-ind", runtime.ParamLocationQuery, *params.VsmfSupportInd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GmlcNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gmlc-number", runtime.ParamLocationQuery, *params.GmlcNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptEncoding != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, *params.AcceptEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Encoding", headerParam0)
		}

		if params.IfNoneMatch != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-None-Match", headerParam1)
		}

	}

	return req, nil
}

// NewRetrieveStoredSearchRequest generates requests for RetrieveStoredSearch
func NewRetrieveStoredSearchRequest(server string, searchId SearchId, params *RetrieveStoredSearchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "searchId", runtime.ParamLocationPath, searchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptEncoding != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, *params.AcceptEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Encoding", headerParam0)
		}

	}

	return req, nil
}

// NewRetrieveCompleteSearchRequest generates requests for RetrieveCompleteSearch
func NewRetrieveCompleteSearchRequest(server string, searchId SearchId, params *RetrieveCompleteSearchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "searchId", runtime.ParamLocationPath, searchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searches/%s/complete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptEncoding != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, *params.AcceptEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Encoding", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SearchNFInstancesWithResponse request
	SearchNFInstancesWithResponse(ctx context.Context, params *SearchNFInstancesParams, reqEditors ...RequestEditorFn) (*SearchNFInstancesResponse, error)

	// RetrieveStoredSearchWithResponse request
	RetrieveStoredSearchWithResponse(ctx context.Context, searchId SearchId, params *RetrieveStoredSearchParams, reqEditors ...RequestEditorFn) (*RetrieveStoredSearchResponse, error)

	// RetrieveCompleteSearchWithResponse request
	RetrieveCompleteSearchWithResponse(ctx context.Context, searchId SearchId, params *RetrieveCompleteSearchParams, reqEditors ...RequestEditorFn) (*RetrieveCompleteSearchResponse, error)
}

type SearchNFInstancesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *externalRef0.SearchResult
	JSON307                       *externalRef0.RedirectResponse
	JSON308                       *externalRef0.RedirectResponse
	ApplicationproblemJSON400     *externalRef0.N400
	ApplicationproblemJSON401     *externalRef0.N401
	ApplicationproblemJSON403     *externalRef0.N403
	ApplicationproblemJSON404     *externalRef0.N404
	ApplicationproblemJSON411     *externalRef0.N411
	ApplicationproblemJSON413     *externalRef0.N413
	ApplicationproblemJSON415     *externalRef0.N415
	ApplicationproblemJSON429     *externalRef0.N429
	ApplicationproblemJSON500     *externalRef0.N500
	ApplicationproblemJSON501     *externalRef0.N501
	ApplicationproblemJSON503     *externalRef0.N503
	ApplicationproblemJSONDefault *externalRef0.Default
}

// Status returns HTTPResponse.Status
func (r SearchNFInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchNFInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveStoredSearchResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *N200
	JSON307                       *externalRef0.RedirectResponse
	JSON308                       *externalRef0.RedirectResponse
	ApplicationproblemJSONDefault *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r RetrieveStoredSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveStoredSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveCompleteSearchResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *N200
	JSON307                       *externalRef0.RedirectResponse
	JSON308                       *externalRef0.RedirectResponse
	ApplicationproblemJSONDefault *externalRef0.ProblemDetails
}

// Status returns HTTPResponse.Status
func (r RetrieveCompleteSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveCompleteSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SearchNFInstancesWithResponse request returning *SearchNFInstancesResponse
func (c *ClientWithResponses) SearchNFInstancesWithResponse(ctx context.Context, params *SearchNFInstancesParams, reqEditors ...RequestEditorFn) (*SearchNFInstancesResponse, error) {
	rsp, err := c.SearchNFInstances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchNFInstancesResponse(rsp)
}

// RetrieveStoredSearchWithResponse request returning *RetrieveStoredSearchResponse
func (c *ClientWithResponses) RetrieveStoredSearchWithResponse(ctx context.Context, searchId SearchId, params *RetrieveStoredSearchParams, reqEditors ...RequestEditorFn) (*RetrieveStoredSearchResponse, error) {
	rsp, err := c.RetrieveStoredSearch(ctx, searchId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveStoredSearchResponse(rsp)
}

// RetrieveCompleteSearchWithResponse request returning *RetrieveCompleteSearchResponse
func (c *ClientWithResponses) RetrieveCompleteSearchWithResponse(ctx context.Context, searchId SearchId, params *RetrieveCompleteSearchParams, reqEditors ...RequestEditorFn) (*RetrieveCompleteSearchResponse, error) {
	rsp, err := c.RetrieveCompleteSearch(ctx, searchId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveCompleteSearchResponse(rsp)
}

// ParseSearchNFInstancesResponse parses an HTTP response from a SearchNFInstancesWithResponse call
func ParseSearchNFInstancesResponse(rsp *http.Response) (*SearchNFInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchNFInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest externalRef0.SearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case rsp.StatusCode == 406:
		break // No content-type

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef0.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.Default
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRetrieveStoredSearchResponse parses an HTTP response from a RetrieveStoredSearchWithResponse call
func ParseRetrieveStoredSearchResponse(rsp *http.Response) (*RetrieveStoredSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveStoredSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRetrieveCompleteSearchResponse parses an HTTP response from a RetrieveCompleteSearchWithResponse call
func ParseRetrieveCompleteSearchResponse(rsp *http.Response) (*RetrieveCompleteSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveCompleteSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.ProblemDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Search a collection of NF Instances
	// (GET /nf-instances)
	SearchNFInstances(c *gin.Context, params SearchNFInstancesParams)

	// (GET /searches/{searchId})
	RetrieveStoredSearch(c *gin.Context, searchId SearchId, params RetrieveStoredSearchParams)

	// (GET /searches/{searchId}/complete)
	RetrieveCompleteSearch(c *gin.Context, searchId SearchId, params RetrieveCompleteSearchParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// SearchNFInstances operation middleware
func (siw *ServerInterfaceWrapper) SearchNFInstances(c *gin.Context) {

	var err error

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-disc"})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchNFInstancesParams

	// ------------- Required query parameter "target-nf-type" -------------

	if paramValue := c.Query("target-nf-type"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument target-nf-type is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "target-nf-type", c.Request.URL.Query(), &params.TargetNfType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter target-nf-type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "requester-nf-type" -------------

	if paramValue := c.Query("requester-nf-type"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument requester-nf-type is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "requester-nf-type", c.Request.URL.Query(), &params.RequesterNfType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter requester-nf-type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "requester-nf-instance-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "requester-nf-instance-id", c.Request.URL.Query(), &params.RequesterNfInstanceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter requester-nf-instance-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "service-names" -------------

	err = runtime.BindQueryParameter("form", false, false, "service-names", c.Request.URL.Query(), &params.ServiceNames)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service-names: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "requester-nf-instance-fqdn" -------------

	err = runtime.BindQueryParameter("form", true, false, "requester-nf-instance-fqdn", c.Request.URL.Query(), &params.RequesterNfInstanceFqdn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter requester-nf-instance-fqdn: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "target-plmn-list" -------------

	if paramValue := c.Query("target-plmn-list"); paramValue != "" {

		var value []externalRef0.PlmnId
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'target-plmn-list' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.TargetPlmnList = &value

	}

	// ------------- Optional query parameter "requester-plmn-list" -------------

	if paramValue := c.Query("requester-plmn-list"); paramValue != "" {

		var value []externalRef0.PlmnId
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'requester-plmn-list' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RequesterPlmnList = &value

	}

	// ------------- Optional query parameter "target-nf-instance-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "target-nf-instance-id", c.Request.URL.Query(), &params.TargetNfInstanceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter target-nf-instance-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "target-nf-fqdn" -------------

	err = runtime.BindQueryParameter("form", true, false, "target-nf-fqdn", c.Request.URL.Query(), &params.TargetNfFqdn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter target-nf-fqdn: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "hnrf-uri" -------------

	err = runtime.BindQueryParameter("form", true, false, "hnrf-uri", c.Request.URL.Query(), &params.HnrfUri)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter hnrf-uri: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "snssais" -------------

	if paramValue := c.Query("snssais"); paramValue != "" {

		var value []externalRef0.Snssai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'snssais' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.Snssais = &value

	}

	// ------------- Optional query parameter "requester-snssais" -------------

	if paramValue := c.Query("requester-snssais"); paramValue != "" {

		var value []externalRef0.Snssai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'requester-snssais' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RequesterSnssais = &value

	}

	// ------------- Optional query parameter "plmn-specific-snssai-list" -------------

	if paramValue := c.Query("plmn-specific-snssai-list"); paramValue != "" {

		var value []externalRef0.PlmnSnssai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'plmn-specific-snssai-list' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.PlmnSpecificSnssaiList = &value

	}

	// ------------- Optional query parameter "requester-plmn-specific-snssai-list" -------------

	if paramValue := c.Query("requester-plmn-specific-snssai-list"); paramValue != "" {

		var value []externalRef0.PlmnSnssai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'requester-plmn-specific-snssai-list' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RequesterPlmnSpecificSnssaiList = &value

	}

	// ------------- Optional query parameter "dnn" -------------

	err = runtime.BindQueryParameter("form", true, false, "dnn", c.Request.URL.Query(), &params.Dnn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter dnn: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "nsi-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "nsi-list", c.Request.URL.Query(), &params.NsiList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nsi-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "smf-serving-area" -------------

	err = runtime.BindQueryParameter("form", true, false, "smf-serving-area", c.Request.URL.Query(), &params.SmfServingArea)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter smf-serving-area: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tai" -------------

	if paramValue := c.Query("tai"); paramValue != "" {

		var value externalRef0.Tai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'tai' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.Tai = &value

	}

	// ------------- Optional query parameter "amf-region-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "amf-region-id", c.Request.URL.Query(), &params.AmfRegionId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter amf-region-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amf-set-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "amf-set-id", c.Request.URL.Query(), &params.AmfSetId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter amf-set-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "guami" -------------

	if paramValue := c.Query("guami"); paramValue != "" {

		var value externalRef0.Guami
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'guami' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.Guami = &value

	}

	// ------------- Optional query parameter "supi" -------------

	err = runtime.BindQueryParameter("form", true, false, "supi", c.Request.URL.Query(), &params.Supi)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter supi: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ue-ipv4-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "ue-ipv4-address", c.Request.URL.Query(), &params.UeIpv4Address)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ue-ipv4-address: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ip-domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "ip-domain", c.Request.URL.Query(), &params.IpDomain)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ip-domain: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ue-ipv6-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "ue-ipv6-prefix", c.Request.URL.Query(), &params.UeIpv6Prefix)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ue-ipv6-prefix: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pgw-ind" -------------

	err = runtime.BindQueryParameter("form", true, false, "pgw-ind", c.Request.URL.Query(), &params.PgwInd)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pgw-ind: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pgw" -------------

	err = runtime.BindQueryParameter("form", true, false, "pgw", c.Request.URL.Query(), &params.Pgw)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pgw: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "gpsi" -------------

	err = runtime.BindQueryParameter("form", true, false, "gpsi", c.Request.URL.Query(), &params.Gpsi)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter gpsi: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "external-group-identity" -------------

	err = runtime.BindQueryParameter("form", true, false, "external-group-identity", c.Request.URL.Query(), &params.ExternalGroupIdentity)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter external-group-identity: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "internal-group-identity" -------------

	err = runtime.BindQueryParameter("form", true, false, "internal-group-identity", c.Request.URL.Query(), &params.InternalGroupIdentity)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter internal-group-identity: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pfd-data" -------------

	if paramValue := c.Query("pfd-data"); paramValue != "" {

		var value externalRef0.NrfPfdData
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'pfd-data' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.PfdData = &value

	}

	// ------------- Optional query parameter "data-set" -------------

	err = runtime.BindQueryParameter("form", true, false, "data-set", c.Request.URL.Query(), &params.DataSet)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter data-set: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "routing-indicator" -------------

	err = runtime.BindQueryParameter("form", true, false, "routing-indicator", c.Request.URL.Query(), &params.RoutingIndicator)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter routing-indicator: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "group-id-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "group-id-list", c.Request.URL.Query(), &params.GroupIdList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter group-id-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "dnai-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "dnai-list", c.Request.URL.Query(), &params.DnaiList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter dnai-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "pdu-session-types" -------------

	err = runtime.BindQueryParameter("form", false, false, "pdu-session-types", c.Request.URL.Query(), &params.PduSessionTypes)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter pdu-session-types: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "event-id-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "event-id-list", c.Request.URL.Query(), &params.EventIdList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter event-id-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "nwdaf-event-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "nwdaf-event-list", c.Request.URL.Query(), &params.NwdafEventList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nwdaf-event-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "supported-features" -------------

	err = runtime.BindQueryParameter("form", true, false, "supported-features", c.Request.URL.Query(), &params.SupportedFeatures)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter supported-features: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "upf-iwk-eps-ind" -------------

	err = runtime.BindQueryParameter("form", true, false, "upf-iwk-eps-ind", c.Request.URL.Query(), &params.UpfIwkEpsInd)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter upf-iwk-eps-ind: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "chf-supported-plmn" -------------

	if paramValue := c.Query("chf-supported-plmn"); paramValue != "" {

		var value externalRef0.PlmnId
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'chf-supported-plmn' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.ChfSupportedPlmn = &value

	}

	// ------------- Optional query parameter "preferred-locality" -------------

	err = runtime.BindQueryParameter("form", true, false, "preferred-locality", c.Request.URL.Query(), &params.PreferredLocality)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter preferred-locality: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "access-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "access-type", c.Request.URL.Query(), &params.AccessType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter access-type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "required-features" -------------

	err = runtime.BindQueryParameter("form", false, false, "required-features", c.Request.URL.Query(), &params.RequiredFeatures)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter required-features: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "complex-query" -------------

	if paramValue := c.Query("complex-query"); paramValue != "" {

		var value externalRef0.ComplexQuery
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'complex-query' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.ComplexQuery = &value

	}

	// ------------- Optional query parameter "max-payload-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-payload-size", c.Request.URL.Query(), &params.MaxPayloadSize)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter max-payload-size: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "max-payload-size-ext" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-payload-size-ext", c.Request.URL.Query(), &params.MaxPayloadSizeExt)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter max-payload-size-ext: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "atsss-capability" -------------

	if paramValue := c.Query("atsss-capability"); paramValue != "" {

		var value externalRef0.AtsssCapability
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'atsss-capability' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.AtsssCapability = &value

	}

	// ------------- Optional query parameter "upf-ue-ip-addr-ind" -------------

	err = runtime.BindQueryParameter("form", true, false, "upf-ue-ip-addr-ind", c.Request.URL.Query(), &params.UpfUeIpAddrInd)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter upf-ue-ip-addr-ind: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "client-type" -------------

	if paramValue := c.Query("client-type"); paramValue != "" {

		var value string
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'client-type' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.ClientType = &value

	}

	// ------------- Optional query parameter "lmf-id" -------------

	if paramValue := c.Query("lmf-id"); paramValue != "" {

		var value string
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'lmf-id' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.LmfId = &value

	}

	// ------------- Optional query parameter "an-node-type" -------------

	if paramValue := c.Query("an-node-type"); paramValue != "" {

		var value externalRef0.AnNodeType
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'an-node-type' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.AnNodeType = &value

	}

	// ------------- Optional query parameter "rat-type" -------------

	if paramValue := c.Query("rat-type"); paramValue != "" {

		var value externalRef0.RatType
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'rat-type' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RatType = &value

	}

	// ------------- Optional query parameter "preferred-tai" -------------

	if paramValue := c.Query("preferred-tai"); paramValue != "" {

		var value externalRef0.Tai
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'preferred-tai' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.PreferredTai = &value

	}

	// ------------- Optional query parameter "preferred-nf-instances" -------------

	err = runtime.BindQueryParameter("form", false, false, "preferred-nf-instances", c.Request.URL.Query(), &params.PreferredNfInstances)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter preferred-nf-instances: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "target-snpn" -------------

	if paramValue := c.Query("target-snpn"); paramValue != "" {

		var value externalRef0.PlmnIdNid
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'target-snpn' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.TargetSnpn = &value

	}

	// ------------- Optional query parameter "requester-snpn-list" -------------

	if paramValue := c.Query("requester-snpn-list"); paramValue != "" {

		var value []externalRef0.PlmnIdNid
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'requester-snpn-list' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RequesterSnpnList = &value

	}

	// ------------- Optional query parameter "af-ee-data" -------------

	if paramValue := c.Query("af-ee-data"); paramValue != "" {

		var value externalRef0.AfEventExposureData
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'af-ee-data' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.AfEeData = &value

	}

	// ------------- Optional query parameter "w-agf-info" -------------

	if paramValue := c.Query("w-agf-info"); paramValue != "" {

		var value externalRef0.WAgfInfo
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'w-agf-info' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.WAgfInfo = &value

	}

	// ------------- Optional query parameter "tngf-info" -------------

	if paramValue := c.Query("tngf-info"); paramValue != "" {

		var value externalRef0.TngfInfo
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'tngf-info' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.TngfInfo = &value

	}

	// ------------- Optional query parameter "twif-info" -------------

	if paramValue := c.Query("twif-info"); paramValue != "" {

		var value externalRef0.TwifInfo
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'twif-info' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.TwifInfo = &value

	}

	// ------------- Optional query parameter "target-nf-set-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "target-nf-set-id", c.Request.URL.Query(), &params.TargetNfSetId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter target-nf-set-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "target-nf-service-set-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "target-nf-service-set-id", c.Request.URL.Query(), &params.TargetNfServiceSetId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter target-nf-service-set-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "nef-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "nef-id", c.Request.URL.Query(), &params.NefId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nef-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "notification-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "notification-type", c.Request.URL.Query(), &params.NotificationType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter notification-type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "n1-msg-class" -------------

	err = runtime.BindQueryParameter("form", true, false, "n1-msg-class", c.Request.URL.Query(), &params.N1MsgClass)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter n1-msg-class: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "n2-info-class" -------------

	err = runtime.BindQueryParameter("form", true, false, "n2-info-class", c.Request.URL.Query(), &params.N2InfoClass)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter n2-info-class: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "serving-scope" -------------

	err = runtime.BindQueryParameter("form", false, false, "serving-scope", c.Request.URL.Query(), &params.ServingScope)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter serving-scope: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "imsi" -------------

	err = runtime.BindQueryParameter("form", true, false, "imsi", c.Request.URL.Query(), &params.Imsi)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter imsi: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ims-private-identity" -------------

	err = runtime.BindQueryParameter("form", true, false, "ims-private-identity", c.Request.URL.Query(), &params.ImsPrivateIdentity)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ims-private-identity: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ims-public-identity" -------------

	err = runtime.BindQueryParameter("form", true, false, "ims-public-identity", c.Request.URL.Query(), &params.ImsPublicIdentity)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ims-public-identity: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "msisdn" -------------

	err = runtime.BindQueryParameter("form", true, false, "msisdn", c.Request.URL.Query(), &params.Msisdn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter msisdn: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "preferred-api-versions" -------------

	if paramValue := c.Query("preferred-api-versions"); paramValue != "" {

		var value map[string]string
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'preferred-api-versions' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.PreferredApiVersions = &value

	}

	// ------------- Optional query parameter "v2x-support-ind" -------------

	err = runtime.BindQueryParameter("form", true, false, "v2x-support-ind", c.Request.URL.Query(), &params.V2xSupportInd)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter v2x-support-ind: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "redundant-gtpu" -------------

	err = runtime.BindQueryParameter("form", true, false, "redundant-gtpu", c.Request.URL.Query(), &params.RedundantGtpu)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter redundant-gtpu: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "redundant-transport" -------------

	err = runtime.BindQueryParameter("form", true, false, "redundant-transport", c.Request.URL.Query(), &params.RedundantTransport)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter redundant-transport: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ipups" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipups", c.Request.URL.Query(), &params.Ipups)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ipups: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "scp-domain-list" -------------

	err = runtime.BindQueryParameter("form", false, false, "scp-domain-list", c.Request.URL.Query(), &params.ScpDomainList)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter scp-domain-list: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "address-domain" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-domain", c.Request.URL.Query(), &params.AddressDomain)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter address-domain: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ipv4-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipv4-addr", c.Request.URL.Query(), &params.Ipv4Addr)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ipv4-addr: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ipv6-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "ipv6-prefix", c.Request.URL.Query(), &params.Ipv6Prefix)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ipv6-prefix: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "served-nf-set-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "served-nf-set-id", c.Request.URL.Query(), &params.ServedNfSetId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter served-nf-set-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "remote-plmn-id" -------------

	if paramValue := c.Query("remote-plmn-id"); paramValue != "" {

		var value externalRef0.PlmnId
		err = json.Unmarshal([]byte(paramValue), &value)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Error unmarshaling parameter 'remote-plmn-id' as JSON: %w", err), http.StatusBadRequest)
			return
		}

		params.RemotePlmnId = &value

	}

	// ------------- Optional query parameter "data-forwarding" -------------

	err = runtime.BindQueryParameter("form", true, false, "data-forwarding", c.Request.URL.Query(), &params.DataForwarding)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter data-forwarding: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "preferred-full-plmn" -------------

	err = runtime.BindQueryParameter("form", true, false, "preferred-full-plmn", c.Request.URL.Query(), &params.PreferredFullPlmn)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter preferred-full-plmn: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "requester-features" -------------

	err = runtime.BindQueryParameter("form", true, false, "requester-features", c.Request.URL.Query(), &params.RequesterFeatures)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter requester-features: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "realm-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "realm-id", c.Request.URL.Query(), &params.RealmId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter realm-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "storage-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "storage-id", c.Request.URL.Query(), &params.StorageId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter storage-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "vsmf-support-ind" -------------

	err = runtime.BindQueryParameter("form", true, false, "vsmf-support-ind", c.Request.URL.Query(), &params.VsmfSupportInd)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter vsmf-support-ind: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "gmlc-number" -------------

	err = runtime.BindQueryParameter("form", true, false, "gmlc-number", c.Request.URL.Query(), &params.GmlcNumber)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter gmlc-number: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter If-None-Match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SearchNFInstances(c, params)
}

// RetrieveStoredSearch operation middleware
func (siw *ServerInterfaceWrapper) RetrieveStoredSearch(c *gin.Context) {

	var err error

	// ------------- Path parameter "searchId" -------------
	var searchId SearchId

	err = runtime.BindStyledParameterWithOptions("simple", "searchId", c.Param("searchId"), &searchId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter searchId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-disc"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveStoredSearchParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RetrieveStoredSearch(c, searchId, params)
}

// RetrieveCompleteSearch operation middleware
func (siw *ServerInterfaceWrapper) RetrieveCompleteSearch(c *gin.Context) {

	var err error

	// ------------- Path parameter "searchId" -------------
	var searchId SearchId

	err = runtime.BindStyledParameterWithOptions("simple", "searchId", c.Param("searchId"), &searchId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter searchId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-disc"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RetrieveCompleteSearchParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RetrieveCompleteSearch(c, searchId, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/nf-instances", wrapper.SearchNFInstances)
	router.GET(options.BaseURL+"/searches/:searchId", wrapper.RetrieveStoredSearch)
	router.GET(options.BaseURL+"/searches/:searchId/complete", wrapper.RetrieveCompleteSearch)
}

type N200ResponseHeaders struct {
	CacheControl    *string
	ContentEncoding *string
	ETag            *string
}
type N200JSONResponse struct {
	Body externalRef0.StoredSearchResult

	Headers N200ResponseHeaders
}

type SearchNFInstancesRequestObject struct {
	Params SearchNFInstancesParams
}

type SearchNFInstancesResponseObject interface {
	VisitSearchNFInstancesResponse(w http.ResponseWriter) error
}

type SearchNFInstances200ResponseHeaders struct {
	CacheControl    *string
	ContentEncoding *string
	ETag            *string
}

type SearchNFInstances200JSONResponse struct {
	Body    externalRef0.SearchResult
	Headers SearchNFInstances200ResponseHeaders
}

func (response SearchNFInstances200JSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	if response.Headers.CacheControl != nil {
		w.Header().Set("Cache-Control", fmt.Sprint(*response.Headers.CacheControl))
	}
	if response.Headers.ContentEncoding != nil {
		w.Header().Set("Content-Encoding", fmt.Sprint(*response.Headers.ContentEncoding))
	}
	if response.Headers.ETag != nil {
		w.Header().Set("ETag", fmt.Sprint(*response.Headers.ETag))
	}
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type SearchNFInstances307ResponseHeaders struct {
	Location string
}

type SearchNFInstances307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers SearchNFInstances307ResponseHeaders
}

func (response SearchNFInstances307JSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type SearchNFInstances308ResponseHeaders struct {
	Location string
}

type SearchNFInstances308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers SearchNFInstances308ResponseHeaders
}

func (response SearchNFInstances308JSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type SearchNFInstances400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances400ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N400ApplicationProblemPlusJSONResponse))
}

type SearchNFInstances401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances401ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N401ApplicationProblemPlusJSONResponse))
}

type SearchNFInstances403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances403ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N403ApplicationProblemPlusJSONResponse))
}

type SearchNFInstances404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances404ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N404ApplicationProblemPlusJSONResponse))
}

type SearchNFInstances406Response externalRef0.N406Response

func (response SearchNFInstances406Response) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.WriteHeader(406)
	return nil
}

type SearchNFInstances411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances411ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N411ApplicationProblemPlusJSONResponse))
}

type SearchNFInstances413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances413ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N413ApplicationProblemPlusJSONResponse))
}

type SearchNFInstances415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances415ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N415ApplicationProblemPlusJSONResponse))
}

type SearchNFInstances429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances429ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N429ApplicationProblemPlusJSONResponse))
}

type SearchNFInstances500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances500ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N500ApplicationProblemPlusJSONResponse))
}

type SearchNFInstances501ApplicationProblemPlusJSONResponse struct {
	externalRef0.N501ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances501ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N501ApplicationProblemPlusJSONResponse))
}

type SearchNFInstances503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response SearchNFInstances503ApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N503ApplicationProblemPlusJSONResponse))
}

type SearchNFInstancesdefaultApplicationProblemPlusJSONResponse struct {
	Body       externalRef0.ProblemDetails
	StatusCode int
}

func (response SearchNFInstancesdefaultApplicationProblemPlusJSONResponse) VisitSearchNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveStoredSearchRequestObject struct {
	SearchId SearchId `json:"searchId"`
	Params   RetrieveStoredSearchParams
}

type RetrieveStoredSearchResponseObject interface {
	VisitRetrieveStoredSearchResponse(w http.ResponseWriter) error
}

type RetrieveStoredSearch200JSONResponse struct{ N200JSONResponse }

func (response RetrieveStoredSearch200JSONResponse) VisitRetrieveStoredSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	if response.Headers.CacheControl != nil {
		w.Header().Set("Cache-Control", fmt.Sprint(*response.Headers.CacheControl))
	}
	if response.Headers.ContentEncoding != nil {
		w.Header().Set("Content-Encoding", fmt.Sprint(*response.Headers.ContentEncoding))
	}
	if response.Headers.ETag != nil {
		w.Header().Set("ETag", fmt.Sprint(*response.Headers.ETag))
	}
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveStoredSearch307ResponseHeaders struct {
	Location string
}

type RetrieveStoredSearch307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers RetrieveStoredSearch307ResponseHeaders
}

func (response RetrieveStoredSearch307JSONResponse) VisitRetrieveStoredSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveStoredSearch308ResponseHeaders struct {
	Location string
}

type RetrieveStoredSearch308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers RetrieveStoredSearch308ResponseHeaders
}

func (response RetrieveStoredSearch308JSONResponse) VisitRetrieveStoredSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveStoredSearchdefaultApplicationProblemPlusJSONResponse struct {
	Body       externalRef0.ProblemDetails
	StatusCode int
}

func (response RetrieveStoredSearchdefaultApplicationProblemPlusJSONResponse) VisitRetrieveStoredSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveCompleteSearchRequestObject struct {
	SearchId SearchId `json:"searchId"`
	Params   RetrieveCompleteSearchParams
}

type RetrieveCompleteSearchResponseObject interface {
	VisitRetrieveCompleteSearchResponse(w http.ResponseWriter) error
}

type RetrieveCompleteSearch200JSONResponse struct{ N200JSONResponse }

func (response RetrieveCompleteSearch200JSONResponse) VisitRetrieveCompleteSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	if response.Headers.CacheControl != nil {
		w.Header().Set("Cache-Control", fmt.Sprint(*response.Headers.CacheControl))
	}
	if response.Headers.ContentEncoding != nil {
		w.Header().Set("Content-Encoding", fmt.Sprint(*response.Headers.ContentEncoding))
	}
	if response.Headers.ETag != nil {
		w.Header().Set("ETag", fmt.Sprint(*response.Headers.ETag))
	}
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveCompleteSearch307ResponseHeaders struct {
	Location string
}

type RetrieveCompleteSearch307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers RetrieveCompleteSearch307ResponseHeaders
}

func (response RetrieveCompleteSearch307JSONResponse) VisitRetrieveCompleteSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveCompleteSearch308ResponseHeaders struct {
	Location string
}

type RetrieveCompleteSearch308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers RetrieveCompleteSearch308ResponseHeaders
}

func (response RetrieveCompleteSearch308JSONResponse) VisitRetrieveCompleteSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type RetrieveCompleteSearchdefaultApplicationProblemPlusJSONResponse struct {
	Body       externalRef0.ProblemDetails
	StatusCode int
}

func (response RetrieveCompleteSearchdefaultApplicationProblemPlusJSONResponse) VisitRetrieveCompleteSearchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Search a collection of NF Instances
	// (GET /nf-instances)
	SearchNFInstances(ctx context.Context, request SearchNFInstancesRequestObject) (SearchNFInstancesResponseObject, error)

	// (GET /searches/{searchId})
	RetrieveStoredSearch(ctx context.Context, request RetrieveStoredSearchRequestObject) (RetrieveStoredSearchResponseObject, error)

	// (GET /searches/{searchId}/complete)
	RetrieveCompleteSearch(ctx context.Context, request RetrieveCompleteSearchRequestObject) (RetrieveCompleteSearchResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// SearchNFInstances operation middleware
func (sh *strictHandler) SearchNFInstances(ctx *gin.Context, params SearchNFInstancesParams) {
	var request SearchNFInstancesRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SearchNFInstances(ctx, request.(SearchNFInstancesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SearchNFInstances")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(SearchNFInstancesResponseObject); ok {
		if err := validResponse.VisitSearchNFInstancesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// RetrieveStoredSearch operation middleware
func (sh *strictHandler) RetrieveStoredSearch(ctx *gin.Context, searchId SearchId, params RetrieveStoredSearchParams) {
	var request RetrieveStoredSearchRequestObject

	request.SearchId = searchId
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RetrieveStoredSearch(ctx, request.(RetrieveStoredSearchRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RetrieveStoredSearch")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(RetrieveStoredSearchResponseObject); ok {
		if err := validResponse.VisitRetrieveStoredSearchResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// RetrieveCompleteSearch operation middleware
func (sh *strictHandler) RetrieveCompleteSearch(ctx *gin.Context, searchId SearchId, params RetrieveCompleteSearchParams) {
	var request RetrieveCompleteSearchRequestObject

	request.SearchId = searchId
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RetrieveCompleteSearch(ctx, request.(RetrieveCompleteSearchRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RetrieveCompleteSearch")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(RetrieveCompleteSearchResponseObject); ok {
		if err := validResponse.VisitRetrieveCompleteSearchResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}
