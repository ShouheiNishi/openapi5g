// Package management provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package management

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	externalRef0 "github.com/ShouheiNishi/openapi5g/commondata"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

const (
	OAuth2ClientCredentialsScopes = "oAuth2ClientCredentials.Scopes"
)

// Defines values for AnNodeType.
const (
	GNB   AnNodeType = "GNB"
	NGENB AnNodeType = "NG_ENB"
)

// Defines values for ConditionEventType.
const (
	NFADDED   ConditionEventType = "NF_ADDED"
	NFREMOVED ConditionEventType = "NF_REMOVED"
)

// Defines values for DataSetId.
const (
	APPLICATION  DataSetId = "APPLICATION"
	EXPOSURE     DataSetId = "EXPOSURE"
	POLICY       DataSetId = "POLICY"
	SUBSCRIPTION DataSetId = "SUBSCRIPTION"
)

// Defines values for IpReachability.
const (
	IPV4   IpReachability = "IPV4"
	IPV4V6 IpReachability = "IPV4V6"
	IPV6   IpReachability = "IPV6"
)

// Defines values for NFServiceStatus.
const (
	NFServiceStatusREGISTERED     NFServiceStatus = "REGISTERED"
	NFServiceStatusSUSPENDED      NFServiceStatus = "SUSPENDED"
	NFServiceStatusUNDISCOVERABLE NFServiceStatus = "UNDISCOVERABLE"
)

// Defines values for NFStatus.
const (
	NFStatusREGISTERED     NFStatus = "REGISTERED"
	NFStatusSUSPENDED      NFStatus = "SUSPENDED"
	NFStatusUNDISCOVERABLE NFStatus = "UNDISCOVERABLE"
)

// Defines values for NFType.
const (
	NFTypeAF     NFType = "AF"
	NFTypeAMF    NFType = "AMF"
	NFTypeAUSF   NFType = "AUSF"
	NFTypeBSF    NFType = "BSF"
	NFTypeCBCF   NFType = "CBCF"
	NFTypeCEF    NFType = "CEF"
	NFTypeCHF    NFType = "CHF"
	NFTypeDRA    NFType = "DRA"
	NFTypeGMLC   NFType = "GMLC"
	NFTypeHSS    NFType = "HSS"
	NFTypeICSCF  NFType = "ICSCF"
	NFTypeIMSAS  NFType = "IMS_AS"
	NFTypeLMF    NFType = "LMF"
	NFTypeMME    NFType = "MME"
	NFTypeN3IWF  NFType = "N3IWF"
	NFTypeN5GEIR NFType = "5G_EIR"
	NFTypeNEF    NFType = "NEF"
	NFTypeNRF    NFType = "NRF"
	NFTypeNSSAAF NFType = "NSSAAF"
	NFTypeNSSF   NFType = "NSSF"
	NFTypeNWDAF  NFType = "NWDAF"
	NFTypePCF    NFType = "PCF"
	NFTypePCSCF  NFType = "PCSCF"
	NFTypeSCEF   NFType = "SCEF"
	NFTypeSCP    NFType = "SCP"
	NFTypeSCSAS  NFType = "SCSAS"
	NFTypeSCSCF  NFType = "SCSCF"
	NFTypeSEPP   NFType = "SEPP"
	NFTypeSMF    NFType = "SMF"
	NFTypeSMSF   NFType = "SMSF"
	NFTypeSORAF  NFType = "SOR_AF"
	NFTypeSPAF   NFType = "SPAF"
	NFTypeUCMF   NFType = "UCMF"
	NFTypeUDM    NFType = "UDM"
	NFTypeUDR    NFType = "UDR"
	NFTypeUDSF   NFType = "UDSF"
	NFTypeUPF    NFType = "UPF"
)

// Defines values for NefCondConditionType.
const (
	NEFCOND NefCondConditionType = "NEF_COND"
)

// Defines values for NfGroupCondNfType.
const (
	NfGroupCondNfTypeAUSF NfGroupCondNfType = "AUSF"
	NfGroupCondNfTypeCHF  NfGroupCondNfType = "CHF"
	NfGroupCondNfTypePCF  NfGroupCondNfType = "PCF"
	NfGroupCondNfTypeUDM  NfGroupCondNfType = "UDM"
	NfGroupCondNfTypeUDR  NfGroupCondNfType = "UDR"
)

// Defines values for NotificationEventType.
const (
	NFDEREGISTERED   NotificationEventType = "NF_DEREGISTERED"
	NFPROFILECHANGED NotificationEventType = "NF_PROFILE_CHANGED"
	NFREGISTERED     NotificationEventType = "NF_REGISTERED"
)

// Defines values for NotificationType.
const (
	DATACHANGENOTIFICATION     NotificationType = "DATA_CHANGE_NOTIFICATION"
	DATAREMOVALNOTIFICATION    NotificationType = "DATA_REMOVAL_NOTIFICATION"
	LCSKEYDELIVERYNOTIFICATION NotificationType = "LCS_KEY_DELIVERY_NOTIFICATION"
	LOCATIONNOTIFICATION       NotificationType = "LOCATION_NOTIFICATION"
	LOCATIONUPDATENOTIFICATION NotificationType = "LOCATION_UPDATE_NOTIFICATION"
	N1MESSAGES                 NotificationType = "N1_MESSAGES"
	N2INFORMATION              NotificationType = "N2_INFORMATION"
	NSSAAREAUTHNOTIFICATION    NotificationType = "NSSAA_REAUTH_NOTIFICATION"
	NSSAAREVOCNOTIFICATION     NotificationType = "NSSAA_REVOC_NOTIFICATION"
)

// Defines values for NwdafCondConditionType.
const (
	NWDAFCOND NwdafCondConditionType = "NWDAF_COND"
)

// Defines values for ServiceName.
const (
	N3gppAnalyticsexposure         ServiceName = "3gpp-analyticsexposure"
	N3gppApplyingBdtPolicy         ServiceName = "3gpp-applying-bdt-policy"
	N3gppAsSessionWithQos          ServiceName = "3gpp-as-session-with-qos"
	N3gppBdt                       ServiceName = "3gpp-bdt"
	N3gppChargeableParty           ServiceName = "3gpp-chargeable-party"
	N3gppCpParameterProvisioning   ServiceName = "3gpp-cp-parameter-provisioning"
	N3gppDeviceTriggering          ServiceName = "3gpp-device-triggering"
	N3gppEcrControl                ServiceName = "3gpp-ecr-control"
	N3gppMoLcsNotify               ServiceName = "3gpp-mo-lcs-notify"
	N3gppMonitoringEvent           ServiceName = "3gpp-monitoring-event"
	N3gppMsisdnLessMoSms           ServiceName = "3gpp-msisdn-less-mo-sms"
	N3gppNidd                      ServiceName = "3gpp-nidd"
	N3gppNiddConfigurationTrigger  ServiceName = "3gpp-nidd-configuration-trigger"
	N3gppRacsParameterProvisioning ServiceName = "3gpp-racs-parameter-provisioning"
	N3gppServiceParameter          ServiceName = "3gpp-service-parameter"
	N3gppTrafficInfluence          ServiceName = "3gpp-traffic-influence"
	N5gEirEic                      ServiceName = "n5g-eir-eic"
	NamfComm                       ServiceName = "namf-comm"
	NamfEvts                       ServiceName = "namf-evts"
	NamfLoc                        ServiceName = "namf-loc"
	NamfMt                         ServiceName = "namf-mt"
	NausfAuth                      ServiceName = "nausf-auth"
	NausfSorprotection             ServiceName = "nausf-sorprotection"
	NausfUpuprotection             ServiceName = "nausf-upuprotection"
	NbsfManagement                 ServiceName = "nbsf-management"
	NchfConvergedcharging          ServiceName = "nchf-convergedcharging"
	NchfOfflineonlycharging        ServiceName = "nchf-offlineonlycharging"
	NchfSpendinglimitcontrol       ServiceName = "nchf-spendinglimitcontrol"
	NgmlcLoc                       ServiceName = "ngmlc-loc"
	NhssEe                         ServiceName = "nhss-ee"
	NhssImsSdm                     ServiceName = "nhss-ims-sdm"
	NhssImsUeau                    ServiceName = "nhss-ims-ueau"
	NhssImsUecm                    ServiceName = "nhss-ims-uecm"
	NhssSdm                        ServiceName = "nhss-sdm"
	NhssUeau                       ServiceName = "nhss-ueau"
	NhssUecm                       ServiceName = "nhss-uecm"
	NlmfLoc                        ServiceName = "nlmf-loc"
	NnefEventexposure              ServiceName = "nnef-eventexposure"
	NnefPfdmanagement              ServiceName = "nnef-pfdmanagement"
	NnefSmcontext                  ServiceName = "nnef-smcontext"
	NnrfDisc                       ServiceName = "nnrf-disc"
	NnrfNfm                        ServiceName = "nnrf-nfm"
	NnrfOauth2                     ServiceName = "nnrf-oauth2"
	NnssaafNssaa                   ServiceName = "nnssaaf-nssaa"
	NnssfNssaiavailability         ServiceName = "nnssf-nssaiavailability"
	NnssfNsselection               ServiceName = "nnssf-nsselection"
	NnwdafAnalyticsinfo            ServiceName = "nnwdaf-analyticsinfo"
	NnwdafEventssubscription       ServiceName = "nnwdaf-eventssubscription"
	NpcfAmPolicyControl            ServiceName = "npcf-am-policy-control"
	NpcfBdtpolicycontrol           ServiceName = "npcf-bdtpolicycontrol"
	NpcfEventexposure              ServiceName = "npcf-eventexposure"
	NpcfPolicyauthorization        ServiceName = "npcf-policyauthorization"
	NpcfSmpolicycontrol            ServiceName = "npcf-smpolicycontrol"
	NpcfUePolicyControl            ServiceName = "npcf-ue-policy-control"
	NseppTelescopic                ServiceName = "nsepp-telescopic"
	NsmfEventExposure              ServiceName = "nsmf-event-exposure"
	NsmfNidd                       ServiceName = "nsmf-nidd"
	NsmfPdusession                 ServiceName = "nsmf-pdusession"
	NsmsfSms                       ServiceName = "nsmsf-sms"
	NsorafSor                      ServiceName = "nsoraf-sor"
	NspafSecuredPacket             ServiceName = "nspaf-secured-packet"
	NucmfProvisioning              ServiceName = "nucmf-provisioning"
	NucmfUecapabilitymanagement    ServiceName = "nucmf-uecapabilitymanagement"
	NudmEe                         ServiceName = "nudm-ee"
	NudmMt                         ServiceName = "nudm-mt"
	NudmNiddau                     ServiceName = "nudm-niddau"
	NudmPp                         ServiceName = "nudm-pp"
	NudmSdm                        ServiceName = "nudm-sdm"
	NudmUeau                       ServiceName = "nudm-ueau"
	NudmUecm                       ServiceName = "nudm-uecm"
	NudrDr                         ServiceName = "nudr-dr"
	NudrGroupIdMap                 ServiceName = "nudr-group-id-map"
	NudsfDr                        ServiceName = "nudsf-dr"
)

// Defines values for TransportProtocol.
const (
	TCP TransportProtocol = "TCP"
)

// Defines values for UPInterfaceType.
const (
	DATAFORWARDING UPInterfaceType = "DATA_FORWARDING"
	N3             UPInterfaceType = "N3"
	N6             UPInterfaceType = "N6"
	N9             UPInterfaceType = "N9"
)

// Defines values for UpfCondConditionType.
const (
	UPFCOND UpfCondConditionType = "UPF_COND"
)

// AfEventExposureData AF Event Exposure data managed by a given NEF Instance
type AfEventExposureData struct {
	AfEvents             []string               `json:"afEvents"`
	AfIds                []string               `json:"afIds,omitempty"`
	AppIds               []string               `json:"appIds,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AmfCond Subscription to a set of AMFs, based on AMF Set Id and/or AMF Region Id
type AmfCond struct {
	AmfRegionId          externalRef0.AmfRegionId `json:"amfRegionId,omitempty"`
	AmfSetId             externalRef0.AmfSetId    `json:"amfSetId,omitempty"`
	AdditionalProperties map[string]interface{}   `json:"-"`
}

// AmfInfo Information of an AMF NF Instance
type AmfInfo struct {
	AmfRegionId          externalRef0.AmfRegionId `json:"amfRegionId"`
	AmfSetId             externalRef0.AmfSetId    `json:"amfSetId"`
	BackupInfoAmfFailure []externalRef0.Guami     `json:"backupInfoAmfFailure,omitempty"`
	BackupInfoAmfRemoval []externalRef0.Guami     `json:"backupInfoAmfRemoval,omitempty"`
	GuamiList            []externalRef0.Guami     `json:"guamiList"`

	// N2InterfaceAmfInfo AMF N2 interface information
	N2InterfaceAmfInfo   *N2InterfaceAmfInfo    `json:"n2InterfaceAmfInfo,omitempty"`
	TaiList              []externalRef0.Tai     `json:"taiList,omitempty"`
	TaiRangeList         []TaiRange             `json:"taiRangeList,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AnNodeType Access Network Node Type (gNB, ng-eNB...)
type AnNodeType string

// AusfInfo Information of an AUSF NF Instance
type AusfInfo struct {
	GroupId              *externalRef0.NfGroupId `json:"groupId,omitempty"`
	RoutingIndicators    []string                `json:"routingIndicators,omitempty"`
	SupiRanges           []SupiRange             `json:"supiRanges,omitempty"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// BsfInfo Information of a BSF NF Instance
type BsfInfo struct {
	DnnList              []externalRef0.Dnn     `json:"dnnList,omitempty"`
	IpDomainList         []string               `json:"ipDomainList,omitempty"`
	Ipv4AddressRanges    []Ipv4AddressRange     `json:"ipv4AddressRanges,omitempty"`
	Ipv6PrefixRanges     []Ipv6PrefixRange      `json:"ipv6PrefixRanges,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ChfInfo Information of a CHF NF Instance
type ChfInfo struct {
	GpsiRangeList        []IdentityRange            `json:"gpsiRangeList,omitempty"`
	GroupId              *externalRef0.NfGroupId    `json:"groupId,omitempty"`
	PlmnRangeList        []PlmnRange                `json:"plmnRangeList,omitempty"`
	PrimaryChfInstance   *externalRef0.NfInstanceId `json:"primaryChfInstance,omitempty"`
	SecondaryChfInstance *externalRef0.NfInstanceId `json:"secondaryChfInstance,omitempty"`
	SupiRangeList        []SupiRange                `json:"supiRangeList,omitempty"`
	AdditionalProperties map[string]interface{}     `json:"-"`
}

// ConditionEventType Indicates whether a notification is due to the NF Instance to start or stop being part of a condition for a subscription to a set of NFs
type ConditionEventType string

// DataSetId Types of data sets stored in UDR
type DataSetId string

// DefaultNotificationSubscription Data structure for specifying the notifications the NF service subscribes by default along with callback URI
type DefaultNotificationSubscription struct {
	Binding     *string          `json:"binding,omitempty"`
	CallbackUri externalRef0.Uri `json:"callbackUri"`

	// N1MessageClass Original reference TS29518_Namf_Communication.yaml#/components/schemas/N1MessageClass
	N1MessageClass *string `json:"n1MessageClass,omitempty"`

	// N2InformationClass Original reference TS29518_Namf_Communication.yaml#/components/schemas/N2InformationClass
	N2InformationClass *string `json:"n2InformationClass,omitempty"`

	// NotificationType Types of notifications used in Default Notification URIs in the NF Profile of an NF Instance
	NotificationType     NotificationType       `json:"notificationType"`
	Versions             []string               `json:"versions,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DnnSmfInfoItem Set of parameters supported by SMF for a given DNN
type DnnSmfInfoItem struct {
	Dnn                  externalRef0.Dnn       `json:"dnn"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DnnUpfInfoItem Set of parameters supported by UPF for a given DNN
type DnnUpfInfoItem struct {
	DnaiList []externalRef0.Dnai `json:"dnaiList,omitempty"`

	// DnaiNwInstanceList Map of network instance per DNAI for the DNN, where the key of the map is the DNAI. When present, the value of each entry of the map shall contain a N6 network instance that is configured for the DNAI indicated by the key.
	DnaiNwInstanceList   *map[string]string            `json:"dnaiNwInstanceList,omitempty"`
	Dnn                  externalRef0.Dnn              `json:"dnn"`
	Ipv4AddressRanges    []Ipv4AddressRange            `json:"ipv4AddressRanges,omitempty"`
	Ipv6PrefixRanges     []Ipv6PrefixRange             `json:"ipv6PrefixRanges,omitempty"`
	PduSessionTypes      []externalRef0.PduSessionType `json:"pduSessionTypes,omitempty"`
	AdditionalProperties map[string]interface{}        `json:"-"`
}

// Fqdn Fully Qualified Domain Name
type Fqdn = string

// GmlcInfo Information of a GMLC NF Instance
type GmlcInfo struct {
	GmlcNumbers          []string               `json:"gmlcNumbers,omitempty"`
	ServingClientTypes   []string               `json:"servingClientTypes,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GuamiListCond Subscription to a set of AMFs, based on their GUAMIs
type GuamiListCond struct {
	GuamiList            []externalRef0.Guami   `json:"guamiList"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// HssInfo Information of an HSS NF Instance
type HssInfo struct {
	GroupId                  *externalRef0.NfGroupId `json:"groupId,omitempty"`
	ImsPrivateIdentityRanges []IdentityRange         `json:"imsPrivateIdentityRanges,omitempty"`
	ImsPublicIdentityRanges  []IdentityRange         `json:"imsPublicIdentityRanges,omitempty"`
	ImsiRanges               []ImsiRange             `json:"imsiRanges,omitempty"`
	MsisdnRanges             []IdentityRange         `json:"msisdnRanges,omitempty"`
	AdditionalProperties     map[string]interface{}  `json:"-"`
}

// IdentityRange A range of GPSIs (subscriber identities), either based on a numeric range, or based on regular-expression matching
type IdentityRange struct {
	End                  string                 `json:"end,omitempty"`
	Pattern              *string                `json:"pattern,omitempty"`
	Start                string                 `json:"start,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ImsiRange A range of IMSIs (subscriber identities), either based on a numeric range, or based on regular-expression matching
type ImsiRange struct {
	End                  string                 `json:"end,omitempty"`
	Pattern              *string                `json:"pattern,omitempty"`
	Start                string                 `json:"start,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// InterfaceUpfInfoItem Information of a given IP interface of an UPF
type InterfaceUpfInfoItem struct {
	// EndpointFqdn Fully Qualified Domain Name
	EndpointFqdn *Fqdn `json:"endpointFqdn,omitempty"`

	// InterfaceType Types of User-Plane interfaces of the UPF
	InterfaceType         UPInterfaceType         `json:"interfaceType"`
	Ipv4EndpointAddresses []externalRef0.Ipv4Addr `json:"ipv4EndpointAddresses,omitempty"`
	Ipv6EndpointAddresses []externalRef0.Ipv6Addr `json:"ipv6EndpointAddresses,omitempty"`
	NetworkInstance       *string                 `json:"networkInstance,omitempty"`
	AdditionalProperties  map[string]interface{}  `json:"-"`
}

// InternalGroupIdRange A range of Group IDs (internal group identities), either based on a numeric range, or based on regular-expression matching
type InternalGroupIdRange struct {
	End                  externalRef0.GroupId   `json:"end,omitempty"`
	Pattern              *string                `json:"pattern,omitempty"`
	Start                externalRef0.GroupId   `json:"start,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IpEndPoint IP addressing information of a given NFService; it consists on, e.g. IP address, TCP port, transport protocol...
type IpEndPoint struct {
	Ipv4Address externalRef0.Ipv4Addr  `json:"ipv4Address,omitempty"`
	Ipv6Address *externalRef0.Ipv6Addr `json:"ipv6Address,omitempty"`
	Port        *int                   `json:"port,omitempty"`

	// Transport Types of transport protocol used in a given IP endpoint of an NF Service Instance
	Transport            *TransportProtocol     `json:"transport,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IpReachability Indicates the type(s) of IP addresses reachable via an SCP
type IpReachability string

// Ipv4AddressRange Range of IPv4 addresses
type Ipv4AddressRange struct {
	End                  externalRef0.Ipv4Addr  `json:"end,omitempty"`
	Start                externalRef0.Ipv4Addr  `json:"start,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Ipv6PrefixRange Range of IPv6 prefixes
type Ipv6PrefixRange struct {
	End                  *externalRef0.Ipv6Prefix `json:"end,omitempty"`
	Start                *externalRef0.Ipv6Prefix `json:"start,omitempty"`
	AdditionalProperties map[string]interface{}   `json:"-"`
}

// LmfInfo Information of an LMF NF Instance
type LmfInfo struct {
	// LmfId Original reference TS29572_Nlmf_Location.yaml#/components/schemas/LMFIdentification
	LmfId                *string                   `json:"lmfId,omitempty"`
	ServingAccessTypes   []externalRef0.AccessType `json:"servingAccessTypes,omitempty"`
	ServingAnNodeTypes   []AnNodeType              `json:"servingAnNodeTypes,omitempty"`
	ServingClientTypes   []string                  `json:"servingClientTypes,omitempty"`
	ServingRatTypes      []externalRef0.RatType    `json:"servingRatTypes,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// N2InterfaceAmfInfo AMF N2 interface information
type N2InterfaceAmfInfo struct {
	AmfName              *externalRef0.AmfName   `json:"amfName,omitempty"`
	Ipv4EndpointAddress  []externalRef0.Ipv4Addr `json:"ipv4EndpointAddress,omitempty"`
	Ipv6EndpointAddress  []externalRef0.Ipv6Addr `json:"ipv6EndpointAddress,omitempty"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// NFProfile Information of an NF Instance registered in the NRF
type NFProfile struct {
	AllowedNfDomains []string                 `json:"allowedNfDomains,omitempty"`
	AllowedNfTypes   []NFType                 `json:"allowedNfTypes,omitempty"`
	AllowedNssais    []externalRef0.ExtSnssai `json:"allowedNssais,omitempty"`
	AllowedPlmns     []externalRef0.PlmnId    `json:"allowedPlmns,omitempty"`
	AllowedSnpns     []externalRef0.PlmnIdNid `json:"allowedSnpns,omitempty"`

	// AmfInfo Information of an AMF NF Instance
	AmfInfo     *AmfInfo            `json:"amfInfo,omitempty"`
	AmfInfoList *map[string]AmfInfo `json:"amfInfoList,omitempty"`

	// AusfInfo Information of an AUSF NF Instance
	AusfInfo     *AusfInfo            `json:"ausfInfo,omitempty"`
	AusfInfoList *map[string]AusfInfo `json:"ausfInfoList,omitempty"`

	// BsfInfo Information of a BSF NF Instance
	BsfInfo     *BsfInfo            `json:"bsfInfo,omitempty"`
	BsfInfoList *map[string]BsfInfo `json:"bsfInfoList,omitempty"`
	Capacity    *int                `json:"capacity,omitempty"`

	// ChfInfo Information of a CHF NF Instance
	ChfInfo                          *ChfInfo                           `json:"chfInfo,omitempty"`
	ChfInfoList                      *map[string]ChfInfo                `json:"chfInfoList,omitempty"`
	CustomInfo                       *map[string]interface{}            `json:"customInfo,omitempty"`
	DefaultNotificationSubscriptions *[]DefaultNotificationSubscription `json:"defaultNotificationSubscriptions,omitempty"`

	// Fqdn Fully Qualified Domain Name
	Fqdn *Fqdn `json:"fqdn,omitempty"`

	// GmlcInfo Information of a GMLC NF Instance
	GmlcInfo       *GmlcInfo           `json:"gmlcInfo,omitempty"`
	HeartBeatTimer *int                `json:"heartBeatTimer,omitempty"`
	HssInfoList    *map[string]HssInfo `json:"hssInfoList,omitempty"`

	// InterPlmnFqdn Fully Qualified Domain Name
	InterPlmnFqdn *Fqdn                   `json:"interPlmnFqdn,omitempty"`
	Ipv4Addresses []externalRef0.Ipv4Addr `json:"ipv4Addresses,omitempty"`
	Ipv6Addresses []externalRef0.Ipv6Addr `json:"ipv6Addresses,omitempty"`
	LcHSupportInd *bool                   `json:"lcHSupportInd,omitempty"`

	// LmfInfo Information of an LMF NF Instance
	LmfInfo       *LmfInfo               `json:"lmfInfo,omitempty"`
	Load          *int                   `json:"load,omitempty"`
	LoadTimeStamp *externalRef0.DateTime `json:"loadTimeStamp,omitempty"`
	Locality      *string                `json:"locality,omitempty"`

	// NefInfo Information of an NEF NF Instance
	NefInfo                    *NefInfo                  `json:"nefInfo,omitempty"`
	NfInstanceId               externalRef0.NfInstanceId `json:"nfInstanceId"`
	NfInstanceName             *string                   `json:"nfInstanceName,omitempty"`
	NfProfileChangesInd        *bool                     `json:"nfProfileChangesInd,omitempty"`
	NfProfileChangesSupportInd *bool                     `json:"nfProfileChangesSupportInd,omitempty"`
	NfServiceList              *map[string]NFService     `json:"nfServiceList,omitempty"`
	NfServicePersistence       *bool                     `json:"nfServicePersistence,omitempty"`
	// Deprecated:
	NfServices            []NFService                       `json:"nfServices,omitempty"`
	NfSetIdList           []externalRef0.NfSetId            `json:"nfSetIdList,omitempty"`
	NfSetRecoveryTimeList *map[string]externalRef0.DateTime `json:"nfSetRecoveryTimeList,omitempty"`

	// NfStatus Status of a given NF Instance stored in NRF
	NfStatus NFStatus `json:"nfStatus"`

	// NfType NF types known to NRF
	NfType NFType `json:"nfType"`

	// NrfInfo Information of an NRF NF Instance, used in hierarchical NRF deployments
	NrfInfo *NrfInfo `json:"nrfInfo,omitempty"`
	NsiList []string `json:"nsiList,omitempty"`

	// NwdafInfo Information of a NWDAF NF Instance
	NwdafInfo      *NwdafInfo `json:"nwdafInfo,omitempty"`
	OlcHSupportInd *bool      `json:"olcHSupportInd,omitempty"`

	// PcfInfo Information of a PCF NF Instance
	PcfInfo           *PcfInfo                 `json:"pcfInfo,omitempty"`
	PcfInfoList       *map[string]PcfInfo      `json:"pcfInfoList,omitempty"`
	PcscfInfoList     *map[string]PcscfInfo    `json:"pcscfInfoList,omitempty"`
	PerPlmnSnssaiList []PlmnSnssai             `json:"perPlmnSnssaiList,omitempty"`
	PlmnList          []externalRef0.PlmnId    `json:"plmnList,omitempty"`
	Priority          *int                     `json:"priority,omitempty"`
	RecoveryTime      *externalRef0.DateTime   `json:"recoveryTime,omitempty"`
	SNssais           []externalRef0.ExtSnssai `json:"sNssais,omitempty"`
	ScpDomains        []string                 `json:"scpDomains,omitempty"`

	// ScpInfo Information of an SCP Instance
	ScpInfo                    *ScpInfo                          `json:"scpInfo,omitempty"`
	ServiceSetRecoveryTimeList *map[string]externalRef0.DateTime `json:"serviceSetRecoveryTimeList,omitempty"`
	ServingScope               []string                          `json:"servingScope,omitempty"`

	// SmfInfo Information of an SMF NF Instance
	SmfInfo     *SmfInfo                 `json:"smfInfo,omitempty"`
	SmfInfoList *map[string]SmfInfo      `json:"smfInfoList,omitempty"`
	SnpnList    []externalRef0.PlmnIdNid `json:"snpnList,omitempty"`

	// UdmInfo Information of an UDM NF Instance
	UdmInfo     *UdmInfo            `json:"udmInfo,omitempty"`
	UdmInfoList *map[string]UdmInfo `json:"udmInfoList,omitempty"`

	// UdrInfo Information of an UDR NF Instance
	UdrInfo     *UdrInfo            `json:"udrInfo,omitempty"`
	UdrInfoList *map[string]UdrInfo `json:"udrInfoList,omitempty"`

	// UdsfInfo Information related to UDSF
	UdsfInfo     *UdsfInfo            `json:"udsfInfo,omitempty"`
	UdsfInfoList *map[string]UdsfInfo `json:"udsfInfoList,omitempty"`

	// UpfInfo Information of an UPF NF Instance
	UpfInfo              *UpfInfo               `json:"upfInfo,omitempty"`
	UpfInfoList          *map[string]UpfInfo    `json:"upfInfoList,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NFService Information of a given NF Service Instance; it is part of the NFProfile of an NF Instance
type NFService struct {
	AllowedNfDomains                 []string                          `json:"allowedNfDomains,omitempty"`
	AllowedNfTypes                   []NFType                          `json:"allowedNfTypes,omitempty"`
	AllowedNssais                    []externalRef0.ExtSnssai          `json:"allowedNssais,omitempty"`
	AllowedOperationsPerNfInstance   *map[string][]string              `json:"allowedOperationsPerNfInstance,omitempty"`
	AllowedOperationsPerNfType       *map[string][]string              `json:"allowedOperationsPerNfType,omitempty"`
	AllowedPlmns                     []externalRef0.PlmnId             `json:"allowedPlmns,omitempty"`
	AllowedSnpns                     []externalRef0.PlmnIdNid          `json:"allowedSnpns,omitempty"`
	ApiPrefix                        *string                           `json:"apiPrefix,omitempty"`
	Capacity                         *int                              `json:"capacity,omitempty"`
	DefaultNotificationSubscriptions []DefaultNotificationSubscription `json:"defaultNotificationSubscriptions,omitempty"`

	// Fqdn Fully Qualified Domain Name
	Fqdn *Fqdn `json:"fqdn,omitempty"`

	// InterPlmnFqdn Fully Qualified Domain Name
	InterPlmnFqdn      *Fqdn                         `json:"interPlmnFqdn,omitempty"`
	IpEndPoints        []IpEndPoint                  `json:"ipEndPoints,omitempty"`
	Load               *int                          `json:"load,omitempty"`
	LoadTimeStamp      *externalRef0.DateTime        `json:"loadTimeStamp,omitempty"`
	NfServiceSetIdList []externalRef0.NfServiceSetId `json:"nfServiceSetIdList,omitempty"`

	// NfServiceStatus Status of a given NF Service Instance of an NF Instance stored in NRF
	NfServiceStatus   NFServiceStatus          `json:"nfServiceStatus"`
	Oauth2Required    *bool                    `json:"oauth2Required,omitempty"`
	PerPlmnSnssaiList []PlmnSnssai             `json:"perPlmnSnssaiList,omitempty"`
	Priority          *int                     `json:"priority,omitempty"`
	RecoveryTime      *externalRef0.DateTime   `json:"recoveryTime,omitempty"`
	SNssais           []externalRef0.ExtSnssai `json:"sNssais,omitempty"`
	Scheme            externalRef0.UriScheme   `json:"scheme"`
	ServiceInstanceId string                   `json:"serviceInstanceId"`

	// ServiceName Service names known to NRF
	ServiceName                     ServiceName                         `json:"serviceName"`
	SupportedFeatures               *externalRef0.SupportedFeatures     `json:"supportedFeatures,omitempty"`
	SupportedVendorSpecificFeatures *map[string][]VendorSpecificFeature `json:"supportedVendorSpecificFeatures,omitempty"`

	// VendorId Vendor ID of the NF Service instance (Private Enterprise Number assigned by IANA)
	VendorId             VendorId               `json:"vendorId,omitempty"`
	Versions             []NFServiceVersion     `json:"versions"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NFServiceStatus Status of a given NF Service Instance of an NF Instance stored in NRF
type NFServiceStatus string

// NFServiceVersion Contains the version details of an NF service
type NFServiceVersion struct {
	ApiFullVersion       string                 `json:"apiFullVersion"`
	ApiVersionInUri      string                 `json:"apiVersionInUri"`
	Expiry               *externalRef0.DateTime `json:"expiry,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NFStatus Status of a given NF Instance stored in NRF
type NFStatus string

// NFType NF types known to NRF
type NFType string

// NefCond Subscription to a set of NF Instances (NEFs), identified by Event ID(s) provided by AF, S-NSSAI(s), AF Instance ID, Application Identifier, External Identifier, External Group Identifier, or domain name.
type NefCond struct {
	AfEvents                       []string             `json:"afEvents,omitempty"`
	ConditionType                  NefCondConditionType `json:"conditionType"`
	ExternalGroupIdentifiersRanges []IdentityRange      `json:"externalGroupIdentifiersRanges,omitempty"`
	GpsiRanges                     []IdentityRange      `json:"gpsiRanges,omitempty"`

	// PfdData List of Application IDs and/or AF IDs managed by a given NEF Instance
	PfdData              *PfdData               `json:"pfdData,omitempty"`
	ServedFqdnList       []string               `json:"servedFqdnList,omitempty"`
	SnssaiList           []externalRef0.Snssai  `json:"snssaiList,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NefCondConditionType defines model for NefCond.ConditionType.
type NefCondConditionType string

// NefId Identity of the NEF
type NefId = string

// NefInfo Information of an NEF NF Instance
type NefInfo struct {
	// AfEeData AF Event Exposure data managed by a given NEF Instance
	AfEeData                       *AfEventExposureData `json:"afEeData,omitempty"`
	ExternalGroupIdentifiersRanges []IdentityRange      `json:"externalGroupIdentifiersRanges,omitempty"`
	GpsiRanges                     []IdentityRange      `json:"gpsiRanges,omitempty"`

	// NefId Identity of the NEF
	NefId *NefId `json:"nefId,omitempty"`

	// PfdData List of Application IDs and/or AF IDs managed by a given NEF Instance
	PfdData              *PfdData               `json:"pfdData,omitempty"`
	ServedFqdnList       []string               `json:"servedFqdnList,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NetworkSliceCond Subscription to a set of NFs, based on the slices (S-NSSAI and NSI) they support
type NetworkSliceCond struct {
	NsiList              *[]string              `json:"nsiList,omitempty"`
	SnssaiList           []externalRef0.Snssai  `json:"snssaiList"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NfGroupCond Subscription to a set of NFs based on their Group Id
type NfGroupCond struct {
	NfGroupId            externalRef0.NfGroupId `json:"nfGroupId"`
	NfType               NfGroupCondNfType      `json:"nfType"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NfGroupCondNfType defines model for NfGroupCond.NfType.
type NfGroupCondNfType string

// NfInfo Information of a generic NF Instance
type NfInfo struct {
	// NfType NF types known to NRF
	NfType               *NFType                `json:"nfType,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NfInstanceIdCond Subscription to a given NF Instance Id
type NfInstanceIdCond struct {
	NfInstanceId         externalRef0.NfInstanceId `json:"nfInstanceId"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// NfInstanceIdListCond Subscription to a list of NF Instances
type NfInstanceIdListCond struct {
	NfInstanceIdList     []externalRef0.NfInstanceId `json:"nfInstanceIdList"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// NfServiceSetCond Subscription to a set of NFs based on their Service Set Id
type NfServiceSetCond struct {
	NfServiceSetId       externalRef0.NfServiceSetId `json:"nfServiceSetId"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// NfSetCond Subscription to a set of NFs based on their Set Id
type NfSetCond struct {
	NfSetId              externalRef0.NfSetId   `json:"nfSetId"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NfTypeCond Subscription to a set of NFs based on their NF Type
type NfTypeCond struct {
	// NfType NF types known to NRF
	NfType               NFType                 `json:"nfType"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NotifCondition Condition (list of attributes in the NF Profile) to determine whether a notification must be sent by NRF
type NotifCondition struct {
	MonitoredAttributes   []string               `json:"monitoredAttributes,omitempty"`
	UnmonitoredAttributes []string               `json:"unmonitoredAttributes,omitempty"`
	AdditionalProperties  map[string]interface{} `json:"-"`
}

// NotificationData Data sent in notifications from NRF to subscribed NF Instances
type NotificationData struct {
	// ConditionEvent Indicates whether a notification is due to the NF Instance to start or stop being part of a condition for a subscription to a set of NFs
	ConditionEvent *ConditionEventType `json:"conditionEvent,omitempty"`

	// Event Types of events sent in notifications from NRF to subscribed NF Instances
	Event                NotificationEventType       `json:"event"`
	NfInstanceUri        externalRef0.Uri            `json:"nfInstanceUri"`
	NfProfile            *NotificationData_NfProfile `json:"nfProfile,omitempty"`
	ProfileChanges       []externalRef0.ChangeItem   `json:"profileChanges,omitempty"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// NotificationData_NfProfile defines model for NotificationData.NfProfile.
type NotificationData_NfProfile struct {
	AllowedNfDomains []string                 `json:"allowedNfDomains,omitempty"`
	AllowedNfTypes   []NFType                 `json:"allowedNfTypes,omitempty"`
	AllowedNssais    []externalRef0.ExtSnssai `json:"allowedNssais,omitempty"`
	AllowedPlmns     []externalRef0.PlmnId    `json:"allowedPlmns,omitempty"`
	AllowedSnpns     []externalRef0.PlmnIdNid `json:"allowedSnpns,omitempty"`

	// AmfInfo Information of an AMF NF Instance
	AmfInfo     *AmfInfo            `json:"amfInfo,omitempty"`
	AmfInfoList *map[string]AmfInfo `json:"amfInfoList,omitempty"`

	// AusfInfo Information of an AUSF NF Instance
	AusfInfo     *AusfInfo            `json:"ausfInfo,omitempty"`
	AusfInfoList *map[string]AusfInfo `json:"ausfInfoList,omitempty"`

	// BsfInfo Information of a BSF NF Instance
	BsfInfo     *BsfInfo            `json:"bsfInfo,omitempty"`
	BsfInfoList *map[string]BsfInfo `json:"bsfInfoList,omitempty"`
	Capacity    *int                `json:"capacity,omitempty"`

	// ChfInfo Information of a CHF NF Instance
	ChfInfo                          *ChfInfo                           `json:"chfInfo,omitempty"`
	ChfInfoList                      *map[string]ChfInfo                `json:"chfInfoList,omitempty"`
	CustomInfo                       *map[string]interface{}            `json:"customInfo,omitempty"`
	DefaultNotificationSubscriptions *[]DefaultNotificationSubscription `json:"defaultNotificationSubscriptions,omitempty"`

	// Fqdn Fully Qualified Domain Name
	Fqdn *Fqdn `json:"fqdn,omitempty"`

	// GmlcInfo Information of a GMLC NF Instance
	GmlcInfo       *GmlcInfo           `json:"gmlcInfo,omitempty"`
	HeartBeatTimer *int                `json:"heartBeatTimer,omitempty"`
	HssInfoList    *map[string]HssInfo `json:"hssInfoList,omitempty"`

	// InterPlmnFqdn Fully Qualified Domain Name
	InterPlmnFqdn *Fqdn                   `json:"interPlmnFqdn,omitempty"`
	Ipv4Addresses []externalRef0.Ipv4Addr `json:"ipv4Addresses,omitempty"`
	Ipv6Addresses []externalRef0.Ipv6Addr `json:"ipv6Addresses,omitempty"`
	LcHSupportInd *bool                   `json:"lcHSupportInd,omitempty"`

	// LmfInfo Information of an LMF NF Instance
	LmfInfo       *LmfInfo               `json:"lmfInfo,omitempty"`
	Load          *int                   `json:"load,omitempty"`
	LoadTimeStamp *externalRef0.DateTime `json:"loadTimeStamp,omitempty"`
	Locality      *string                `json:"locality,omitempty"`

	// NefInfo Information of an NEF NF Instance
	NefInfo                    *NefInfo                          `json:"nefInfo,omitempty"`
	NfInstanceId               externalRef0.NfInstanceId         `json:"nfInstanceId"`
	NfInstanceName             *string                           `json:"nfInstanceName,omitempty"`
	NfProfileChangesInd        *bool                             `json:"nfProfileChangesInd,omitempty"`
	NfProfileChangesSupportInd *bool                             `json:"nfProfileChangesSupportInd,omitempty"`
	NfServiceList              *map[string]NFService             `json:"nfServiceList,omitempty"`
	NfServicePersistence       *bool                             `json:"nfServicePersistence,omitempty"`
	NfServices                 *[]NFService                      `json:"nfServices,omitempty"`
	NfSetIdList                []externalRef0.NfSetId            `json:"nfSetIdList,omitempty"`
	NfSetRecoveryTimeList      *map[string]externalRef0.DateTime `json:"nfSetRecoveryTimeList,omitempty"`

	// NfStatus Status of a given NF Instance stored in NRF
	NfStatus NFStatus `json:"nfStatus"`

	// NfType NF types known to NRF
	NfType NFType `json:"nfType"`

	// NrfInfo Information of an NRF NF Instance, used in hierarchical NRF deployments
	NrfInfo *NrfInfo `json:"nrfInfo,omitempty"`
	NsiList []string `json:"nsiList,omitempty"`

	// NwdafInfo Information of a NWDAF NF Instance
	NwdafInfo      *NwdafInfo `json:"nwdafInfo,omitempty"`
	OlcHSupportInd *bool      `json:"olcHSupportInd,omitempty"`

	// PcfInfo Information of a PCF NF Instance
	PcfInfo           *PcfInfo                 `json:"pcfInfo,omitempty"`
	PcfInfoList       *map[string]PcfInfo      `json:"pcfInfoList,omitempty"`
	PcscfInfoList     *map[string]PcscfInfo    `json:"pcscfInfoList,omitempty"`
	PerPlmnSnssaiList []PlmnSnssai             `json:"perPlmnSnssaiList,omitempty"`
	PlmnList          []externalRef0.PlmnId    `json:"plmnList,omitempty"`
	Priority          *int                     `json:"priority,omitempty"`
	RecoveryTime      *externalRef0.DateTime   `json:"recoveryTime,omitempty"`
	SNssais           []externalRef0.ExtSnssai `json:"sNssais,omitempty"`
	ScpDomains        []string                 `json:"scpDomains,omitempty"`

	// ScpInfo Information of an SCP Instance
	ScpInfo                    *ScpInfo                          `json:"scpInfo,omitempty"`
	ServiceSetRecoveryTimeList *map[string]externalRef0.DateTime `json:"serviceSetRecoveryTimeList,omitempty"`
	ServingScope               []string                          `json:"servingScope,omitempty"`

	// SmfInfo Information of an SMF NF Instance
	SmfInfo     *SmfInfo                 `json:"smfInfo,omitempty"`
	SmfInfoList *map[string]SmfInfo      `json:"smfInfoList,omitempty"`
	SnpnList    []externalRef0.PlmnIdNid `json:"snpnList,omitempty"`

	// UdmInfo Information of an UDM NF Instance
	UdmInfo     *UdmInfo            `json:"udmInfo,omitempty"`
	UdmInfoList *map[string]UdmInfo `json:"udmInfoList,omitempty"`

	// UdrInfo Information of an UDR NF Instance
	UdrInfo     *UdrInfo            `json:"udrInfo,omitempty"`
	UdrInfoList *map[string]UdrInfo `json:"udrInfoList,omitempty"`

	// UdsfInfo Information related to UDSF
	UdsfInfo     *UdsfInfo            `json:"udsfInfo,omitempty"`
	UdsfInfoList *map[string]UdsfInfo `json:"udsfInfoList,omitempty"`

	// UpfInfo Information of an UPF NF Instance
	UpfInfo              *UpfInfo               `json:"upfInfo,omitempty"`
	UpfInfoList          *map[string]UpfInfo    `json:"upfInfoList,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NotificationEventType Types of events sent in notifications from NRF to subscribed NF Instances
type NotificationEventType string

// NotificationType Types of notifications used in Default Notification URIs in the NF Profile of an NF Instance
type NotificationType string

// NrfInfo Information of an NRF NF Instance, used in hierarchical NRF deployments
type NrfInfo struct {
	ServedAmfInfo        *map[string]AmfInfo              `json:"servedAmfInfo,omitempty"`
	ServedAmfInfoList    *map[string]map[string]AmfInfo   `json:"servedAmfInfoList,omitempty"`
	ServedAusfInfo       *map[string]AusfInfo             `json:"servedAusfInfo,omitempty"`
	ServedAusfInfoList   *map[string]map[string]AusfInfo  `json:"servedAusfInfoList,omitempty"`
	ServedBsfInfo        *map[string]BsfInfo              `json:"servedBsfInfo,omitempty"`
	ServedBsfInfoList    *map[string]map[string]BsfInfo   `json:"servedBsfInfoList,omitempty"`
	ServedChfInfo        *map[string]ChfInfo              `json:"servedChfInfo,omitempty"`
	ServedChfInfoList    *map[string]map[string]ChfInfo   `json:"servedChfInfoList,omitempty"`
	ServedGmlcInfo       *map[string]GmlcInfo             `json:"servedGmlcInfo,omitempty"`
	ServedHssInfoList    *map[string]map[string]HssInfo   `json:"servedHssInfoList,omitempty"`
	ServedLmfInfo        *map[string]LmfInfo              `json:"servedLmfInfo,omitempty"`
	ServedNefInfo        *map[string]NefInfo              `json:"servedNefInfo,omitempty"`
	ServedNfInfo         *map[string]NfInfo               `json:"servedNfInfo,omitempty"`
	ServedNwdafInfo      *map[string]NwdafInfo            `json:"servedNwdafInfo,omitempty"`
	ServedPcfInfo        *map[string]PcfInfo              `json:"servedPcfInfo,omitempty"`
	ServedPcfInfoList    *map[string]map[string]PcfInfo   `json:"servedPcfInfoList,omitempty"`
	ServedPcscfInfoList  *map[string]map[string]PcscfInfo `json:"servedPcscfInfoList,omitempty"`
	ServedScpInfoList    *map[string]ScpInfo              `json:"servedScpInfoList,omitempty"`
	ServedSmfInfo        *map[string]SmfInfo              `json:"servedSmfInfo,omitempty"`
	ServedSmfInfoList    *map[string]map[string]SmfInfo   `json:"servedSmfInfoList,omitempty"`
	ServedUdmInfo        *map[string]UdmInfo              `json:"servedUdmInfo,omitempty"`
	ServedUdmInfoList    *map[string]map[string]UdmInfo   `json:"servedUdmInfoList,omitempty"`
	ServedUdrInfo        *map[string]UdrInfo              `json:"servedUdrInfo,omitempty"`
	ServedUdrInfoList    *map[string]map[string]UdrInfo   `json:"servedUdrInfoList,omitempty"`
	ServedUdsfInfo       *map[string]UdsfInfo             `json:"servedUdsfInfo,omitempty"`
	ServedUdsfInfoList   *map[string]map[string]UdsfInfo  `json:"servedUdsfInfoList,omitempty"`
	ServedUpfInfo        *map[string]UpfInfo              `json:"servedUpfInfo,omitempty"`
	ServedUpfInfoList    *map[string]map[string]UpfInfo   `json:"servedUpfInfoList,omitempty"`
	AdditionalProperties map[string]interface{}           `json:"-"`
}

// NwdafCond Subscription to a set of NF Instances (NWDAFs), identified by Analytics ID(s), S-NSSAI(s) or NWDAF Serving Area information, i.e. list of TAIs for which the NWDAF can provide analytics.
type NwdafCond struct {
	AnalyticsIds         []string               `json:"analyticsIds,omitempty"`
	ConditionType        NwdafCondConditionType `json:"conditionType"`
	SnssaiList           []externalRef0.Snssai  `json:"snssaiList,omitempty"`
	TaiList              []externalRef0.Tai     `json:"taiList,omitempty"`
	TaiRangeList         []TaiRange             `json:"taiRangeList,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// NwdafCondConditionType defines model for NwdafCond.ConditionType.
type NwdafCondConditionType string

// NwdafInfo Information of a NWDAF NF Instance
type NwdafInfo struct {
	EventIds             []string               `json:"eventIds,omitempty"`
	NwdafEvents          []string               `json:"nwdafEvents,omitempty"`
	TaiList              []externalRef0.Tai     `json:"taiList,omitempty"`
	TaiRangeList         []TaiRange             `json:"taiRangeList,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OptionsResponse Communication options of the NRF sent in response payload of OPTIONS method
type OptionsResponse struct {
	SupportedFeatures    *externalRef0.SupportedFeatures `json:"supportedFeatures,omitempty"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// PcfInfo Information of a PCF NF Instance
type PcfInfo struct {
	DnnList              []externalRef0.Dnn            `json:"dnnList,omitempty"`
	GpsiRanges           []IdentityRange               `json:"gpsiRanges,omitempty"`
	GroupId              *externalRef0.NfGroupId       `json:"groupId,omitempty"`
	RxDiamHost           externalRef0.DiameterIdentity `json:"rxDiamHost,omitempty"`
	RxDiamRealm          externalRef0.DiameterIdentity `json:"rxDiamRealm,omitempty"`
	SupiRanges           []SupiRange                   `json:"supiRanges,omitempty"`
	V2xSupportInd        *bool                         `json:"v2xSupportInd,omitempty"`
	AdditionalProperties map[string]interface{}        `json:"-"`
}

// PcscfInfo Information of a P-CSCF NF Instance
type PcscfInfo struct {
	AccessType []externalRef0.AccessType `json:"accessType,omitempty"`
	DnnList    []externalRef0.Dnn        `json:"dnnList,omitempty"`

	// GmFqdn Fully Qualified Domain Name
	GmFqdn                  *Fqdn                   `json:"gmFqdn,omitempty"`
	GmIpv4Addresses         []externalRef0.Ipv4Addr `json:"gmIpv4Addresses,omitempty"`
	GmIpv6Addresses         []externalRef0.Ipv6Addr `json:"gmIpv6Addresses,omitempty"`
	ServedIpv4AddressRanges []Ipv4AddressRange      `json:"servedIpv4AddressRanges,omitempty"`
	ServedIpv6PrefixRanges  []Ipv6PrefixRange       `json:"servedIpv6PrefixRanges,omitempty"`
	AdditionalProperties    map[string]interface{}  `json:"-"`
}

// PfdData List of Application IDs and/or AF IDs managed by a given NEF Instance
type PfdData struct {
	AfIds                []string               `json:"afIds,omitempty"`
	AppIds               []string               `json:"appIds,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PlmnRange Range of PLMN IDs
type PlmnRange struct {
	End                  string                 `json:"end,omitempty"`
	Pattern              *string                `json:"pattern,omitempty"`
	Start                string                 `json:"start,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PlmnSnssai List of network slices (S-NSSAIs) for a given PLMN ID
type PlmnSnssai struct {
	Nid                  externalRef0.Nid         `json:"nid,omitempty"`
	PlmnId               externalRef0.PlmnId      `json:"plmnId"`
	SNssaiList           []externalRef0.ExtSnssai `json:"sNssaiList"`
	AdditionalProperties map[string]interface{}   `json:"-"`
}

// ScpDomainCond Subscription to a set of NF or SCP instances belonging to certain SCP domains
type ScpDomainCond struct {
	ScpDomains           []string               `json:"scpDomains"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ScpDomainInfo SCP Domain specific information
type ScpDomainInfo struct {
	// ScpFqdn Fully Qualified Domain Name
	ScpFqdn              *Fqdn                  `json:"scpFqdn,omitempty"`
	ScpIpEndPoints       []IpEndPoint           `json:"scpIpEndPoints,omitempty"`
	ScpPorts             *map[string]int        `json:"scpPorts,omitempty"`
	ScpPrefix            *string                `json:"scpPrefix,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ScpInfo Information of an SCP Instance
type ScpInfo struct {
	AddressDomains []string `json:"addressDomains,omitempty"`

	// IpReachability Indicates the type(s) of IP addresses reachable via an SCP
	IpReachability       *IpReachability           `json:"ipReachability,omitempty"`
	Ipv4AddrRanges       []Ipv4AddressRange        `json:"ipv4AddrRanges,omitempty"`
	Ipv4Addresses        []externalRef0.Ipv4Addr   `json:"ipv4Addresses,omitempty"`
	Ipv6PrefixRanges     []Ipv6PrefixRange         `json:"ipv6PrefixRanges,omitempty"`
	Ipv6Prefixes         []externalRef0.Ipv6Prefix `json:"ipv6Prefixes,omitempty"`
	RemotePlmnList       []externalRef0.PlmnId     `json:"remotePlmnList,omitempty"`
	ScpDomainInfoList    *map[string]ScpDomainInfo `json:"scpDomainInfoList,omitempty"`
	ScpPorts             *map[string]int           `json:"scpPorts,omitempty"`
	ScpPrefix            *string                   `json:"scpPrefix,omitempty"`
	ServedNfSetIdList    []externalRef0.NfSetId    `json:"servedNfSetIdList,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// ServiceName Service names known to NRF
type ServiceName string

// ServiceNameCond Subscription to a set of NFs based on their support for a given Service Name
type ServiceNameCond struct {
	// ServiceName Service names known to NRF
	ServiceName          ServiceName            `json:"serviceName"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SmfInfo Information of an SMF NF Instance
type SmfInfo struct {
	AccessType []externalRef0.AccessType `json:"accessType,omitempty"`

	// PgwFqdn Fully Qualified Domain Name
	PgwFqdn              *Fqdn                  `json:"pgwFqdn,omitempty"`
	Priority             *int                   `json:"priority,omitempty"`
	SNssaiSmfInfoList    []SnssaiSmfInfoItem    `json:"sNssaiSmfInfoList"`
	TaiList              []externalRef0.Tai     `json:"taiList,omitempty"`
	TaiRangeList         []TaiRange             `json:"taiRangeList,omitempty"`
	VsmfSupportInd       *bool                  `json:"vsmfSupportInd,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SnssaiSmfInfoItem Set of parameters supported by SMF for a given S-NSSAI
type SnssaiSmfInfoItem struct {
	DnnSmfInfoList       []DnnSmfInfoItem       `json:"dnnSmfInfoList"`
	SNssai               externalRef0.Snssai    `json:"sNssai"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SnssaiUpfInfoItem Set of parameters supported by UPF for a given S-NSSAI
type SnssaiUpfInfoItem struct {
	DnnUpfInfoList       []DnnUpfInfoItem       `json:"dnnUpfInfoList"`
	RedundantTransport   *bool                  `json:"redundantTransport,omitempty"`
	SNssai               externalRef0.Snssai    `json:"sNssai"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SubscriptionData Information of a subscription to notifications to NRF events, included in subscription requests and responses
type SubscriptionData struct {
	NfStatusNotificationUri string           `json:"nfStatusNotificationUri"`
	Nid                     externalRef0.Nid `json:"nid,omitempty"`

	// NotifCondition Condition (list of attributes in the NF Profile) to determine whether a notification must be sent by NRF
	NotifCondition       *NotifCondition                 `json:"notifCondition,omitempty"`
	NrfSupportedFeatures *externalRef0.SupportedFeatures `json:"nrfSupportedFeatures,omitempty"`
	PlmnId               *externalRef0.PlmnId            `json:"plmnId,omitempty"`

	// ReqNfFqdn Fully Qualified Domain Name
	ReqNfFqdn       *Fqdn                      `json:"reqNfFqdn,omitempty"`
	ReqNfInstanceId *externalRef0.NfInstanceId `json:"reqNfInstanceId,omitempty"`

	// ReqNfType NF types known to NRF
	ReqNfType            *NFType                         `json:"reqNfType,omitempty"`
	ReqNotifEvents       []NotificationEventType         `json:"reqNotifEvents,omitempty"`
	ReqPerPlmnSnssais    []PlmnSnssai                    `json:"reqPerPlmnSnssais,omitempty"`
	ReqPlmnList          []externalRef0.PlmnId           `json:"reqPlmnList,omitempty"`
	ReqSnpnList          []externalRef0.PlmnIdNid        `json:"reqSnpnList,omitempty"`
	ReqSnssais           []externalRef0.Snssai           `json:"reqSnssais,omitempty"`
	RequesterFeatures    *externalRef0.SupportedFeatures `json:"requesterFeatures,omitempty"`
	ServingScope         []string                        `json:"servingScope,omitempty"`
	SubscrCond           *SubscriptionData_SubscrCond    `json:"subscrCond,omitempty"`
	SubscriptionId       string                          `json:"subscriptionId,omitempty"`
	ValidityTime         *externalRef0.DateTime          `json:"validityTime,omitempty"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// SubscriptionData_SubscrCond defines model for SubscriptionData.SubscrCond.
type SubscriptionData_SubscrCond struct {
	union json.RawMessage
}

// SupiRange A range of SUPIs (subscriber identities), either based on a numeric range, or based on regular-expression matching
type SupiRange struct {
	End                  string                 `json:"end,omitempty"`
	Pattern              *string                `json:"pattern,omitempty"`
	Start                string                 `json:"start,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// TacRange Range of TACs (Tracking Area Codes)
type TacRange struct {
	End                  string                 `json:"end,omitempty"`
	Pattern              *string                `json:"pattern,omitempty"`
	Start                string                 `json:"start,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// TaiRange Range of TAIs (Tracking Area Identities)
type TaiRange struct {
	Nid                  externalRef0.Nid       `json:"nid,omitempty"`
	PlmnId               externalRef0.PlmnId    `json:"plmnId"`
	TacRangeList         []TacRange             `json:"tacRangeList"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// TngfInfo Infomation of the TNGF endpoints
type TngfInfo struct {
	// EndpointFqdn Fully Qualified Domain Name
	EndpointFqdn          *Fqdn                   `json:"endpointFqdn,omitempty"`
	Ipv4EndpointAddresses []externalRef0.Ipv4Addr `json:"ipv4EndpointAddresses,omitempty"`
	Ipv6EndpointAddresses []externalRef0.Ipv6Addr `json:"ipv6EndpointAddresses,omitempty"`
	AdditionalProperties  map[string]interface{}  `json:"-"`
}

// TransportProtocol Types of transport protocol used in a given IP endpoint of an NF Service Instance
type TransportProtocol string

// TwifInfo Addressing information (IP addresses, FQDN) of the TWIF
type TwifInfo struct {
	// EndpointFqdn Fully Qualified Domain Name
	EndpointFqdn          *Fqdn                   `json:"endpointFqdn,omitempty"`
	Ipv4EndpointAddresses []externalRef0.Ipv4Addr `json:"ipv4EndpointAddresses,omitempty"`
	Ipv6EndpointAddresses []externalRef0.Ipv6Addr `json:"ipv6EndpointAddresses,omitempty"`
	AdditionalProperties  map[string]interface{}  `json:"-"`
}

// UPInterfaceType Types of User-Plane interfaces of the UPF
type UPInterfaceType string

// UdmInfo Information of an UDM NF Instance
type UdmInfo struct {
	ExternalGroupIdentifiersRanges []IdentityRange         `json:"externalGroupIdentifiersRanges,omitempty"`
	GpsiRanges                     []IdentityRange         `json:"gpsiRanges,omitempty"`
	GroupId                        *externalRef0.NfGroupId `json:"groupId,omitempty"`
	InternalGroupIdentifiersRanges []InternalGroupIdRange  `json:"internalGroupIdentifiersRanges,omitempty"`
	RoutingIndicators              []string                `json:"routingIndicators,omitempty"`
	SupiRanges                     []SupiRange             `json:"supiRanges,omitempty"`
	AdditionalProperties           map[string]interface{}  `json:"-"`
}

// UdrInfo Information of an UDR NF Instance
type UdrInfo struct {
	ExternalGroupIdentifiersRanges []IdentityRange         `json:"externalGroupIdentifiersRanges,omitempty"`
	GpsiRanges                     []IdentityRange         `json:"gpsiRanges,omitempty"`
	GroupId                        *externalRef0.NfGroupId `json:"groupId,omitempty"`
	SupiRanges                     []SupiRange             `json:"supiRanges,omitempty"`
	SupportedDataSets              []DataSetId             `json:"supportedDataSets,omitempty"`
	AdditionalProperties           map[string]interface{}  `json:"-"`
}

// UdsfInfo Information related to UDSF
type UdsfInfo struct {
	GroupId *externalRef0.NfGroupId `json:"groupId,omitempty"`

	// StorageIdRanges A map (list of key-value pairs) where realmId serves as key and each value in the map is an array of IdentityRanges. Each IdentityRange is a range of storageIds.
	StorageIdRanges      *map[string][]IdentityRange `json:"storageIdRanges,omitempty"`
	SupiRanges           []SupiRange                 `json:"supiRanges,omitempty"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// UpfCond Subscription to a set of NF Instances (UPFs), able to serve a certain service area (i.e. SMF serving area or TAI list)
type UpfCond struct {
	ConditionType        UpfCondConditionType   `json:"conditionType"`
	SmfServingArea       []string               `json:"smfServingArea,omitempty"`
	TaiList              []externalRef0.Tai     `json:"taiList,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpfCondConditionType defines model for UpfCond.ConditionType.
type UpfCondConditionType string

// UpfInfo Information of an UPF NF Instance
type UpfInfo struct {
	AtsssCapability      *externalRef0.AtsssCapability `json:"atsssCapability,omitempty"`
	DataForwarding       *bool                         `json:"dataForwarding,omitempty"`
	InterfaceUpfInfoList []InterfaceUpfInfoItem        `json:"interfaceUpfInfoList,omitempty"`
	Ipups                *bool                         `json:"ipups,omitempty"`
	IwkEpsInd            *bool                         `json:"iwkEpsInd,omitempty"`
	PduSessionTypes      []externalRef0.PduSessionType `json:"pduSessionTypes,omitempty"`
	Priority             *int                          `json:"priority,omitempty"`
	RedundantGtpu        *bool                         `json:"redundantGtpu,omitempty"`
	SNssaiUpfInfoList    []SnssaiUpfInfoItem           `json:"sNssaiUpfInfoList"`
	SmfServingArea       []string                      `json:"smfServingArea,omitempty"`
	TaiList              []externalRef0.Tai            `json:"taiList,omitempty"`

	// TngfInfo Infomation of the TNGF endpoints
	TngfInfo *TngfInfo `json:"tngfInfo,omitempty"`

	// TwifInfo Addressing information (IP addresses, FQDN) of the TWIF
	TwifInfo    *TwifInfo `json:"twifInfo,omitempty"`
	UeIpAddrInd *bool     `json:"ueIpAddrInd,omitempty"`

	// WAgfInfo Information of the W-AGF end-points
	WAgfInfo             *WAgfInfo              `json:"wAgfInfo,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// VendorId Vendor ID of the NF Service instance (Private Enterprise Number assigned by IANA)
type VendorId = string

// VendorSpecificFeature Information about a vendor-specific feature
type VendorSpecificFeature struct {
	FeatureName          string                 `json:"featureName"`
	FeatureVersion       string                 `json:"featureVersion"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// WAgfInfo Information of the W-AGF end-points
type WAgfInfo struct {
	// EndpointFqdn Fully Qualified Domain Name
	EndpointFqdn          *Fqdn                   `json:"endpointFqdn,omitempty"`
	Ipv4EndpointAddresses []externalRef0.Ipv4Addr `json:"ipv4EndpointAddresses,omitempty"`
	Ipv6EndpointAddresses []externalRef0.Ipv6Addr `json:"ipv6EndpointAddresses,omitempty"`
	AdditionalProperties  map[string]interface{}  `json:"-"`
}

// GetNFInstancesParams defines parameters for GetNFInstances.
type GetNFInstancesParams struct {
	// NfType Type of NF
	NfType *NFType `form:"nf-type,omitempty" json:"nf-type,omitempty"`

	// Limit How many items to return at one time
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetNFInstanceParams defines parameters for GetNFInstance.
type GetNFInstanceParams struct {
	// RequesterFeatures Features supported by the NF Service Consumer
	RequesterFeatures *externalRef0.SupportedFeatures `form:"requester-features,omitempty" json:"requester-features,omitempty"`
}

// UpdateNFInstanceApplicationJSONPatchPlusJSONBody defines parameters for UpdateNFInstance.
type UpdateNFInstanceApplicationJSONPatchPlusJSONBody = []externalRef0.PatchItem

// UpdateNFInstanceParams defines parameters for UpdateNFInstance.
type UpdateNFInstanceParams struct {
	// ContentEncoding Content-Encoding, described in IETF RFC 7231
	ContentEncoding *string `json:"Content-Encoding,omitempty"`

	// AcceptEncoding Accept-Encoding, described in IETF RFC 7231
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// IfMatch Validator for conditional requests, as described in IETF RFC 7232, 3.2
	IfMatch *string `json:"If-Match,omitempty"`
}

// RegisterNFInstanceParams defines parameters for RegisterNFInstance.
type RegisterNFInstanceParams struct {
	// ContentEncoding Content-Encoding, described in IETF RFC 7231
	ContentEncoding *string `json:"Content-Encoding,omitempty"`

	// AcceptEncoding Accept-Encoding, described in IETF RFC 7231
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`
}

// CreateSubscriptionParams defines parameters for CreateSubscription.
type CreateSubscriptionParams struct {
	// ContentEncoding Content-Encoding, described in IETF RFC 7231
	ContentEncoding *string `json:"Content-Encoding,omitempty"`

	// AcceptEncoding Accept-Encoding, described in IETF RFC 7231
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`
}

// UpdateSubscriptionApplicationJSONPatchPlusJSONBody defines parameters for UpdateSubscription.
type UpdateSubscriptionApplicationJSONPatchPlusJSONBody = []externalRef0.PatchItem

// UpdateSubscriptionParams defines parameters for UpdateSubscription.
type UpdateSubscriptionParams struct {
	// ContentEncoding Content-Encoding, described in IETF RFC 7231
	ContentEncoding *string `json:"Content-Encoding,omitempty"`

	// AcceptEncoding Accept-Encoding, described in IETF RFC 7231
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`
}

// UpdateNFInstanceApplicationJSONPatchPlusJSONRequestBody defines body for UpdateNFInstance for application/json-patch+json ContentType.
type UpdateNFInstanceApplicationJSONPatchPlusJSONRequestBody = UpdateNFInstanceApplicationJSONPatchPlusJSONBody

// RegisterNFInstanceJSONRequestBody defines body for RegisterNFInstance for application/json ContentType.
type RegisterNFInstanceJSONRequestBody = NFProfile

// CreateSubscriptionJSONRequestBody defines body for CreateSubscription for application/json ContentType.
type CreateSubscriptionJSONRequestBody = SubscriptionData

// UpdateSubscriptionApplicationJSONPatchPlusJSONRequestBody defines body for UpdateSubscription for application/json-patch+json ContentType.
type UpdateSubscriptionApplicationJSONPatchPlusJSONRequestBody = UpdateSubscriptionApplicationJSONPatchPlusJSONBody

// Getter for additional properties for AfEventExposureData. Returns the specified
// element and whether it was found
func (a AfEventExposureData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AfEventExposureData
func (a *AfEventExposureData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AfEventExposureData to handle AdditionalProperties
func (a *AfEventExposureData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["afEvents"]; found {
		err = json.Unmarshal(raw, &a.AfEvents)
		if err != nil {
			return fmt.Errorf("error reading 'afEvents': %w", err)
		}
		delete(object, "afEvents")
	}

	if raw, found := object["afIds"]; found {
		err = json.Unmarshal(raw, &a.AfIds)
		if err != nil {
			return fmt.Errorf("error reading 'afIds': %w", err)
		}
		delete(object, "afIds")
	}

	if raw, found := object["appIds"]; found {
		err = json.Unmarshal(raw, &a.AppIds)
		if err != nil {
			return fmt.Errorf("error reading 'appIds': %w", err)
		}
		delete(object, "appIds")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AfEventExposureData to handle AdditionalProperties
func (a AfEventExposureData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["afEvents"], err = json.Marshal(a.AfEvents)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'afEvents': %w", err)
	}

	if len(a.AfIds) != 0 {
		object["afIds"], err = json.Marshal(a.AfIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'afIds': %w", err)
		}
	}

	if len(a.AppIds) != 0 {
		object["appIds"], err = json.Marshal(a.AppIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'appIds': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AmfCond. Returns the specified
// element and whether it was found
func (a AmfCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AmfCond
func (a *AmfCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AmfCond to handle AdditionalProperties
func (a *AmfCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["amfRegionId"]; found {
		err = json.Unmarshal(raw, &a.AmfRegionId)
		if err != nil {
			return fmt.Errorf("error reading 'amfRegionId': %w", err)
		}
		delete(object, "amfRegionId")
	}

	if raw, found := object["amfSetId"]; found {
		err = json.Unmarshal(raw, &a.AmfSetId)
		if err != nil {
			return fmt.Errorf("error reading 'amfSetId': %w", err)
		}
		delete(object, "amfSetId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AmfCond to handle AdditionalProperties
func (a AmfCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AmfRegionId) != 0 {
		object["amfRegionId"], err = json.Marshal(a.AmfRegionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'amfRegionId': %w", err)
		}
	}

	if len(a.AmfSetId) != 0 {
		object["amfSetId"], err = json.Marshal(a.AmfSetId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'amfSetId': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AmfInfo. Returns the specified
// element and whether it was found
func (a AmfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AmfInfo
func (a *AmfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AmfInfo to handle AdditionalProperties
func (a *AmfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["amfRegionId"]; found {
		err = json.Unmarshal(raw, &a.AmfRegionId)
		if err != nil {
			return fmt.Errorf("error reading 'amfRegionId': %w", err)
		}
		delete(object, "amfRegionId")
	}

	if raw, found := object["amfSetId"]; found {
		err = json.Unmarshal(raw, &a.AmfSetId)
		if err != nil {
			return fmt.Errorf("error reading 'amfSetId': %w", err)
		}
		delete(object, "amfSetId")
	}

	if raw, found := object["backupInfoAmfFailure"]; found {
		err = json.Unmarshal(raw, &a.BackupInfoAmfFailure)
		if err != nil {
			return fmt.Errorf("error reading 'backupInfoAmfFailure': %w", err)
		}
		delete(object, "backupInfoAmfFailure")
	}

	if raw, found := object["backupInfoAmfRemoval"]; found {
		err = json.Unmarshal(raw, &a.BackupInfoAmfRemoval)
		if err != nil {
			return fmt.Errorf("error reading 'backupInfoAmfRemoval': %w", err)
		}
		delete(object, "backupInfoAmfRemoval")
	}

	if raw, found := object["guamiList"]; found {
		err = json.Unmarshal(raw, &a.GuamiList)
		if err != nil {
			return fmt.Errorf("error reading 'guamiList': %w", err)
		}
		delete(object, "guamiList")
	}

	if raw, found := object["n2InterfaceAmfInfo"]; found {
		err = json.Unmarshal(raw, &a.N2InterfaceAmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'n2InterfaceAmfInfo': %w", err)
		}
		delete(object, "n2InterfaceAmfInfo")
	}

	if raw, found := object["taiList"]; found {
		err = json.Unmarshal(raw, &a.TaiList)
		if err != nil {
			return fmt.Errorf("error reading 'taiList': %w", err)
		}
		delete(object, "taiList")
	}

	if raw, found := object["taiRangeList"]; found {
		err = json.Unmarshal(raw, &a.TaiRangeList)
		if err != nil {
			return fmt.Errorf("error reading 'taiRangeList': %w", err)
		}
		delete(object, "taiRangeList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AmfInfo to handle AdditionalProperties
func (a AmfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["amfRegionId"], err = json.Marshal(a.AmfRegionId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'amfRegionId': %w", err)
	}

	object["amfSetId"], err = json.Marshal(a.AmfSetId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'amfSetId': %w", err)
	}

	if len(a.BackupInfoAmfFailure) != 0 {
		object["backupInfoAmfFailure"], err = json.Marshal(a.BackupInfoAmfFailure)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'backupInfoAmfFailure': %w", err)
		}
	}

	if len(a.BackupInfoAmfRemoval) != 0 {
		object["backupInfoAmfRemoval"], err = json.Marshal(a.BackupInfoAmfRemoval)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'backupInfoAmfRemoval': %w", err)
		}
	}

	object["guamiList"], err = json.Marshal(a.GuamiList)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'guamiList': %w", err)
	}

	if a.N2InterfaceAmfInfo != nil {
		object["n2InterfaceAmfInfo"], err = json.Marshal(a.N2InterfaceAmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'n2InterfaceAmfInfo': %w", err)
		}
	}

	if len(a.TaiList) != 0 {
		object["taiList"], err = json.Marshal(a.TaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'taiList': %w", err)
		}
	}

	if len(a.TaiRangeList) != 0 {
		object["taiRangeList"], err = json.Marshal(a.TaiRangeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'taiRangeList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AusfInfo. Returns the specified
// element and whether it was found
func (a AusfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AusfInfo
func (a *AusfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AusfInfo to handle AdditionalProperties
func (a *AusfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["groupId"]; found {
		err = json.Unmarshal(raw, &a.GroupId)
		if err != nil {
			return fmt.Errorf("error reading 'groupId': %w", err)
		}
		delete(object, "groupId")
	}

	if raw, found := object["routingIndicators"]; found {
		err = json.Unmarshal(raw, &a.RoutingIndicators)
		if err != nil {
			return fmt.Errorf("error reading 'routingIndicators': %w", err)
		}
		delete(object, "routingIndicators")
	}

	if raw, found := object["supiRanges"]; found {
		err = json.Unmarshal(raw, &a.SupiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'supiRanges': %w", err)
		}
		delete(object, "supiRanges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AusfInfo to handle AdditionalProperties
func (a AusfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.GroupId != nil {
		object["groupId"], err = json.Marshal(a.GroupId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupId': %w", err)
		}
	}

	if len(a.RoutingIndicators) != 0 {
		object["routingIndicators"], err = json.Marshal(a.RoutingIndicators)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'routingIndicators': %w", err)
		}
	}

	if len(a.SupiRanges) != 0 {
		object["supiRanges"], err = json.Marshal(a.SupiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supiRanges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for BsfInfo. Returns the specified
// element and whether it was found
func (a BsfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for BsfInfo
func (a *BsfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for BsfInfo to handle AdditionalProperties
func (a *BsfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dnnList"]; found {
		err = json.Unmarshal(raw, &a.DnnList)
		if err != nil {
			return fmt.Errorf("error reading 'dnnList': %w", err)
		}
		delete(object, "dnnList")
	}

	if raw, found := object["ipDomainList"]; found {
		err = json.Unmarshal(raw, &a.IpDomainList)
		if err != nil {
			return fmt.Errorf("error reading 'ipDomainList': %w", err)
		}
		delete(object, "ipDomainList")
	}

	if raw, found := object["ipv4AddressRanges"]; found {
		err = json.Unmarshal(raw, &a.Ipv4AddressRanges)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4AddressRanges': %w", err)
		}
		delete(object, "ipv4AddressRanges")
	}

	if raw, found := object["ipv6PrefixRanges"]; found {
		err = json.Unmarshal(raw, &a.Ipv6PrefixRanges)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6PrefixRanges': %w", err)
		}
		delete(object, "ipv6PrefixRanges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for BsfInfo to handle AdditionalProperties
func (a BsfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.DnnList) != 0 {
		object["dnnList"], err = json.Marshal(a.DnnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dnnList': %w", err)
		}
	}

	if len(a.IpDomainList) != 0 {
		object["ipDomainList"], err = json.Marshal(a.IpDomainList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipDomainList': %w", err)
		}
	}

	if len(a.Ipv4AddressRanges) != 0 {
		object["ipv4AddressRanges"], err = json.Marshal(a.Ipv4AddressRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4AddressRanges': %w", err)
		}
	}

	if len(a.Ipv6PrefixRanges) != 0 {
		object["ipv6PrefixRanges"], err = json.Marshal(a.Ipv6PrefixRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6PrefixRanges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ChfInfo. Returns the specified
// element and whether it was found
func (a ChfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ChfInfo
func (a *ChfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ChfInfo to handle AdditionalProperties
func (a *ChfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["gpsiRangeList"]; found {
		err = json.Unmarshal(raw, &a.GpsiRangeList)
		if err != nil {
			return fmt.Errorf("error reading 'gpsiRangeList': %w", err)
		}
		delete(object, "gpsiRangeList")
	}

	if raw, found := object["groupId"]; found {
		err = json.Unmarshal(raw, &a.GroupId)
		if err != nil {
			return fmt.Errorf("error reading 'groupId': %w", err)
		}
		delete(object, "groupId")
	}

	if raw, found := object["plmnRangeList"]; found {
		err = json.Unmarshal(raw, &a.PlmnRangeList)
		if err != nil {
			return fmt.Errorf("error reading 'plmnRangeList': %w", err)
		}
		delete(object, "plmnRangeList")
	}

	if raw, found := object["primaryChfInstance"]; found {
		err = json.Unmarshal(raw, &a.PrimaryChfInstance)
		if err != nil {
			return fmt.Errorf("error reading 'primaryChfInstance': %w", err)
		}
		delete(object, "primaryChfInstance")
	}

	if raw, found := object["secondaryChfInstance"]; found {
		err = json.Unmarshal(raw, &a.SecondaryChfInstance)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryChfInstance': %w", err)
		}
		delete(object, "secondaryChfInstance")
	}

	if raw, found := object["supiRangeList"]; found {
		err = json.Unmarshal(raw, &a.SupiRangeList)
		if err != nil {
			return fmt.Errorf("error reading 'supiRangeList': %w", err)
		}
		delete(object, "supiRangeList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ChfInfo to handle AdditionalProperties
func (a ChfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.GpsiRangeList) != 0 {
		object["gpsiRangeList"], err = json.Marshal(a.GpsiRangeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gpsiRangeList': %w", err)
		}
	}

	if a.GroupId != nil {
		object["groupId"], err = json.Marshal(a.GroupId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupId': %w", err)
		}
	}

	if len(a.PlmnRangeList) != 0 {
		object["plmnRangeList"], err = json.Marshal(a.PlmnRangeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'plmnRangeList': %w", err)
		}
	}

	if a.PrimaryChfInstance != nil {
		object["primaryChfInstance"], err = json.Marshal(a.PrimaryChfInstance)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryChfInstance': %w", err)
		}
	}

	if a.SecondaryChfInstance != nil {
		object["secondaryChfInstance"], err = json.Marshal(a.SecondaryChfInstance)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryChfInstance': %w", err)
		}
	}

	if len(a.SupiRangeList) != 0 {
		object["supiRangeList"], err = json.Marshal(a.SupiRangeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supiRangeList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DefaultNotificationSubscription. Returns the specified
// element and whether it was found
func (a DefaultNotificationSubscription) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DefaultNotificationSubscription
func (a *DefaultNotificationSubscription) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DefaultNotificationSubscription to handle AdditionalProperties
func (a *DefaultNotificationSubscription) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["binding"]; found {
		err = json.Unmarshal(raw, &a.Binding)
		if err != nil {
			return fmt.Errorf("error reading 'binding': %w", err)
		}
		delete(object, "binding")
	}

	if raw, found := object["callbackUri"]; found {
		err = json.Unmarshal(raw, &a.CallbackUri)
		if err != nil {
			return fmt.Errorf("error reading 'callbackUri': %w", err)
		}
		delete(object, "callbackUri")
	}

	if raw, found := object["n1MessageClass"]; found {
		err = json.Unmarshal(raw, &a.N1MessageClass)
		if err != nil {
			return fmt.Errorf("error reading 'n1MessageClass': %w", err)
		}
		delete(object, "n1MessageClass")
	}

	if raw, found := object["n2InformationClass"]; found {
		err = json.Unmarshal(raw, &a.N2InformationClass)
		if err != nil {
			return fmt.Errorf("error reading 'n2InformationClass': %w", err)
		}
		delete(object, "n2InformationClass")
	}

	if raw, found := object["notificationType"]; found {
		err = json.Unmarshal(raw, &a.NotificationType)
		if err != nil {
			return fmt.Errorf("error reading 'notificationType': %w", err)
		}
		delete(object, "notificationType")
	}

	if raw, found := object["versions"]; found {
		err = json.Unmarshal(raw, &a.Versions)
		if err != nil {
			return fmt.Errorf("error reading 'versions': %w", err)
		}
		delete(object, "versions")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DefaultNotificationSubscription to handle AdditionalProperties
func (a DefaultNotificationSubscription) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Binding != nil {
		object["binding"], err = json.Marshal(a.Binding)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'binding': %w", err)
		}
	}

	object["callbackUri"], err = json.Marshal(a.CallbackUri)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'callbackUri': %w", err)
	}

	if a.N1MessageClass != nil {
		object["n1MessageClass"], err = json.Marshal(a.N1MessageClass)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'n1MessageClass': %w", err)
		}
	}

	if a.N2InformationClass != nil {
		object["n2InformationClass"], err = json.Marshal(a.N2InformationClass)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'n2InformationClass': %w", err)
		}
	}

	object["notificationType"], err = json.Marshal(a.NotificationType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'notificationType': %w", err)
	}

	if len(a.Versions) != 0 {
		object["versions"], err = json.Marshal(a.Versions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'versions': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DnnSmfInfoItem. Returns the specified
// element and whether it was found
func (a DnnSmfInfoItem) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DnnSmfInfoItem
func (a *DnnSmfInfoItem) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DnnSmfInfoItem to handle AdditionalProperties
func (a *DnnSmfInfoItem) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dnn"]; found {
		err = json.Unmarshal(raw, &a.Dnn)
		if err != nil {
			return fmt.Errorf("error reading 'dnn': %w", err)
		}
		delete(object, "dnn")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DnnSmfInfoItem to handle AdditionalProperties
func (a DnnSmfInfoItem) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["dnn"], err = json.Marshal(a.Dnn)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'dnn': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DnnUpfInfoItem. Returns the specified
// element and whether it was found
func (a DnnUpfInfoItem) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DnnUpfInfoItem
func (a *DnnUpfInfoItem) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DnnUpfInfoItem to handle AdditionalProperties
func (a *DnnUpfInfoItem) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dnaiList"]; found {
		err = json.Unmarshal(raw, &a.DnaiList)
		if err != nil {
			return fmt.Errorf("error reading 'dnaiList': %w", err)
		}
		delete(object, "dnaiList")
	}

	if raw, found := object["dnaiNwInstanceList"]; found {
		err = json.Unmarshal(raw, &a.DnaiNwInstanceList)
		if err != nil {
			return fmt.Errorf("error reading 'dnaiNwInstanceList': %w", err)
		}
		delete(object, "dnaiNwInstanceList")
	}

	if raw, found := object["dnn"]; found {
		err = json.Unmarshal(raw, &a.Dnn)
		if err != nil {
			return fmt.Errorf("error reading 'dnn': %w", err)
		}
		delete(object, "dnn")
	}

	if raw, found := object["ipv4AddressRanges"]; found {
		err = json.Unmarshal(raw, &a.Ipv4AddressRanges)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4AddressRanges': %w", err)
		}
		delete(object, "ipv4AddressRanges")
	}

	if raw, found := object["ipv6PrefixRanges"]; found {
		err = json.Unmarshal(raw, &a.Ipv6PrefixRanges)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6PrefixRanges': %w", err)
		}
		delete(object, "ipv6PrefixRanges")
	}

	if raw, found := object["pduSessionTypes"]; found {
		err = json.Unmarshal(raw, &a.PduSessionTypes)
		if err != nil {
			return fmt.Errorf("error reading 'pduSessionTypes': %w", err)
		}
		delete(object, "pduSessionTypes")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DnnUpfInfoItem to handle AdditionalProperties
func (a DnnUpfInfoItem) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.DnaiList) != 0 {
		object["dnaiList"], err = json.Marshal(a.DnaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dnaiList': %w", err)
		}
	}

	if a.DnaiNwInstanceList != nil {
		object["dnaiNwInstanceList"], err = json.Marshal(a.DnaiNwInstanceList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dnaiNwInstanceList': %w", err)
		}
	}

	object["dnn"], err = json.Marshal(a.Dnn)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'dnn': %w", err)
	}

	if len(a.Ipv4AddressRanges) != 0 {
		object["ipv4AddressRanges"], err = json.Marshal(a.Ipv4AddressRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4AddressRanges': %w", err)
		}
	}

	if len(a.Ipv6PrefixRanges) != 0 {
		object["ipv6PrefixRanges"], err = json.Marshal(a.Ipv6PrefixRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6PrefixRanges': %w", err)
		}
	}

	if len(a.PduSessionTypes) != 0 {
		object["pduSessionTypes"], err = json.Marshal(a.PduSessionTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pduSessionTypes': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GmlcInfo. Returns the specified
// element and whether it was found
func (a GmlcInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GmlcInfo
func (a *GmlcInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GmlcInfo to handle AdditionalProperties
func (a *GmlcInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["gmlcNumbers"]; found {
		err = json.Unmarshal(raw, &a.GmlcNumbers)
		if err != nil {
			return fmt.Errorf("error reading 'gmlcNumbers': %w", err)
		}
		delete(object, "gmlcNumbers")
	}

	if raw, found := object["servingClientTypes"]; found {
		err = json.Unmarshal(raw, &a.ServingClientTypes)
		if err != nil {
			return fmt.Errorf("error reading 'servingClientTypes': %w", err)
		}
		delete(object, "servingClientTypes")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GmlcInfo to handle AdditionalProperties
func (a GmlcInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.GmlcNumbers) != 0 {
		object["gmlcNumbers"], err = json.Marshal(a.GmlcNumbers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gmlcNumbers': %w", err)
		}
	}

	if len(a.ServingClientTypes) != 0 {
		object["servingClientTypes"], err = json.Marshal(a.ServingClientTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingClientTypes': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GuamiListCond. Returns the specified
// element and whether it was found
func (a GuamiListCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GuamiListCond
func (a *GuamiListCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GuamiListCond to handle AdditionalProperties
func (a *GuamiListCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["guamiList"]; found {
		err = json.Unmarshal(raw, &a.GuamiList)
		if err != nil {
			return fmt.Errorf("error reading 'guamiList': %w", err)
		}
		delete(object, "guamiList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GuamiListCond to handle AdditionalProperties
func (a GuamiListCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["guamiList"], err = json.Marshal(a.GuamiList)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'guamiList': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for HssInfo. Returns the specified
// element and whether it was found
func (a HssInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HssInfo
func (a *HssInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HssInfo to handle AdditionalProperties
func (a *HssInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["groupId"]; found {
		err = json.Unmarshal(raw, &a.GroupId)
		if err != nil {
			return fmt.Errorf("error reading 'groupId': %w", err)
		}
		delete(object, "groupId")
	}

	if raw, found := object["imsPrivateIdentityRanges"]; found {
		err = json.Unmarshal(raw, &a.ImsPrivateIdentityRanges)
		if err != nil {
			return fmt.Errorf("error reading 'imsPrivateIdentityRanges': %w", err)
		}
		delete(object, "imsPrivateIdentityRanges")
	}

	if raw, found := object["imsPublicIdentityRanges"]; found {
		err = json.Unmarshal(raw, &a.ImsPublicIdentityRanges)
		if err != nil {
			return fmt.Errorf("error reading 'imsPublicIdentityRanges': %w", err)
		}
		delete(object, "imsPublicIdentityRanges")
	}

	if raw, found := object["imsiRanges"]; found {
		err = json.Unmarshal(raw, &a.ImsiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'imsiRanges': %w", err)
		}
		delete(object, "imsiRanges")
	}

	if raw, found := object["msisdnRanges"]; found {
		err = json.Unmarshal(raw, &a.MsisdnRanges)
		if err != nil {
			return fmt.Errorf("error reading 'msisdnRanges': %w", err)
		}
		delete(object, "msisdnRanges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HssInfo to handle AdditionalProperties
func (a HssInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.GroupId != nil {
		object["groupId"], err = json.Marshal(a.GroupId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupId': %w", err)
		}
	}

	if len(a.ImsPrivateIdentityRanges) != 0 {
		object["imsPrivateIdentityRanges"], err = json.Marshal(a.ImsPrivateIdentityRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'imsPrivateIdentityRanges': %w", err)
		}
	}

	if len(a.ImsPublicIdentityRanges) != 0 {
		object["imsPublicIdentityRanges"], err = json.Marshal(a.ImsPublicIdentityRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'imsPublicIdentityRanges': %w", err)
		}
	}

	if len(a.ImsiRanges) != 0 {
		object["imsiRanges"], err = json.Marshal(a.ImsiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'imsiRanges': %w", err)
		}
	}

	if len(a.MsisdnRanges) != 0 {
		object["msisdnRanges"], err = json.Marshal(a.MsisdnRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'msisdnRanges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IdentityRange. Returns the specified
// element and whether it was found
func (a IdentityRange) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IdentityRange
func (a *IdentityRange) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IdentityRange to handle AdditionalProperties
func (a *IdentityRange) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["end"]; found {
		err = json.Unmarshal(raw, &a.End)
		if err != nil {
			return fmt.Errorf("error reading 'end': %w", err)
		}
		delete(object, "end")
	}

	if raw, found := object["pattern"]; found {
		err = json.Unmarshal(raw, &a.Pattern)
		if err != nil {
			return fmt.Errorf("error reading 'pattern': %w", err)
		}
		delete(object, "pattern")
	}

	if raw, found := object["start"]; found {
		err = json.Unmarshal(raw, &a.Start)
		if err != nil {
			return fmt.Errorf("error reading 'start': %w", err)
		}
		delete(object, "start")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IdentityRange to handle AdditionalProperties
func (a IdentityRange) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.End) != 0 {
		object["end"], err = json.Marshal(a.End)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'end': %w", err)
		}
	}

	if a.Pattern != nil {
		object["pattern"], err = json.Marshal(a.Pattern)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pattern': %w", err)
		}
	}

	if len(a.Start) != 0 {
		object["start"], err = json.Marshal(a.Start)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ImsiRange. Returns the specified
// element and whether it was found
func (a ImsiRange) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ImsiRange
func (a *ImsiRange) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ImsiRange to handle AdditionalProperties
func (a *ImsiRange) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["end"]; found {
		err = json.Unmarshal(raw, &a.End)
		if err != nil {
			return fmt.Errorf("error reading 'end': %w", err)
		}
		delete(object, "end")
	}

	if raw, found := object["pattern"]; found {
		err = json.Unmarshal(raw, &a.Pattern)
		if err != nil {
			return fmt.Errorf("error reading 'pattern': %w", err)
		}
		delete(object, "pattern")
	}

	if raw, found := object["start"]; found {
		err = json.Unmarshal(raw, &a.Start)
		if err != nil {
			return fmt.Errorf("error reading 'start': %w", err)
		}
		delete(object, "start")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ImsiRange to handle AdditionalProperties
func (a ImsiRange) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.End) != 0 {
		object["end"], err = json.Marshal(a.End)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'end': %w", err)
		}
	}

	if a.Pattern != nil {
		object["pattern"], err = json.Marshal(a.Pattern)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pattern': %w", err)
		}
	}

	if len(a.Start) != 0 {
		object["start"], err = json.Marshal(a.Start)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for InterfaceUpfInfoItem. Returns the specified
// element and whether it was found
func (a InterfaceUpfInfoItem) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for InterfaceUpfInfoItem
func (a *InterfaceUpfInfoItem) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for InterfaceUpfInfoItem to handle AdditionalProperties
func (a *InterfaceUpfInfoItem) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["endpointFqdn"]; found {
		err = json.Unmarshal(raw, &a.EndpointFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'endpointFqdn': %w", err)
		}
		delete(object, "endpointFqdn")
	}

	if raw, found := object["interfaceType"]; found {
		err = json.Unmarshal(raw, &a.InterfaceType)
		if err != nil {
			return fmt.Errorf("error reading 'interfaceType': %w", err)
		}
		delete(object, "interfaceType")
	}

	if raw, found := object["ipv4EndpointAddresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv4EndpointAddresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4EndpointAddresses': %w", err)
		}
		delete(object, "ipv4EndpointAddresses")
	}

	if raw, found := object["ipv6EndpointAddresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv6EndpointAddresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6EndpointAddresses': %w", err)
		}
		delete(object, "ipv6EndpointAddresses")
	}

	if raw, found := object["networkInstance"]; found {
		err = json.Unmarshal(raw, &a.NetworkInstance)
		if err != nil {
			return fmt.Errorf("error reading 'networkInstance': %w", err)
		}
		delete(object, "networkInstance")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for InterfaceUpfInfoItem to handle AdditionalProperties
func (a InterfaceUpfInfoItem) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.EndpointFqdn != nil {
		object["endpointFqdn"], err = json.Marshal(a.EndpointFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'endpointFqdn': %w", err)
		}
	}

	object["interfaceType"], err = json.Marshal(a.InterfaceType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'interfaceType': %w", err)
	}

	if len(a.Ipv4EndpointAddresses) != 0 {
		object["ipv4EndpointAddresses"], err = json.Marshal(a.Ipv4EndpointAddresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4EndpointAddresses': %w", err)
		}
	}

	if len(a.Ipv6EndpointAddresses) != 0 {
		object["ipv6EndpointAddresses"], err = json.Marshal(a.Ipv6EndpointAddresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6EndpointAddresses': %w", err)
		}
	}

	if a.NetworkInstance != nil {
		object["networkInstance"], err = json.Marshal(a.NetworkInstance)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'networkInstance': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for InternalGroupIdRange. Returns the specified
// element and whether it was found
func (a InternalGroupIdRange) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for InternalGroupIdRange
func (a *InternalGroupIdRange) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for InternalGroupIdRange to handle AdditionalProperties
func (a *InternalGroupIdRange) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["end"]; found {
		err = json.Unmarshal(raw, &a.End)
		if err != nil {
			return fmt.Errorf("error reading 'end': %w", err)
		}
		delete(object, "end")
	}

	if raw, found := object["pattern"]; found {
		err = json.Unmarshal(raw, &a.Pattern)
		if err != nil {
			return fmt.Errorf("error reading 'pattern': %w", err)
		}
		delete(object, "pattern")
	}

	if raw, found := object["start"]; found {
		err = json.Unmarshal(raw, &a.Start)
		if err != nil {
			return fmt.Errorf("error reading 'start': %w", err)
		}
		delete(object, "start")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for InternalGroupIdRange to handle AdditionalProperties
func (a InternalGroupIdRange) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.End) != 0 {
		object["end"], err = json.Marshal(a.End)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'end': %w", err)
		}
	}

	if a.Pattern != nil {
		object["pattern"], err = json.Marshal(a.Pattern)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pattern': %w", err)
		}
	}

	if len(a.Start) != 0 {
		object["start"], err = json.Marshal(a.Start)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IpEndPoint. Returns the specified
// element and whether it was found
func (a IpEndPoint) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IpEndPoint
func (a *IpEndPoint) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IpEndPoint to handle AdditionalProperties
func (a *IpEndPoint) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ipv4Address"]; found {
		err = json.Unmarshal(raw, &a.Ipv4Address)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4Address': %w", err)
		}
		delete(object, "ipv4Address")
	}

	if raw, found := object["ipv6Address"]; found {
		err = json.Unmarshal(raw, &a.Ipv6Address)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6Address': %w", err)
		}
		delete(object, "ipv6Address")
	}

	if raw, found := object["port"]; found {
		err = json.Unmarshal(raw, &a.Port)
		if err != nil {
			return fmt.Errorf("error reading 'port': %w", err)
		}
		delete(object, "port")
	}

	if raw, found := object["transport"]; found {
		err = json.Unmarshal(raw, &a.Transport)
		if err != nil {
			return fmt.Errorf("error reading 'transport': %w", err)
		}
		delete(object, "transport")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IpEndPoint to handle AdditionalProperties
func (a IpEndPoint) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.Ipv4Address) != 0 {
		object["ipv4Address"], err = json.Marshal(a.Ipv4Address)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4Address': %w", err)
		}
	}

	if a.Ipv6Address != nil {
		object["ipv6Address"], err = json.Marshal(a.Ipv6Address)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6Address': %w", err)
		}
	}

	if a.Port != nil {
		object["port"], err = json.Marshal(a.Port)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'port': %w", err)
		}
	}

	if a.Transport != nil {
		object["transport"], err = json.Marshal(a.Transport)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'transport': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Ipv4AddressRange. Returns the specified
// element and whether it was found
func (a Ipv4AddressRange) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Ipv4AddressRange
func (a *Ipv4AddressRange) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Ipv4AddressRange to handle AdditionalProperties
func (a *Ipv4AddressRange) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["end"]; found {
		err = json.Unmarshal(raw, &a.End)
		if err != nil {
			return fmt.Errorf("error reading 'end': %w", err)
		}
		delete(object, "end")
	}

	if raw, found := object["start"]; found {
		err = json.Unmarshal(raw, &a.Start)
		if err != nil {
			return fmt.Errorf("error reading 'start': %w", err)
		}
		delete(object, "start")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Ipv4AddressRange to handle AdditionalProperties
func (a Ipv4AddressRange) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.End) != 0 {
		object["end"], err = json.Marshal(a.End)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'end': %w", err)
		}
	}

	if len(a.Start) != 0 {
		object["start"], err = json.Marshal(a.Start)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Ipv6PrefixRange. Returns the specified
// element and whether it was found
func (a Ipv6PrefixRange) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Ipv6PrefixRange
func (a *Ipv6PrefixRange) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Ipv6PrefixRange to handle AdditionalProperties
func (a *Ipv6PrefixRange) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["end"]; found {
		err = json.Unmarshal(raw, &a.End)
		if err != nil {
			return fmt.Errorf("error reading 'end': %w", err)
		}
		delete(object, "end")
	}

	if raw, found := object["start"]; found {
		err = json.Unmarshal(raw, &a.Start)
		if err != nil {
			return fmt.Errorf("error reading 'start': %w", err)
		}
		delete(object, "start")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Ipv6PrefixRange to handle AdditionalProperties
func (a Ipv6PrefixRange) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.End != nil {
		object["end"], err = json.Marshal(a.End)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'end': %w", err)
		}
	}

	if a.Start != nil {
		object["start"], err = json.Marshal(a.Start)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for LmfInfo. Returns the specified
// element and whether it was found
func (a LmfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for LmfInfo
func (a *LmfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for LmfInfo to handle AdditionalProperties
func (a *LmfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["lmfId"]; found {
		err = json.Unmarshal(raw, &a.LmfId)
		if err != nil {
			return fmt.Errorf("error reading 'lmfId': %w", err)
		}
		delete(object, "lmfId")
	}

	if raw, found := object["servingAccessTypes"]; found {
		err = json.Unmarshal(raw, &a.ServingAccessTypes)
		if err != nil {
			return fmt.Errorf("error reading 'servingAccessTypes': %w", err)
		}
		delete(object, "servingAccessTypes")
	}

	if raw, found := object["servingAnNodeTypes"]; found {
		err = json.Unmarshal(raw, &a.ServingAnNodeTypes)
		if err != nil {
			return fmt.Errorf("error reading 'servingAnNodeTypes': %w", err)
		}
		delete(object, "servingAnNodeTypes")
	}

	if raw, found := object["servingClientTypes"]; found {
		err = json.Unmarshal(raw, &a.ServingClientTypes)
		if err != nil {
			return fmt.Errorf("error reading 'servingClientTypes': %w", err)
		}
		delete(object, "servingClientTypes")
	}

	if raw, found := object["servingRatTypes"]; found {
		err = json.Unmarshal(raw, &a.ServingRatTypes)
		if err != nil {
			return fmt.Errorf("error reading 'servingRatTypes': %w", err)
		}
		delete(object, "servingRatTypes")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for LmfInfo to handle AdditionalProperties
func (a LmfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.LmfId != nil {
		object["lmfId"], err = json.Marshal(a.LmfId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lmfId': %w", err)
		}
	}

	if len(a.ServingAccessTypes) != 0 {
		object["servingAccessTypes"], err = json.Marshal(a.ServingAccessTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingAccessTypes': %w", err)
		}
	}

	if len(a.ServingAnNodeTypes) != 0 {
		object["servingAnNodeTypes"], err = json.Marshal(a.ServingAnNodeTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingAnNodeTypes': %w", err)
		}
	}

	if len(a.ServingClientTypes) != 0 {
		object["servingClientTypes"], err = json.Marshal(a.ServingClientTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingClientTypes': %w", err)
		}
	}

	if len(a.ServingRatTypes) != 0 {
		object["servingRatTypes"], err = json.Marshal(a.ServingRatTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingRatTypes': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for N2InterfaceAmfInfo. Returns the specified
// element and whether it was found
func (a N2InterfaceAmfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for N2InterfaceAmfInfo
func (a *N2InterfaceAmfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for N2InterfaceAmfInfo to handle AdditionalProperties
func (a *N2InterfaceAmfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["amfName"]; found {
		err = json.Unmarshal(raw, &a.AmfName)
		if err != nil {
			return fmt.Errorf("error reading 'amfName': %w", err)
		}
		delete(object, "amfName")
	}

	if raw, found := object["ipv4EndpointAddress"]; found {
		err = json.Unmarshal(raw, &a.Ipv4EndpointAddress)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4EndpointAddress': %w", err)
		}
		delete(object, "ipv4EndpointAddress")
	}

	if raw, found := object["ipv6EndpointAddress"]; found {
		err = json.Unmarshal(raw, &a.Ipv6EndpointAddress)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6EndpointAddress': %w", err)
		}
		delete(object, "ipv6EndpointAddress")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for N2InterfaceAmfInfo to handle AdditionalProperties
func (a N2InterfaceAmfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AmfName != nil {
		object["amfName"], err = json.Marshal(a.AmfName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'amfName': %w", err)
		}
	}

	if len(a.Ipv4EndpointAddress) != 0 {
		object["ipv4EndpointAddress"], err = json.Marshal(a.Ipv4EndpointAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4EndpointAddress': %w", err)
		}
	}

	if len(a.Ipv6EndpointAddress) != 0 {
		object["ipv6EndpointAddress"], err = json.Marshal(a.Ipv6EndpointAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6EndpointAddress': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NFProfile. Returns the specified
// element and whether it was found
func (a NFProfile) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NFProfile
func (a *NFProfile) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NFProfile to handle AdditionalProperties
func (a *NFProfile) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allowedNfDomains"]; found {
		err = json.Unmarshal(raw, &a.AllowedNfDomains)
		if err != nil {
			return fmt.Errorf("error reading 'allowedNfDomains': %w", err)
		}
		delete(object, "allowedNfDomains")
	}

	if raw, found := object["allowedNfTypes"]; found {
		err = json.Unmarshal(raw, &a.AllowedNfTypes)
		if err != nil {
			return fmt.Errorf("error reading 'allowedNfTypes': %w", err)
		}
		delete(object, "allowedNfTypes")
	}

	if raw, found := object["allowedNssais"]; found {
		err = json.Unmarshal(raw, &a.AllowedNssais)
		if err != nil {
			return fmt.Errorf("error reading 'allowedNssais': %w", err)
		}
		delete(object, "allowedNssais")
	}

	if raw, found := object["allowedPlmns"]; found {
		err = json.Unmarshal(raw, &a.AllowedPlmns)
		if err != nil {
			return fmt.Errorf("error reading 'allowedPlmns': %w", err)
		}
		delete(object, "allowedPlmns")
	}

	if raw, found := object["allowedSnpns"]; found {
		err = json.Unmarshal(raw, &a.AllowedSnpns)
		if err != nil {
			return fmt.Errorf("error reading 'allowedSnpns': %w", err)
		}
		delete(object, "allowedSnpns")
	}

	if raw, found := object["amfInfo"]; found {
		err = json.Unmarshal(raw, &a.AmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'amfInfo': %w", err)
		}
		delete(object, "amfInfo")
	}

	if raw, found := object["amfInfoList"]; found {
		err = json.Unmarshal(raw, &a.AmfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'amfInfoList': %w", err)
		}
		delete(object, "amfInfoList")
	}

	if raw, found := object["ausfInfo"]; found {
		err = json.Unmarshal(raw, &a.AusfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'ausfInfo': %w", err)
		}
		delete(object, "ausfInfo")
	}

	if raw, found := object["ausfInfoList"]; found {
		err = json.Unmarshal(raw, &a.AusfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'ausfInfoList': %w", err)
		}
		delete(object, "ausfInfoList")
	}

	if raw, found := object["bsfInfo"]; found {
		err = json.Unmarshal(raw, &a.BsfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'bsfInfo': %w", err)
		}
		delete(object, "bsfInfo")
	}

	if raw, found := object["bsfInfoList"]; found {
		err = json.Unmarshal(raw, &a.BsfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'bsfInfoList': %w", err)
		}
		delete(object, "bsfInfoList")
	}

	if raw, found := object["capacity"]; found {
		err = json.Unmarshal(raw, &a.Capacity)
		if err != nil {
			return fmt.Errorf("error reading 'capacity': %w", err)
		}
		delete(object, "capacity")
	}

	if raw, found := object["chfInfo"]; found {
		err = json.Unmarshal(raw, &a.ChfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'chfInfo': %w", err)
		}
		delete(object, "chfInfo")
	}

	if raw, found := object["chfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ChfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'chfInfoList': %w", err)
		}
		delete(object, "chfInfoList")
	}

	if raw, found := object["customInfo"]; found {
		err = json.Unmarshal(raw, &a.CustomInfo)
		if err != nil {
			return fmt.Errorf("error reading 'customInfo': %w", err)
		}
		delete(object, "customInfo")
	}

	if raw, found := object["defaultNotificationSubscriptions"]; found {
		err = json.Unmarshal(raw, &a.DefaultNotificationSubscriptions)
		if err != nil {
			return fmt.Errorf("error reading 'defaultNotificationSubscriptions': %w", err)
		}
		delete(object, "defaultNotificationSubscriptions")
	}

	if raw, found := object["fqdn"]; found {
		err = json.Unmarshal(raw, &a.Fqdn)
		if err != nil {
			return fmt.Errorf("error reading 'fqdn': %w", err)
		}
		delete(object, "fqdn")
	}

	if raw, found := object["gmlcInfo"]; found {
		err = json.Unmarshal(raw, &a.GmlcInfo)
		if err != nil {
			return fmt.Errorf("error reading 'gmlcInfo': %w", err)
		}
		delete(object, "gmlcInfo")
	}

	if raw, found := object["heartBeatTimer"]; found {
		err = json.Unmarshal(raw, &a.HeartBeatTimer)
		if err != nil {
			return fmt.Errorf("error reading 'heartBeatTimer': %w", err)
		}
		delete(object, "heartBeatTimer")
	}

	if raw, found := object["hssInfoList"]; found {
		err = json.Unmarshal(raw, &a.HssInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'hssInfoList': %w", err)
		}
		delete(object, "hssInfoList")
	}

	if raw, found := object["interPlmnFqdn"]; found {
		err = json.Unmarshal(raw, &a.InterPlmnFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'interPlmnFqdn': %w", err)
		}
		delete(object, "interPlmnFqdn")
	}

	if raw, found := object["ipv4Addresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv4Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4Addresses': %w", err)
		}
		delete(object, "ipv4Addresses")
	}

	if raw, found := object["ipv6Addresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv6Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6Addresses': %w", err)
		}
		delete(object, "ipv6Addresses")
	}

	if raw, found := object["lcHSupportInd"]; found {
		err = json.Unmarshal(raw, &a.LcHSupportInd)
		if err != nil {
			return fmt.Errorf("error reading 'lcHSupportInd': %w", err)
		}
		delete(object, "lcHSupportInd")
	}

	if raw, found := object["lmfInfo"]; found {
		err = json.Unmarshal(raw, &a.LmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'lmfInfo': %w", err)
		}
		delete(object, "lmfInfo")
	}

	if raw, found := object["load"]; found {
		err = json.Unmarshal(raw, &a.Load)
		if err != nil {
			return fmt.Errorf("error reading 'load': %w", err)
		}
		delete(object, "load")
	}

	if raw, found := object["loadTimeStamp"]; found {
		err = json.Unmarshal(raw, &a.LoadTimeStamp)
		if err != nil {
			return fmt.Errorf("error reading 'loadTimeStamp': %w", err)
		}
		delete(object, "loadTimeStamp")
	}

	if raw, found := object["locality"]; found {
		err = json.Unmarshal(raw, &a.Locality)
		if err != nil {
			return fmt.Errorf("error reading 'locality': %w", err)
		}
		delete(object, "locality")
	}

	if raw, found := object["nefInfo"]; found {
		err = json.Unmarshal(raw, &a.NefInfo)
		if err != nil {
			return fmt.Errorf("error reading 'nefInfo': %w", err)
		}
		delete(object, "nefInfo")
	}

	if raw, found := object["nfInstanceId"]; found {
		err = json.Unmarshal(raw, &a.NfInstanceId)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstanceId': %w", err)
		}
		delete(object, "nfInstanceId")
	}

	if raw, found := object["nfInstanceName"]; found {
		err = json.Unmarshal(raw, &a.NfInstanceName)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstanceName': %w", err)
		}
		delete(object, "nfInstanceName")
	}

	if raw, found := object["nfProfileChangesInd"]; found {
		err = json.Unmarshal(raw, &a.NfProfileChangesInd)
		if err != nil {
			return fmt.Errorf("error reading 'nfProfileChangesInd': %w", err)
		}
		delete(object, "nfProfileChangesInd")
	}

	if raw, found := object["nfProfileChangesSupportInd"]; found {
		err = json.Unmarshal(raw, &a.NfProfileChangesSupportInd)
		if err != nil {
			return fmt.Errorf("error reading 'nfProfileChangesSupportInd': %w", err)
		}
		delete(object, "nfProfileChangesSupportInd")
	}

	if raw, found := object["nfServiceList"]; found {
		err = json.Unmarshal(raw, &a.NfServiceList)
		if err != nil {
			return fmt.Errorf("error reading 'nfServiceList': %w", err)
		}
		delete(object, "nfServiceList")
	}

	if raw, found := object["nfServicePersistence"]; found {
		err = json.Unmarshal(raw, &a.NfServicePersistence)
		if err != nil {
			return fmt.Errorf("error reading 'nfServicePersistence': %w", err)
		}
		delete(object, "nfServicePersistence")
	}

	if raw, found := object["nfServices"]; found {
		err = json.Unmarshal(raw, &a.NfServices)
		if err != nil {
			return fmt.Errorf("error reading 'nfServices': %w", err)
		}
		delete(object, "nfServices")
	}

	if raw, found := object["nfSetIdList"]; found {
		err = json.Unmarshal(raw, &a.NfSetIdList)
		if err != nil {
			return fmt.Errorf("error reading 'nfSetIdList': %w", err)
		}
		delete(object, "nfSetIdList")
	}

	if raw, found := object["nfSetRecoveryTimeList"]; found {
		err = json.Unmarshal(raw, &a.NfSetRecoveryTimeList)
		if err != nil {
			return fmt.Errorf("error reading 'nfSetRecoveryTimeList': %w", err)
		}
		delete(object, "nfSetRecoveryTimeList")
	}

	if raw, found := object["nfStatus"]; found {
		err = json.Unmarshal(raw, &a.NfStatus)
		if err != nil {
			return fmt.Errorf("error reading 'nfStatus': %w", err)
		}
		delete(object, "nfStatus")
	}

	if raw, found := object["nfType"]; found {
		err = json.Unmarshal(raw, &a.NfType)
		if err != nil {
			return fmt.Errorf("error reading 'nfType': %w", err)
		}
		delete(object, "nfType")
	}

	if raw, found := object["nrfInfo"]; found {
		err = json.Unmarshal(raw, &a.NrfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'nrfInfo': %w", err)
		}
		delete(object, "nrfInfo")
	}

	if raw, found := object["nsiList"]; found {
		err = json.Unmarshal(raw, &a.NsiList)
		if err != nil {
			return fmt.Errorf("error reading 'nsiList': %w", err)
		}
		delete(object, "nsiList")
	}

	if raw, found := object["nwdafInfo"]; found {
		err = json.Unmarshal(raw, &a.NwdafInfo)
		if err != nil {
			return fmt.Errorf("error reading 'nwdafInfo': %w", err)
		}
		delete(object, "nwdafInfo")
	}

	if raw, found := object["olcHSupportInd"]; found {
		err = json.Unmarshal(raw, &a.OlcHSupportInd)
		if err != nil {
			return fmt.Errorf("error reading 'olcHSupportInd': %w", err)
		}
		delete(object, "olcHSupportInd")
	}

	if raw, found := object["pcfInfo"]; found {
		err = json.Unmarshal(raw, &a.PcfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'pcfInfo': %w", err)
		}
		delete(object, "pcfInfo")
	}

	if raw, found := object["pcfInfoList"]; found {
		err = json.Unmarshal(raw, &a.PcfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'pcfInfoList': %w", err)
		}
		delete(object, "pcfInfoList")
	}

	if raw, found := object["pcscfInfoList"]; found {
		err = json.Unmarshal(raw, &a.PcscfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'pcscfInfoList': %w", err)
		}
		delete(object, "pcscfInfoList")
	}

	if raw, found := object["perPlmnSnssaiList"]; found {
		err = json.Unmarshal(raw, &a.PerPlmnSnssaiList)
		if err != nil {
			return fmt.Errorf("error reading 'perPlmnSnssaiList': %w", err)
		}
		delete(object, "perPlmnSnssaiList")
	}

	if raw, found := object["plmnList"]; found {
		err = json.Unmarshal(raw, &a.PlmnList)
		if err != nil {
			return fmt.Errorf("error reading 'plmnList': %w", err)
		}
		delete(object, "plmnList")
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &a.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
		delete(object, "priority")
	}

	if raw, found := object["recoveryTime"]; found {
		err = json.Unmarshal(raw, &a.RecoveryTime)
		if err != nil {
			return fmt.Errorf("error reading 'recoveryTime': %w", err)
		}
		delete(object, "recoveryTime")
	}

	if raw, found := object["sNssais"]; found {
		err = json.Unmarshal(raw, &a.SNssais)
		if err != nil {
			return fmt.Errorf("error reading 'sNssais': %w", err)
		}
		delete(object, "sNssais")
	}

	if raw, found := object["scpDomains"]; found {
		err = json.Unmarshal(raw, &a.ScpDomains)
		if err != nil {
			return fmt.Errorf("error reading 'scpDomains': %w", err)
		}
		delete(object, "scpDomains")
	}

	if raw, found := object["scpInfo"]; found {
		err = json.Unmarshal(raw, &a.ScpInfo)
		if err != nil {
			return fmt.Errorf("error reading 'scpInfo': %w", err)
		}
		delete(object, "scpInfo")
	}

	if raw, found := object["serviceSetRecoveryTimeList"]; found {
		err = json.Unmarshal(raw, &a.ServiceSetRecoveryTimeList)
		if err != nil {
			return fmt.Errorf("error reading 'serviceSetRecoveryTimeList': %w", err)
		}
		delete(object, "serviceSetRecoveryTimeList")
	}

	if raw, found := object["servingScope"]; found {
		err = json.Unmarshal(raw, &a.ServingScope)
		if err != nil {
			return fmt.Errorf("error reading 'servingScope': %w", err)
		}
		delete(object, "servingScope")
	}

	if raw, found := object["smfInfo"]; found {
		err = json.Unmarshal(raw, &a.SmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'smfInfo': %w", err)
		}
		delete(object, "smfInfo")
	}

	if raw, found := object["smfInfoList"]; found {
		err = json.Unmarshal(raw, &a.SmfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'smfInfoList': %w", err)
		}
		delete(object, "smfInfoList")
	}

	if raw, found := object["snpnList"]; found {
		err = json.Unmarshal(raw, &a.SnpnList)
		if err != nil {
			return fmt.Errorf("error reading 'snpnList': %w", err)
		}
		delete(object, "snpnList")
	}

	if raw, found := object["udmInfo"]; found {
		err = json.Unmarshal(raw, &a.UdmInfo)
		if err != nil {
			return fmt.Errorf("error reading 'udmInfo': %w", err)
		}
		delete(object, "udmInfo")
	}

	if raw, found := object["udmInfoList"]; found {
		err = json.Unmarshal(raw, &a.UdmInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'udmInfoList': %w", err)
		}
		delete(object, "udmInfoList")
	}

	if raw, found := object["udrInfo"]; found {
		err = json.Unmarshal(raw, &a.UdrInfo)
		if err != nil {
			return fmt.Errorf("error reading 'udrInfo': %w", err)
		}
		delete(object, "udrInfo")
	}

	if raw, found := object["udrInfoList"]; found {
		err = json.Unmarshal(raw, &a.UdrInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'udrInfoList': %w", err)
		}
		delete(object, "udrInfoList")
	}

	if raw, found := object["udsfInfo"]; found {
		err = json.Unmarshal(raw, &a.UdsfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'udsfInfo': %w", err)
		}
		delete(object, "udsfInfo")
	}

	if raw, found := object["udsfInfoList"]; found {
		err = json.Unmarshal(raw, &a.UdsfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'udsfInfoList': %w", err)
		}
		delete(object, "udsfInfoList")
	}

	if raw, found := object["upfInfo"]; found {
		err = json.Unmarshal(raw, &a.UpfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'upfInfo': %w", err)
		}
		delete(object, "upfInfo")
	}

	if raw, found := object["upfInfoList"]; found {
		err = json.Unmarshal(raw, &a.UpfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'upfInfoList': %w", err)
		}
		delete(object, "upfInfoList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NFProfile to handle AdditionalProperties
func (a NFProfile) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AllowedNfDomains) != 0 {
		object["allowedNfDomains"], err = json.Marshal(a.AllowedNfDomains)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedNfDomains': %w", err)
		}
	}

	if len(a.AllowedNfTypes) != 0 {
		object["allowedNfTypes"], err = json.Marshal(a.AllowedNfTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedNfTypes': %w", err)
		}
	}

	if len(a.AllowedNssais) != 0 {
		object["allowedNssais"], err = json.Marshal(a.AllowedNssais)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedNssais': %w", err)
		}
	}

	if len(a.AllowedPlmns) != 0 {
		object["allowedPlmns"], err = json.Marshal(a.AllowedPlmns)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedPlmns': %w", err)
		}
	}

	if len(a.AllowedSnpns) != 0 {
		object["allowedSnpns"], err = json.Marshal(a.AllowedSnpns)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedSnpns': %w", err)
		}
	}

	if a.AmfInfo != nil {
		object["amfInfo"], err = json.Marshal(a.AmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'amfInfo': %w", err)
		}
	}

	if a.AmfInfoList != nil {
		object["amfInfoList"], err = json.Marshal(a.AmfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'amfInfoList': %w", err)
		}
	}

	if a.AusfInfo != nil {
		object["ausfInfo"], err = json.Marshal(a.AusfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ausfInfo': %w", err)
		}
	}

	if a.AusfInfoList != nil {
		object["ausfInfoList"], err = json.Marshal(a.AusfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ausfInfoList': %w", err)
		}
	}

	if a.BsfInfo != nil {
		object["bsfInfo"], err = json.Marshal(a.BsfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bsfInfo': %w", err)
		}
	}

	if a.BsfInfoList != nil {
		object["bsfInfoList"], err = json.Marshal(a.BsfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bsfInfoList': %w", err)
		}
	}

	if a.Capacity != nil {
		object["capacity"], err = json.Marshal(a.Capacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capacity': %w", err)
		}
	}

	if a.ChfInfo != nil {
		object["chfInfo"], err = json.Marshal(a.ChfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'chfInfo': %w", err)
		}
	}

	if a.ChfInfoList != nil {
		object["chfInfoList"], err = json.Marshal(a.ChfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'chfInfoList': %w", err)
		}
	}

	if a.CustomInfo != nil {
		object["customInfo"], err = json.Marshal(a.CustomInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'customInfo': %w", err)
		}
	}

	if a.DefaultNotificationSubscriptions != nil {
		object["defaultNotificationSubscriptions"], err = json.Marshal(a.DefaultNotificationSubscriptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'defaultNotificationSubscriptions': %w", err)
		}
	}

	if a.Fqdn != nil {
		object["fqdn"], err = json.Marshal(a.Fqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fqdn': %w", err)
		}
	}

	if a.GmlcInfo != nil {
		object["gmlcInfo"], err = json.Marshal(a.GmlcInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gmlcInfo': %w", err)
		}
	}

	if a.HeartBeatTimer != nil {
		object["heartBeatTimer"], err = json.Marshal(a.HeartBeatTimer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'heartBeatTimer': %w", err)
		}
	}

	if a.HssInfoList != nil {
		object["hssInfoList"], err = json.Marshal(a.HssInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hssInfoList': %w", err)
		}
	}

	if a.InterPlmnFqdn != nil {
		object["interPlmnFqdn"], err = json.Marshal(a.InterPlmnFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'interPlmnFqdn': %w", err)
		}
	}

	if len(a.Ipv4Addresses) != 0 {
		object["ipv4Addresses"], err = json.Marshal(a.Ipv4Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4Addresses': %w", err)
		}
	}

	if len(a.Ipv6Addresses) != 0 {
		object["ipv6Addresses"], err = json.Marshal(a.Ipv6Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6Addresses': %w", err)
		}
	}

	if a.LcHSupportInd != nil {
		object["lcHSupportInd"], err = json.Marshal(a.LcHSupportInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lcHSupportInd': %w", err)
		}
	}

	if a.LmfInfo != nil {
		object["lmfInfo"], err = json.Marshal(a.LmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lmfInfo': %w", err)
		}
	}

	if a.Load != nil {
		object["load"], err = json.Marshal(a.Load)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'load': %w", err)
		}
	}

	if a.LoadTimeStamp != nil {
		object["loadTimeStamp"], err = json.Marshal(a.LoadTimeStamp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'loadTimeStamp': %w", err)
		}
	}

	if a.Locality != nil {
		object["locality"], err = json.Marshal(a.Locality)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'locality': %w", err)
		}
	}

	if a.NefInfo != nil {
		object["nefInfo"], err = json.Marshal(a.NefInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nefInfo': %w", err)
		}
	}

	object["nfInstanceId"], err = json.Marshal(a.NfInstanceId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfInstanceId': %w", err)
	}

	if a.NfInstanceName != nil {
		object["nfInstanceName"], err = json.Marshal(a.NfInstanceName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfInstanceName': %w", err)
		}
	}

	if a.NfProfileChangesInd != nil {
		object["nfProfileChangesInd"], err = json.Marshal(a.NfProfileChangesInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfProfileChangesInd': %w", err)
		}
	}

	if a.NfProfileChangesSupportInd != nil {
		object["nfProfileChangesSupportInd"], err = json.Marshal(a.NfProfileChangesSupportInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfProfileChangesSupportInd': %w", err)
		}
	}

	if a.NfServiceList != nil {
		object["nfServiceList"], err = json.Marshal(a.NfServiceList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServiceList': %w", err)
		}
	}

	if a.NfServicePersistence != nil {
		object["nfServicePersistence"], err = json.Marshal(a.NfServicePersistence)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServicePersistence': %w", err)
		}
	}

	if len(a.NfServices) != 0 {
		object["nfServices"], err = json.Marshal(a.NfServices)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServices': %w", err)
		}
	}

	if len(a.NfSetIdList) != 0 {
		object["nfSetIdList"], err = json.Marshal(a.NfSetIdList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfSetIdList': %w", err)
		}
	}

	if a.NfSetRecoveryTimeList != nil {
		object["nfSetRecoveryTimeList"], err = json.Marshal(a.NfSetRecoveryTimeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfSetRecoveryTimeList': %w", err)
		}
	}

	object["nfStatus"], err = json.Marshal(a.NfStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfStatus': %w", err)
	}

	object["nfType"], err = json.Marshal(a.NfType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfType': %w", err)
	}

	if a.NrfInfo != nil {
		object["nrfInfo"], err = json.Marshal(a.NrfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nrfInfo': %w", err)
		}
	}

	if len(a.NsiList) != 0 {
		object["nsiList"], err = json.Marshal(a.NsiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nsiList': %w", err)
		}
	}

	if a.NwdafInfo != nil {
		object["nwdafInfo"], err = json.Marshal(a.NwdafInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nwdafInfo': %w", err)
		}
	}

	if a.OlcHSupportInd != nil {
		object["olcHSupportInd"], err = json.Marshal(a.OlcHSupportInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'olcHSupportInd': %w", err)
		}
	}

	if a.PcfInfo != nil {
		object["pcfInfo"], err = json.Marshal(a.PcfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pcfInfo': %w", err)
		}
	}

	if a.PcfInfoList != nil {
		object["pcfInfoList"], err = json.Marshal(a.PcfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pcfInfoList': %w", err)
		}
	}

	if a.PcscfInfoList != nil {
		object["pcscfInfoList"], err = json.Marshal(a.PcscfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pcscfInfoList': %w", err)
		}
	}

	if len(a.PerPlmnSnssaiList) != 0 {
		object["perPlmnSnssaiList"], err = json.Marshal(a.PerPlmnSnssaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'perPlmnSnssaiList': %w", err)
		}
	}

	if len(a.PlmnList) != 0 {
		object["plmnList"], err = json.Marshal(a.PlmnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'plmnList': %w", err)
		}
	}

	if a.Priority != nil {
		object["priority"], err = json.Marshal(a.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	if a.RecoveryTime != nil {
		object["recoveryTime"], err = json.Marshal(a.RecoveryTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recoveryTime': %w", err)
		}
	}

	if len(a.SNssais) != 0 {
		object["sNssais"], err = json.Marshal(a.SNssais)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sNssais': %w", err)
		}
	}

	if len(a.ScpDomains) != 0 {
		object["scpDomains"], err = json.Marshal(a.ScpDomains)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpDomains': %w", err)
		}
	}

	if a.ScpInfo != nil {
		object["scpInfo"], err = json.Marshal(a.ScpInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpInfo': %w", err)
		}
	}

	if a.ServiceSetRecoveryTimeList != nil {
		object["serviceSetRecoveryTimeList"], err = json.Marshal(a.ServiceSetRecoveryTimeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'serviceSetRecoveryTimeList': %w", err)
		}
	}

	if len(a.ServingScope) != 0 {
		object["servingScope"], err = json.Marshal(a.ServingScope)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingScope': %w", err)
		}
	}

	if a.SmfInfo != nil {
		object["smfInfo"], err = json.Marshal(a.SmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'smfInfo': %w", err)
		}
	}

	if a.SmfInfoList != nil {
		object["smfInfoList"], err = json.Marshal(a.SmfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'smfInfoList': %w", err)
		}
	}

	if len(a.SnpnList) != 0 {
		object["snpnList"], err = json.Marshal(a.SnpnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'snpnList': %w", err)
		}
	}

	if a.UdmInfo != nil {
		object["udmInfo"], err = json.Marshal(a.UdmInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udmInfo': %w", err)
		}
	}

	if a.UdmInfoList != nil {
		object["udmInfoList"], err = json.Marshal(a.UdmInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udmInfoList': %w", err)
		}
	}

	if a.UdrInfo != nil {
		object["udrInfo"], err = json.Marshal(a.UdrInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udrInfo': %w", err)
		}
	}

	if a.UdrInfoList != nil {
		object["udrInfoList"], err = json.Marshal(a.UdrInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udrInfoList': %w", err)
		}
	}

	if a.UdsfInfo != nil {
		object["udsfInfo"], err = json.Marshal(a.UdsfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udsfInfo': %w", err)
		}
	}

	if a.UdsfInfoList != nil {
		object["udsfInfoList"], err = json.Marshal(a.UdsfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udsfInfoList': %w", err)
		}
	}

	if a.UpfInfo != nil {
		object["upfInfo"], err = json.Marshal(a.UpfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upfInfo': %w", err)
		}
	}

	if a.UpfInfoList != nil {
		object["upfInfoList"], err = json.Marshal(a.UpfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upfInfoList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NFService. Returns the specified
// element and whether it was found
func (a NFService) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NFService
func (a *NFService) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NFService to handle AdditionalProperties
func (a *NFService) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allowedNfDomains"]; found {
		err = json.Unmarshal(raw, &a.AllowedNfDomains)
		if err != nil {
			return fmt.Errorf("error reading 'allowedNfDomains': %w", err)
		}
		delete(object, "allowedNfDomains")
	}

	if raw, found := object["allowedNfTypes"]; found {
		err = json.Unmarshal(raw, &a.AllowedNfTypes)
		if err != nil {
			return fmt.Errorf("error reading 'allowedNfTypes': %w", err)
		}
		delete(object, "allowedNfTypes")
	}

	if raw, found := object["allowedNssais"]; found {
		err = json.Unmarshal(raw, &a.AllowedNssais)
		if err != nil {
			return fmt.Errorf("error reading 'allowedNssais': %w", err)
		}
		delete(object, "allowedNssais")
	}

	if raw, found := object["allowedOperationsPerNfInstance"]; found {
		err = json.Unmarshal(raw, &a.AllowedOperationsPerNfInstance)
		if err != nil {
			return fmt.Errorf("error reading 'allowedOperationsPerNfInstance': %w", err)
		}
		delete(object, "allowedOperationsPerNfInstance")
	}

	if raw, found := object["allowedOperationsPerNfType"]; found {
		err = json.Unmarshal(raw, &a.AllowedOperationsPerNfType)
		if err != nil {
			return fmt.Errorf("error reading 'allowedOperationsPerNfType': %w", err)
		}
		delete(object, "allowedOperationsPerNfType")
	}

	if raw, found := object["allowedPlmns"]; found {
		err = json.Unmarshal(raw, &a.AllowedPlmns)
		if err != nil {
			return fmt.Errorf("error reading 'allowedPlmns': %w", err)
		}
		delete(object, "allowedPlmns")
	}

	if raw, found := object["allowedSnpns"]; found {
		err = json.Unmarshal(raw, &a.AllowedSnpns)
		if err != nil {
			return fmt.Errorf("error reading 'allowedSnpns': %w", err)
		}
		delete(object, "allowedSnpns")
	}

	if raw, found := object["apiPrefix"]; found {
		err = json.Unmarshal(raw, &a.ApiPrefix)
		if err != nil {
			return fmt.Errorf("error reading 'apiPrefix': %w", err)
		}
		delete(object, "apiPrefix")
	}

	if raw, found := object["capacity"]; found {
		err = json.Unmarshal(raw, &a.Capacity)
		if err != nil {
			return fmt.Errorf("error reading 'capacity': %w", err)
		}
		delete(object, "capacity")
	}

	if raw, found := object["defaultNotificationSubscriptions"]; found {
		err = json.Unmarshal(raw, &a.DefaultNotificationSubscriptions)
		if err != nil {
			return fmt.Errorf("error reading 'defaultNotificationSubscriptions': %w", err)
		}
		delete(object, "defaultNotificationSubscriptions")
	}

	if raw, found := object["fqdn"]; found {
		err = json.Unmarshal(raw, &a.Fqdn)
		if err != nil {
			return fmt.Errorf("error reading 'fqdn': %w", err)
		}
		delete(object, "fqdn")
	}

	if raw, found := object["interPlmnFqdn"]; found {
		err = json.Unmarshal(raw, &a.InterPlmnFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'interPlmnFqdn': %w", err)
		}
		delete(object, "interPlmnFqdn")
	}

	if raw, found := object["ipEndPoints"]; found {
		err = json.Unmarshal(raw, &a.IpEndPoints)
		if err != nil {
			return fmt.Errorf("error reading 'ipEndPoints': %w", err)
		}
		delete(object, "ipEndPoints")
	}

	if raw, found := object["load"]; found {
		err = json.Unmarshal(raw, &a.Load)
		if err != nil {
			return fmt.Errorf("error reading 'load': %w", err)
		}
		delete(object, "load")
	}

	if raw, found := object["loadTimeStamp"]; found {
		err = json.Unmarshal(raw, &a.LoadTimeStamp)
		if err != nil {
			return fmt.Errorf("error reading 'loadTimeStamp': %w", err)
		}
		delete(object, "loadTimeStamp")
	}

	if raw, found := object["nfServiceSetIdList"]; found {
		err = json.Unmarshal(raw, &a.NfServiceSetIdList)
		if err != nil {
			return fmt.Errorf("error reading 'nfServiceSetIdList': %w", err)
		}
		delete(object, "nfServiceSetIdList")
	}

	if raw, found := object["nfServiceStatus"]; found {
		err = json.Unmarshal(raw, &a.NfServiceStatus)
		if err != nil {
			return fmt.Errorf("error reading 'nfServiceStatus': %w", err)
		}
		delete(object, "nfServiceStatus")
	}

	if raw, found := object["oauth2Required"]; found {
		err = json.Unmarshal(raw, &a.Oauth2Required)
		if err != nil {
			return fmt.Errorf("error reading 'oauth2Required': %w", err)
		}
		delete(object, "oauth2Required")
	}

	if raw, found := object["perPlmnSnssaiList"]; found {
		err = json.Unmarshal(raw, &a.PerPlmnSnssaiList)
		if err != nil {
			return fmt.Errorf("error reading 'perPlmnSnssaiList': %w", err)
		}
		delete(object, "perPlmnSnssaiList")
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &a.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
		delete(object, "priority")
	}

	if raw, found := object["recoveryTime"]; found {
		err = json.Unmarshal(raw, &a.RecoveryTime)
		if err != nil {
			return fmt.Errorf("error reading 'recoveryTime': %w", err)
		}
		delete(object, "recoveryTime")
	}

	if raw, found := object["sNssais"]; found {
		err = json.Unmarshal(raw, &a.SNssais)
		if err != nil {
			return fmt.Errorf("error reading 'sNssais': %w", err)
		}
		delete(object, "sNssais")
	}

	if raw, found := object["scheme"]; found {
		err = json.Unmarshal(raw, &a.Scheme)
		if err != nil {
			return fmt.Errorf("error reading 'scheme': %w", err)
		}
		delete(object, "scheme")
	}

	if raw, found := object["serviceInstanceId"]; found {
		err = json.Unmarshal(raw, &a.ServiceInstanceId)
		if err != nil {
			return fmt.Errorf("error reading 'serviceInstanceId': %w", err)
		}
		delete(object, "serviceInstanceId")
	}

	if raw, found := object["serviceName"]; found {
		err = json.Unmarshal(raw, &a.ServiceName)
		if err != nil {
			return fmt.Errorf("error reading 'serviceName': %w", err)
		}
		delete(object, "serviceName")
	}

	if raw, found := object["supportedFeatures"]; found {
		err = json.Unmarshal(raw, &a.SupportedFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'supportedFeatures': %w", err)
		}
		delete(object, "supportedFeatures")
	}

	if raw, found := object["supportedVendorSpecificFeatures"]; found {
		err = json.Unmarshal(raw, &a.SupportedVendorSpecificFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'supportedVendorSpecificFeatures': %w", err)
		}
		delete(object, "supportedVendorSpecificFeatures")
	}

	if raw, found := object["vendorId"]; found {
		err = json.Unmarshal(raw, &a.VendorId)
		if err != nil {
			return fmt.Errorf("error reading 'vendorId': %w", err)
		}
		delete(object, "vendorId")
	}

	if raw, found := object["versions"]; found {
		err = json.Unmarshal(raw, &a.Versions)
		if err != nil {
			return fmt.Errorf("error reading 'versions': %w", err)
		}
		delete(object, "versions")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NFService to handle AdditionalProperties
func (a NFService) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AllowedNfDomains) != 0 {
		object["allowedNfDomains"], err = json.Marshal(a.AllowedNfDomains)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedNfDomains': %w", err)
		}
	}

	if len(a.AllowedNfTypes) != 0 {
		object["allowedNfTypes"], err = json.Marshal(a.AllowedNfTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedNfTypes': %w", err)
		}
	}

	if len(a.AllowedNssais) != 0 {
		object["allowedNssais"], err = json.Marshal(a.AllowedNssais)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedNssais': %w", err)
		}
	}

	if a.AllowedOperationsPerNfInstance != nil {
		object["allowedOperationsPerNfInstance"], err = json.Marshal(a.AllowedOperationsPerNfInstance)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedOperationsPerNfInstance': %w", err)
		}
	}

	if a.AllowedOperationsPerNfType != nil {
		object["allowedOperationsPerNfType"], err = json.Marshal(a.AllowedOperationsPerNfType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedOperationsPerNfType': %w", err)
		}
	}

	if len(a.AllowedPlmns) != 0 {
		object["allowedPlmns"], err = json.Marshal(a.AllowedPlmns)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedPlmns': %w", err)
		}
	}

	if len(a.AllowedSnpns) != 0 {
		object["allowedSnpns"], err = json.Marshal(a.AllowedSnpns)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedSnpns': %w", err)
		}
	}

	if a.ApiPrefix != nil {
		object["apiPrefix"], err = json.Marshal(a.ApiPrefix)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'apiPrefix': %w", err)
		}
	}

	if a.Capacity != nil {
		object["capacity"], err = json.Marshal(a.Capacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capacity': %w", err)
		}
	}

	if len(a.DefaultNotificationSubscriptions) != 0 {
		object["defaultNotificationSubscriptions"], err = json.Marshal(a.DefaultNotificationSubscriptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'defaultNotificationSubscriptions': %w", err)
		}
	}

	if a.Fqdn != nil {
		object["fqdn"], err = json.Marshal(a.Fqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fqdn': %w", err)
		}
	}

	if a.InterPlmnFqdn != nil {
		object["interPlmnFqdn"], err = json.Marshal(a.InterPlmnFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'interPlmnFqdn': %w", err)
		}
	}

	if len(a.IpEndPoints) != 0 {
		object["ipEndPoints"], err = json.Marshal(a.IpEndPoints)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipEndPoints': %w", err)
		}
	}

	if a.Load != nil {
		object["load"], err = json.Marshal(a.Load)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'load': %w", err)
		}
	}

	if a.LoadTimeStamp != nil {
		object["loadTimeStamp"], err = json.Marshal(a.LoadTimeStamp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'loadTimeStamp': %w", err)
		}
	}

	if len(a.NfServiceSetIdList) != 0 {
		object["nfServiceSetIdList"], err = json.Marshal(a.NfServiceSetIdList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServiceSetIdList': %w", err)
		}
	}

	object["nfServiceStatus"], err = json.Marshal(a.NfServiceStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfServiceStatus': %w", err)
	}

	if a.Oauth2Required != nil {
		object["oauth2Required"], err = json.Marshal(a.Oauth2Required)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'oauth2Required': %w", err)
		}
	}

	if len(a.PerPlmnSnssaiList) != 0 {
		object["perPlmnSnssaiList"], err = json.Marshal(a.PerPlmnSnssaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'perPlmnSnssaiList': %w", err)
		}
	}

	if a.Priority != nil {
		object["priority"], err = json.Marshal(a.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	if a.RecoveryTime != nil {
		object["recoveryTime"], err = json.Marshal(a.RecoveryTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recoveryTime': %w", err)
		}
	}

	if len(a.SNssais) != 0 {
		object["sNssais"], err = json.Marshal(a.SNssais)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sNssais': %w", err)
		}
	}

	object["scheme"], err = json.Marshal(a.Scheme)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'scheme': %w", err)
	}

	object["serviceInstanceId"], err = json.Marshal(a.ServiceInstanceId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'serviceInstanceId': %w", err)
	}

	object["serviceName"], err = json.Marshal(a.ServiceName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'serviceName': %w", err)
	}

	if a.SupportedFeatures != nil {
		object["supportedFeatures"], err = json.Marshal(a.SupportedFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supportedFeatures': %w", err)
		}
	}

	if a.SupportedVendorSpecificFeatures != nil {
		object["supportedVendorSpecificFeatures"], err = json.Marshal(a.SupportedVendorSpecificFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supportedVendorSpecificFeatures': %w", err)
		}
	}

	if len(a.VendorId) != 0 {
		object["vendorId"], err = json.Marshal(a.VendorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vendorId': %w", err)
		}
	}

	object["versions"], err = json.Marshal(a.Versions)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'versions': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NFServiceVersion. Returns the specified
// element and whether it was found
func (a NFServiceVersion) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NFServiceVersion
func (a *NFServiceVersion) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NFServiceVersion to handle AdditionalProperties
func (a *NFServiceVersion) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["apiFullVersion"]; found {
		err = json.Unmarshal(raw, &a.ApiFullVersion)
		if err != nil {
			return fmt.Errorf("error reading 'apiFullVersion': %w", err)
		}
		delete(object, "apiFullVersion")
	}

	if raw, found := object["apiVersionInUri"]; found {
		err = json.Unmarshal(raw, &a.ApiVersionInUri)
		if err != nil {
			return fmt.Errorf("error reading 'apiVersionInUri': %w", err)
		}
		delete(object, "apiVersionInUri")
	}

	if raw, found := object["expiry"]; found {
		err = json.Unmarshal(raw, &a.Expiry)
		if err != nil {
			return fmt.Errorf("error reading 'expiry': %w", err)
		}
		delete(object, "expiry")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NFServiceVersion to handle AdditionalProperties
func (a NFServiceVersion) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["apiFullVersion"], err = json.Marshal(a.ApiFullVersion)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'apiFullVersion': %w", err)
	}

	object["apiVersionInUri"], err = json.Marshal(a.ApiVersionInUri)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'apiVersionInUri': %w", err)
	}

	if a.Expiry != nil {
		object["expiry"], err = json.Marshal(a.Expiry)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'expiry': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NefCond. Returns the specified
// element and whether it was found
func (a NefCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NefCond
func (a *NefCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NefCond to handle AdditionalProperties
func (a *NefCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["afEvents"]; found {
		err = json.Unmarshal(raw, &a.AfEvents)
		if err != nil {
			return fmt.Errorf("error reading 'afEvents': %w", err)
		}
		delete(object, "afEvents")
	}

	if raw, found := object["conditionType"]; found {
		err = json.Unmarshal(raw, &a.ConditionType)
		if err != nil {
			return fmt.Errorf("error reading 'conditionType': %w", err)
		}
		delete(object, "conditionType")
	}

	if raw, found := object["externalGroupIdentifiersRanges"]; found {
		err = json.Unmarshal(raw, &a.ExternalGroupIdentifiersRanges)
		if err != nil {
			return fmt.Errorf("error reading 'externalGroupIdentifiersRanges': %w", err)
		}
		delete(object, "externalGroupIdentifiersRanges")
	}

	if raw, found := object["gpsiRanges"]; found {
		err = json.Unmarshal(raw, &a.GpsiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'gpsiRanges': %w", err)
		}
		delete(object, "gpsiRanges")
	}

	if raw, found := object["pfdData"]; found {
		err = json.Unmarshal(raw, &a.PfdData)
		if err != nil {
			return fmt.Errorf("error reading 'pfdData': %w", err)
		}
		delete(object, "pfdData")
	}

	if raw, found := object["servedFqdnList"]; found {
		err = json.Unmarshal(raw, &a.ServedFqdnList)
		if err != nil {
			return fmt.Errorf("error reading 'servedFqdnList': %w", err)
		}
		delete(object, "servedFqdnList")
	}

	if raw, found := object["snssaiList"]; found {
		err = json.Unmarshal(raw, &a.SnssaiList)
		if err != nil {
			return fmt.Errorf("error reading 'snssaiList': %w", err)
		}
		delete(object, "snssaiList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NefCond to handle AdditionalProperties
func (a NefCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AfEvents) != 0 {
		object["afEvents"], err = json.Marshal(a.AfEvents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'afEvents': %w", err)
		}
	}

	object["conditionType"], err = json.Marshal(a.ConditionType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'conditionType': %w", err)
	}

	if len(a.ExternalGroupIdentifiersRanges) != 0 {
		object["externalGroupIdentifiersRanges"], err = json.Marshal(a.ExternalGroupIdentifiersRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'externalGroupIdentifiersRanges': %w", err)
		}
	}

	if len(a.GpsiRanges) != 0 {
		object["gpsiRanges"], err = json.Marshal(a.GpsiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gpsiRanges': %w", err)
		}
	}

	if a.PfdData != nil {
		object["pfdData"], err = json.Marshal(a.PfdData)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pfdData': %w", err)
		}
	}

	if len(a.ServedFqdnList) != 0 {
		object["servedFqdnList"], err = json.Marshal(a.ServedFqdnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedFqdnList': %w", err)
		}
	}

	if len(a.SnssaiList) != 0 {
		object["snssaiList"], err = json.Marshal(a.SnssaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'snssaiList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NefInfo. Returns the specified
// element and whether it was found
func (a NefInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NefInfo
func (a *NefInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NefInfo to handle AdditionalProperties
func (a *NefInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["afEeData"]; found {
		err = json.Unmarshal(raw, &a.AfEeData)
		if err != nil {
			return fmt.Errorf("error reading 'afEeData': %w", err)
		}
		delete(object, "afEeData")
	}

	if raw, found := object["externalGroupIdentifiersRanges"]; found {
		err = json.Unmarshal(raw, &a.ExternalGroupIdentifiersRanges)
		if err != nil {
			return fmt.Errorf("error reading 'externalGroupIdentifiersRanges': %w", err)
		}
		delete(object, "externalGroupIdentifiersRanges")
	}

	if raw, found := object["gpsiRanges"]; found {
		err = json.Unmarshal(raw, &a.GpsiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'gpsiRanges': %w", err)
		}
		delete(object, "gpsiRanges")
	}

	if raw, found := object["nefId"]; found {
		err = json.Unmarshal(raw, &a.NefId)
		if err != nil {
			return fmt.Errorf("error reading 'nefId': %w", err)
		}
		delete(object, "nefId")
	}

	if raw, found := object["pfdData"]; found {
		err = json.Unmarshal(raw, &a.PfdData)
		if err != nil {
			return fmt.Errorf("error reading 'pfdData': %w", err)
		}
		delete(object, "pfdData")
	}

	if raw, found := object["servedFqdnList"]; found {
		err = json.Unmarshal(raw, &a.ServedFqdnList)
		if err != nil {
			return fmt.Errorf("error reading 'servedFqdnList': %w", err)
		}
		delete(object, "servedFqdnList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NefInfo to handle AdditionalProperties
func (a NefInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AfEeData != nil {
		object["afEeData"], err = json.Marshal(a.AfEeData)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'afEeData': %w", err)
		}
	}

	if len(a.ExternalGroupIdentifiersRanges) != 0 {
		object["externalGroupIdentifiersRanges"], err = json.Marshal(a.ExternalGroupIdentifiersRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'externalGroupIdentifiersRanges': %w", err)
		}
	}

	if len(a.GpsiRanges) != 0 {
		object["gpsiRanges"], err = json.Marshal(a.GpsiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gpsiRanges': %w", err)
		}
	}

	if a.NefId != nil {
		object["nefId"], err = json.Marshal(a.NefId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nefId': %w", err)
		}
	}

	if a.PfdData != nil {
		object["pfdData"], err = json.Marshal(a.PfdData)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pfdData': %w", err)
		}
	}

	if len(a.ServedFqdnList) != 0 {
		object["servedFqdnList"], err = json.Marshal(a.ServedFqdnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedFqdnList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NetworkSliceCond. Returns the specified
// element and whether it was found
func (a NetworkSliceCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetworkSliceCond
func (a *NetworkSliceCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetworkSliceCond to handle AdditionalProperties
func (a *NetworkSliceCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nsiList"]; found {
		err = json.Unmarshal(raw, &a.NsiList)
		if err != nil {
			return fmt.Errorf("error reading 'nsiList': %w", err)
		}
		delete(object, "nsiList")
	}

	if raw, found := object["snssaiList"]; found {
		err = json.Unmarshal(raw, &a.SnssaiList)
		if err != nil {
			return fmt.Errorf("error reading 'snssaiList': %w", err)
		}
		delete(object, "snssaiList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetworkSliceCond to handle AdditionalProperties
func (a NetworkSliceCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.NsiList != nil {
		object["nsiList"], err = json.Marshal(a.NsiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nsiList': %w", err)
		}
	}

	object["snssaiList"], err = json.Marshal(a.SnssaiList)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'snssaiList': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NfGroupCond. Returns the specified
// element and whether it was found
func (a NfGroupCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NfGroupCond
func (a *NfGroupCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NfGroupCond to handle AdditionalProperties
func (a *NfGroupCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nfGroupId"]; found {
		err = json.Unmarshal(raw, &a.NfGroupId)
		if err != nil {
			return fmt.Errorf("error reading 'nfGroupId': %w", err)
		}
		delete(object, "nfGroupId")
	}

	if raw, found := object["nfType"]; found {
		err = json.Unmarshal(raw, &a.NfType)
		if err != nil {
			return fmt.Errorf("error reading 'nfType': %w", err)
		}
		delete(object, "nfType")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NfGroupCond to handle AdditionalProperties
func (a NfGroupCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nfGroupId"], err = json.Marshal(a.NfGroupId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfGroupId': %w", err)
	}

	object["nfType"], err = json.Marshal(a.NfType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfType': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NfInfo. Returns the specified
// element and whether it was found
func (a NfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NfInfo
func (a *NfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NfInfo to handle AdditionalProperties
func (a *NfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nfType"]; found {
		err = json.Unmarshal(raw, &a.NfType)
		if err != nil {
			return fmt.Errorf("error reading 'nfType': %w", err)
		}
		delete(object, "nfType")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NfInfo to handle AdditionalProperties
func (a NfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.NfType != nil {
		object["nfType"], err = json.Marshal(a.NfType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfType': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NfInstanceIdCond. Returns the specified
// element and whether it was found
func (a NfInstanceIdCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NfInstanceIdCond
func (a *NfInstanceIdCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NfInstanceIdCond to handle AdditionalProperties
func (a *NfInstanceIdCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nfInstanceId"]; found {
		err = json.Unmarshal(raw, &a.NfInstanceId)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstanceId': %w", err)
		}
		delete(object, "nfInstanceId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NfInstanceIdCond to handle AdditionalProperties
func (a NfInstanceIdCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nfInstanceId"], err = json.Marshal(a.NfInstanceId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfInstanceId': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NfInstanceIdListCond. Returns the specified
// element and whether it was found
func (a NfInstanceIdListCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NfInstanceIdListCond
func (a *NfInstanceIdListCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NfInstanceIdListCond to handle AdditionalProperties
func (a *NfInstanceIdListCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nfInstanceIdList"]; found {
		err = json.Unmarshal(raw, &a.NfInstanceIdList)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstanceIdList': %w", err)
		}
		delete(object, "nfInstanceIdList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NfInstanceIdListCond to handle AdditionalProperties
func (a NfInstanceIdListCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nfInstanceIdList"], err = json.Marshal(a.NfInstanceIdList)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfInstanceIdList': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NfServiceSetCond. Returns the specified
// element and whether it was found
func (a NfServiceSetCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NfServiceSetCond
func (a *NfServiceSetCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NfServiceSetCond to handle AdditionalProperties
func (a *NfServiceSetCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nfServiceSetId"]; found {
		err = json.Unmarshal(raw, &a.NfServiceSetId)
		if err != nil {
			return fmt.Errorf("error reading 'nfServiceSetId': %w", err)
		}
		delete(object, "nfServiceSetId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NfServiceSetCond to handle AdditionalProperties
func (a NfServiceSetCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nfServiceSetId"], err = json.Marshal(a.NfServiceSetId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfServiceSetId': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NfSetCond. Returns the specified
// element and whether it was found
func (a NfSetCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NfSetCond
func (a *NfSetCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NfSetCond to handle AdditionalProperties
func (a *NfSetCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nfSetId"]; found {
		err = json.Unmarshal(raw, &a.NfSetId)
		if err != nil {
			return fmt.Errorf("error reading 'nfSetId': %w", err)
		}
		delete(object, "nfSetId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NfSetCond to handle AdditionalProperties
func (a NfSetCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nfSetId"], err = json.Marshal(a.NfSetId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfSetId': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NfTypeCond. Returns the specified
// element and whether it was found
func (a NfTypeCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NfTypeCond
func (a *NfTypeCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NfTypeCond to handle AdditionalProperties
func (a *NfTypeCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nfType"]; found {
		err = json.Unmarshal(raw, &a.NfType)
		if err != nil {
			return fmt.Errorf("error reading 'nfType': %w", err)
		}
		delete(object, "nfType")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NfTypeCond to handle AdditionalProperties
func (a NfTypeCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nfType"], err = json.Marshal(a.NfType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfType': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NotifCondition. Returns the specified
// element and whether it was found
func (a NotifCondition) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NotifCondition
func (a *NotifCondition) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NotifCondition to handle AdditionalProperties
func (a *NotifCondition) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["monitoredAttributes"]; found {
		err = json.Unmarshal(raw, &a.MonitoredAttributes)
		if err != nil {
			return fmt.Errorf("error reading 'monitoredAttributes': %w", err)
		}
		delete(object, "monitoredAttributes")
	}

	if raw, found := object["unmonitoredAttributes"]; found {
		err = json.Unmarshal(raw, &a.UnmonitoredAttributes)
		if err != nil {
			return fmt.Errorf("error reading 'unmonitoredAttributes': %w", err)
		}
		delete(object, "unmonitoredAttributes")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NotifCondition to handle AdditionalProperties
func (a NotifCondition) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.MonitoredAttributes) != 0 {
		object["monitoredAttributes"], err = json.Marshal(a.MonitoredAttributes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'monitoredAttributes': %w", err)
		}
	}

	if len(a.UnmonitoredAttributes) != 0 {
		object["unmonitoredAttributes"], err = json.Marshal(a.UnmonitoredAttributes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'unmonitoredAttributes': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NotificationData. Returns the specified
// element and whether it was found
func (a NotificationData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NotificationData
func (a *NotificationData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NotificationData to handle AdditionalProperties
func (a *NotificationData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["conditionEvent"]; found {
		err = json.Unmarshal(raw, &a.ConditionEvent)
		if err != nil {
			return fmt.Errorf("error reading 'conditionEvent': %w", err)
		}
		delete(object, "conditionEvent")
	}

	if raw, found := object["event"]; found {
		err = json.Unmarshal(raw, &a.Event)
		if err != nil {
			return fmt.Errorf("error reading 'event': %w", err)
		}
		delete(object, "event")
	}

	if raw, found := object["nfInstanceUri"]; found {
		err = json.Unmarshal(raw, &a.NfInstanceUri)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstanceUri': %w", err)
		}
		delete(object, "nfInstanceUri")
	}

	if raw, found := object["nfProfile"]; found {
		err = json.Unmarshal(raw, &a.NfProfile)
		if err != nil {
			return fmt.Errorf("error reading 'nfProfile': %w", err)
		}
		delete(object, "nfProfile")
	}

	if raw, found := object["profileChanges"]; found {
		err = json.Unmarshal(raw, &a.ProfileChanges)
		if err != nil {
			return fmt.Errorf("error reading 'profileChanges': %w", err)
		}
		delete(object, "profileChanges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NotificationData to handle AdditionalProperties
func (a NotificationData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ConditionEvent != nil {
		object["conditionEvent"], err = json.Marshal(a.ConditionEvent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'conditionEvent': %w", err)
		}
	}

	object["event"], err = json.Marshal(a.Event)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'event': %w", err)
	}

	object["nfInstanceUri"], err = json.Marshal(a.NfInstanceUri)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfInstanceUri': %w", err)
	}

	if a.NfProfile != nil {
		object["nfProfile"], err = json.Marshal(a.NfProfile)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfProfile': %w", err)
		}
	}

	if len(a.ProfileChanges) != 0 {
		object["profileChanges"], err = json.Marshal(a.ProfileChanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'profileChanges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NotificationData_NfProfile. Returns the specified
// element and whether it was found
func (a NotificationData_NfProfile) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NotificationData_NfProfile
func (a *NotificationData_NfProfile) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NotificationData_NfProfile to handle AdditionalProperties
func (a *NotificationData_NfProfile) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allowedNfDomains"]; found {
		err = json.Unmarshal(raw, &a.AllowedNfDomains)
		if err != nil {
			return fmt.Errorf("error reading 'allowedNfDomains': %w", err)
		}
		delete(object, "allowedNfDomains")
	}

	if raw, found := object["allowedNfTypes"]; found {
		err = json.Unmarshal(raw, &a.AllowedNfTypes)
		if err != nil {
			return fmt.Errorf("error reading 'allowedNfTypes': %w", err)
		}
		delete(object, "allowedNfTypes")
	}

	if raw, found := object["allowedNssais"]; found {
		err = json.Unmarshal(raw, &a.AllowedNssais)
		if err != nil {
			return fmt.Errorf("error reading 'allowedNssais': %w", err)
		}
		delete(object, "allowedNssais")
	}

	if raw, found := object["allowedPlmns"]; found {
		err = json.Unmarshal(raw, &a.AllowedPlmns)
		if err != nil {
			return fmt.Errorf("error reading 'allowedPlmns': %w", err)
		}
		delete(object, "allowedPlmns")
	}

	if raw, found := object["allowedSnpns"]; found {
		err = json.Unmarshal(raw, &a.AllowedSnpns)
		if err != nil {
			return fmt.Errorf("error reading 'allowedSnpns': %w", err)
		}
		delete(object, "allowedSnpns")
	}

	if raw, found := object["amfInfo"]; found {
		err = json.Unmarshal(raw, &a.AmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'amfInfo': %w", err)
		}
		delete(object, "amfInfo")
	}

	if raw, found := object["amfInfoList"]; found {
		err = json.Unmarshal(raw, &a.AmfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'amfInfoList': %w", err)
		}
		delete(object, "amfInfoList")
	}

	if raw, found := object["ausfInfo"]; found {
		err = json.Unmarshal(raw, &a.AusfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'ausfInfo': %w", err)
		}
		delete(object, "ausfInfo")
	}

	if raw, found := object["ausfInfoList"]; found {
		err = json.Unmarshal(raw, &a.AusfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'ausfInfoList': %w", err)
		}
		delete(object, "ausfInfoList")
	}

	if raw, found := object["bsfInfo"]; found {
		err = json.Unmarshal(raw, &a.BsfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'bsfInfo': %w", err)
		}
		delete(object, "bsfInfo")
	}

	if raw, found := object["bsfInfoList"]; found {
		err = json.Unmarshal(raw, &a.BsfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'bsfInfoList': %w", err)
		}
		delete(object, "bsfInfoList")
	}

	if raw, found := object["capacity"]; found {
		err = json.Unmarshal(raw, &a.Capacity)
		if err != nil {
			return fmt.Errorf("error reading 'capacity': %w", err)
		}
		delete(object, "capacity")
	}

	if raw, found := object["chfInfo"]; found {
		err = json.Unmarshal(raw, &a.ChfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'chfInfo': %w", err)
		}
		delete(object, "chfInfo")
	}

	if raw, found := object["chfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ChfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'chfInfoList': %w", err)
		}
		delete(object, "chfInfoList")
	}

	if raw, found := object["customInfo"]; found {
		err = json.Unmarshal(raw, &a.CustomInfo)
		if err != nil {
			return fmt.Errorf("error reading 'customInfo': %w", err)
		}
		delete(object, "customInfo")
	}

	if raw, found := object["defaultNotificationSubscriptions"]; found {
		err = json.Unmarshal(raw, &a.DefaultNotificationSubscriptions)
		if err != nil {
			return fmt.Errorf("error reading 'defaultNotificationSubscriptions': %w", err)
		}
		delete(object, "defaultNotificationSubscriptions")
	}

	if raw, found := object["fqdn"]; found {
		err = json.Unmarshal(raw, &a.Fqdn)
		if err != nil {
			return fmt.Errorf("error reading 'fqdn': %w", err)
		}
		delete(object, "fqdn")
	}

	if raw, found := object["gmlcInfo"]; found {
		err = json.Unmarshal(raw, &a.GmlcInfo)
		if err != nil {
			return fmt.Errorf("error reading 'gmlcInfo': %w", err)
		}
		delete(object, "gmlcInfo")
	}

	if raw, found := object["heartBeatTimer"]; found {
		err = json.Unmarshal(raw, &a.HeartBeatTimer)
		if err != nil {
			return fmt.Errorf("error reading 'heartBeatTimer': %w", err)
		}
		delete(object, "heartBeatTimer")
	}

	if raw, found := object["hssInfoList"]; found {
		err = json.Unmarshal(raw, &a.HssInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'hssInfoList': %w", err)
		}
		delete(object, "hssInfoList")
	}

	if raw, found := object["interPlmnFqdn"]; found {
		err = json.Unmarshal(raw, &a.InterPlmnFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'interPlmnFqdn': %w", err)
		}
		delete(object, "interPlmnFqdn")
	}

	if raw, found := object["ipv4Addresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv4Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4Addresses': %w", err)
		}
		delete(object, "ipv4Addresses")
	}

	if raw, found := object["ipv6Addresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv6Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6Addresses': %w", err)
		}
		delete(object, "ipv6Addresses")
	}

	if raw, found := object["lcHSupportInd"]; found {
		err = json.Unmarshal(raw, &a.LcHSupportInd)
		if err != nil {
			return fmt.Errorf("error reading 'lcHSupportInd': %w", err)
		}
		delete(object, "lcHSupportInd")
	}

	if raw, found := object["lmfInfo"]; found {
		err = json.Unmarshal(raw, &a.LmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'lmfInfo': %w", err)
		}
		delete(object, "lmfInfo")
	}

	if raw, found := object["load"]; found {
		err = json.Unmarshal(raw, &a.Load)
		if err != nil {
			return fmt.Errorf("error reading 'load': %w", err)
		}
		delete(object, "load")
	}

	if raw, found := object["loadTimeStamp"]; found {
		err = json.Unmarshal(raw, &a.LoadTimeStamp)
		if err != nil {
			return fmt.Errorf("error reading 'loadTimeStamp': %w", err)
		}
		delete(object, "loadTimeStamp")
	}

	if raw, found := object["locality"]; found {
		err = json.Unmarshal(raw, &a.Locality)
		if err != nil {
			return fmt.Errorf("error reading 'locality': %w", err)
		}
		delete(object, "locality")
	}

	if raw, found := object["nefInfo"]; found {
		err = json.Unmarshal(raw, &a.NefInfo)
		if err != nil {
			return fmt.Errorf("error reading 'nefInfo': %w", err)
		}
		delete(object, "nefInfo")
	}

	if raw, found := object["nfInstanceId"]; found {
		err = json.Unmarshal(raw, &a.NfInstanceId)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstanceId': %w", err)
		}
		delete(object, "nfInstanceId")
	}

	if raw, found := object["nfInstanceName"]; found {
		err = json.Unmarshal(raw, &a.NfInstanceName)
		if err != nil {
			return fmt.Errorf("error reading 'nfInstanceName': %w", err)
		}
		delete(object, "nfInstanceName")
	}

	if raw, found := object["nfProfileChangesInd"]; found {
		err = json.Unmarshal(raw, &a.NfProfileChangesInd)
		if err != nil {
			return fmt.Errorf("error reading 'nfProfileChangesInd': %w", err)
		}
		delete(object, "nfProfileChangesInd")
	}

	if raw, found := object["nfProfileChangesSupportInd"]; found {
		err = json.Unmarshal(raw, &a.NfProfileChangesSupportInd)
		if err != nil {
			return fmt.Errorf("error reading 'nfProfileChangesSupportInd': %w", err)
		}
		delete(object, "nfProfileChangesSupportInd")
	}

	if raw, found := object["nfServiceList"]; found {
		err = json.Unmarshal(raw, &a.NfServiceList)
		if err != nil {
			return fmt.Errorf("error reading 'nfServiceList': %w", err)
		}
		delete(object, "nfServiceList")
	}

	if raw, found := object["nfServicePersistence"]; found {
		err = json.Unmarshal(raw, &a.NfServicePersistence)
		if err != nil {
			return fmt.Errorf("error reading 'nfServicePersistence': %w", err)
		}
		delete(object, "nfServicePersistence")
	}

	if raw, found := object["nfServices"]; found {
		err = json.Unmarshal(raw, &a.NfServices)
		if err != nil {
			return fmt.Errorf("error reading 'nfServices': %w", err)
		}
		delete(object, "nfServices")
	}

	if raw, found := object["nfSetIdList"]; found {
		err = json.Unmarshal(raw, &a.NfSetIdList)
		if err != nil {
			return fmt.Errorf("error reading 'nfSetIdList': %w", err)
		}
		delete(object, "nfSetIdList")
	}

	if raw, found := object["nfSetRecoveryTimeList"]; found {
		err = json.Unmarshal(raw, &a.NfSetRecoveryTimeList)
		if err != nil {
			return fmt.Errorf("error reading 'nfSetRecoveryTimeList': %w", err)
		}
		delete(object, "nfSetRecoveryTimeList")
	}

	if raw, found := object["nfStatus"]; found {
		err = json.Unmarshal(raw, &a.NfStatus)
		if err != nil {
			return fmt.Errorf("error reading 'nfStatus': %w", err)
		}
		delete(object, "nfStatus")
	}

	if raw, found := object["nfType"]; found {
		err = json.Unmarshal(raw, &a.NfType)
		if err != nil {
			return fmt.Errorf("error reading 'nfType': %w", err)
		}
		delete(object, "nfType")
	}

	if raw, found := object["nrfInfo"]; found {
		err = json.Unmarshal(raw, &a.NrfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'nrfInfo': %w", err)
		}
		delete(object, "nrfInfo")
	}

	if raw, found := object["nsiList"]; found {
		err = json.Unmarshal(raw, &a.NsiList)
		if err != nil {
			return fmt.Errorf("error reading 'nsiList': %w", err)
		}
		delete(object, "nsiList")
	}

	if raw, found := object["nwdafInfo"]; found {
		err = json.Unmarshal(raw, &a.NwdafInfo)
		if err != nil {
			return fmt.Errorf("error reading 'nwdafInfo': %w", err)
		}
		delete(object, "nwdafInfo")
	}

	if raw, found := object["olcHSupportInd"]; found {
		err = json.Unmarshal(raw, &a.OlcHSupportInd)
		if err != nil {
			return fmt.Errorf("error reading 'olcHSupportInd': %w", err)
		}
		delete(object, "olcHSupportInd")
	}

	if raw, found := object["pcfInfo"]; found {
		err = json.Unmarshal(raw, &a.PcfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'pcfInfo': %w", err)
		}
		delete(object, "pcfInfo")
	}

	if raw, found := object["pcfInfoList"]; found {
		err = json.Unmarshal(raw, &a.PcfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'pcfInfoList': %w", err)
		}
		delete(object, "pcfInfoList")
	}

	if raw, found := object["pcscfInfoList"]; found {
		err = json.Unmarshal(raw, &a.PcscfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'pcscfInfoList': %w", err)
		}
		delete(object, "pcscfInfoList")
	}

	if raw, found := object["perPlmnSnssaiList"]; found {
		err = json.Unmarshal(raw, &a.PerPlmnSnssaiList)
		if err != nil {
			return fmt.Errorf("error reading 'perPlmnSnssaiList': %w", err)
		}
		delete(object, "perPlmnSnssaiList")
	}

	if raw, found := object["plmnList"]; found {
		err = json.Unmarshal(raw, &a.PlmnList)
		if err != nil {
			return fmt.Errorf("error reading 'plmnList': %w", err)
		}
		delete(object, "plmnList")
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &a.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
		delete(object, "priority")
	}

	if raw, found := object["recoveryTime"]; found {
		err = json.Unmarshal(raw, &a.RecoveryTime)
		if err != nil {
			return fmt.Errorf("error reading 'recoveryTime': %w", err)
		}
		delete(object, "recoveryTime")
	}

	if raw, found := object["sNssais"]; found {
		err = json.Unmarshal(raw, &a.SNssais)
		if err != nil {
			return fmt.Errorf("error reading 'sNssais': %w", err)
		}
		delete(object, "sNssais")
	}

	if raw, found := object["scpDomains"]; found {
		err = json.Unmarshal(raw, &a.ScpDomains)
		if err != nil {
			return fmt.Errorf("error reading 'scpDomains': %w", err)
		}
		delete(object, "scpDomains")
	}

	if raw, found := object["scpInfo"]; found {
		err = json.Unmarshal(raw, &a.ScpInfo)
		if err != nil {
			return fmt.Errorf("error reading 'scpInfo': %w", err)
		}
		delete(object, "scpInfo")
	}

	if raw, found := object["serviceSetRecoveryTimeList"]; found {
		err = json.Unmarshal(raw, &a.ServiceSetRecoveryTimeList)
		if err != nil {
			return fmt.Errorf("error reading 'serviceSetRecoveryTimeList': %w", err)
		}
		delete(object, "serviceSetRecoveryTimeList")
	}

	if raw, found := object["servingScope"]; found {
		err = json.Unmarshal(raw, &a.ServingScope)
		if err != nil {
			return fmt.Errorf("error reading 'servingScope': %w", err)
		}
		delete(object, "servingScope")
	}

	if raw, found := object["smfInfo"]; found {
		err = json.Unmarshal(raw, &a.SmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'smfInfo': %w", err)
		}
		delete(object, "smfInfo")
	}

	if raw, found := object["smfInfoList"]; found {
		err = json.Unmarshal(raw, &a.SmfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'smfInfoList': %w", err)
		}
		delete(object, "smfInfoList")
	}

	if raw, found := object["snpnList"]; found {
		err = json.Unmarshal(raw, &a.SnpnList)
		if err != nil {
			return fmt.Errorf("error reading 'snpnList': %w", err)
		}
		delete(object, "snpnList")
	}

	if raw, found := object["udmInfo"]; found {
		err = json.Unmarshal(raw, &a.UdmInfo)
		if err != nil {
			return fmt.Errorf("error reading 'udmInfo': %w", err)
		}
		delete(object, "udmInfo")
	}

	if raw, found := object["udmInfoList"]; found {
		err = json.Unmarshal(raw, &a.UdmInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'udmInfoList': %w", err)
		}
		delete(object, "udmInfoList")
	}

	if raw, found := object["udrInfo"]; found {
		err = json.Unmarshal(raw, &a.UdrInfo)
		if err != nil {
			return fmt.Errorf("error reading 'udrInfo': %w", err)
		}
		delete(object, "udrInfo")
	}

	if raw, found := object["udrInfoList"]; found {
		err = json.Unmarshal(raw, &a.UdrInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'udrInfoList': %w", err)
		}
		delete(object, "udrInfoList")
	}

	if raw, found := object["udsfInfo"]; found {
		err = json.Unmarshal(raw, &a.UdsfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'udsfInfo': %w", err)
		}
		delete(object, "udsfInfo")
	}

	if raw, found := object["udsfInfoList"]; found {
		err = json.Unmarshal(raw, &a.UdsfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'udsfInfoList': %w", err)
		}
		delete(object, "udsfInfoList")
	}

	if raw, found := object["upfInfo"]; found {
		err = json.Unmarshal(raw, &a.UpfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'upfInfo': %w", err)
		}
		delete(object, "upfInfo")
	}

	if raw, found := object["upfInfoList"]; found {
		err = json.Unmarshal(raw, &a.UpfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'upfInfoList': %w", err)
		}
		delete(object, "upfInfoList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NotificationData_NfProfile to handle AdditionalProperties
func (a NotificationData_NfProfile) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AllowedNfDomains) != 0 {
		object["allowedNfDomains"], err = json.Marshal(a.AllowedNfDomains)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedNfDomains': %w", err)
		}
	}

	if len(a.AllowedNfTypes) != 0 {
		object["allowedNfTypes"], err = json.Marshal(a.AllowedNfTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedNfTypes': %w", err)
		}
	}

	if len(a.AllowedNssais) != 0 {
		object["allowedNssais"], err = json.Marshal(a.AllowedNssais)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedNssais': %w", err)
		}
	}

	if len(a.AllowedPlmns) != 0 {
		object["allowedPlmns"], err = json.Marshal(a.AllowedPlmns)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedPlmns': %w", err)
		}
	}

	if len(a.AllowedSnpns) != 0 {
		object["allowedSnpns"], err = json.Marshal(a.AllowedSnpns)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allowedSnpns': %w", err)
		}
	}

	if a.AmfInfo != nil {
		object["amfInfo"], err = json.Marshal(a.AmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'amfInfo': %w", err)
		}
	}

	if a.AmfInfoList != nil {
		object["amfInfoList"], err = json.Marshal(a.AmfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'amfInfoList': %w", err)
		}
	}

	if a.AusfInfo != nil {
		object["ausfInfo"], err = json.Marshal(a.AusfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ausfInfo': %w", err)
		}
	}

	if a.AusfInfoList != nil {
		object["ausfInfoList"], err = json.Marshal(a.AusfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ausfInfoList': %w", err)
		}
	}

	if a.BsfInfo != nil {
		object["bsfInfo"], err = json.Marshal(a.BsfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bsfInfo': %w", err)
		}
	}

	if a.BsfInfoList != nil {
		object["bsfInfoList"], err = json.Marshal(a.BsfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bsfInfoList': %w", err)
		}
	}

	if a.Capacity != nil {
		object["capacity"], err = json.Marshal(a.Capacity)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capacity': %w", err)
		}
	}

	if a.ChfInfo != nil {
		object["chfInfo"], err = json.Marshal(a.ChfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'chfInfo': %w", err)
		}
	}

	if a.ChfInfoList != nil {
		object["chfInfoList"], err = json.Marshal(a.ChfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'chfInfoList': %w", err)
		}
	}

	if a.CustomInfo != nil {
		object["customInfo"], err = json.Marshal(a.CustomInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'customInfo': %w", err)
		}
	}

	if a.DefaultNotificationSubscriptions != nil {
		object["defaultNotificationSubscriptions"], err = json.Marshal(a.DefaultNotificationSubscriptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'defaultNotificationSubscriptions': %w", err)
		}
	}

	if a.Fqdn != nil {
		object["fqdn"], err = json.Marshal(a.Fqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fqdn': %w", err)
		}
	}

	if a.GmlcInfo != nil {
		object["gmlcInfo"], err = json.Marshal(a.GmlcInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gmlcInfo': %w", err)
		}
	}

	if a.HeartBeatTimer != nil {
		object["heartBeatTimer"], err = json.Marshal(a.HeartBeatTimer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'heartBeatTimer': %w", err)
		}
	}

	if a.HssInfoList != nil {
		object["hssInfoList"], err = json.Marshal(a.HssInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hssInfoList': %w", err)
		}
	}

	if a.InterPlmnFqdn != nil {
		object["interPlmnFqdn"], err = json.Marshal(a.InterPlmnFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'interPlmnFqdn': %w", err)
		}
	}

	if len(a.Ipv4Addresses) != 0 {
		object["ipv4Addresses"], err = json.Marshal(a.Ipv4Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4Addresses': %w", err)
		}
	}

	if len(a.Ipv6Addresses) != 0 {
		object["ipv6Addresses"], err = json.Marshal(a.Ipv6Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6Addresses': %w", err)
		}
	}

	if a.LcHSupportInd != nil {
		object["lcHSupportInd"], err = json.Marshal(a.LcHSupportInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lcHSupportInd': %w", err)
		}
	}

	if a.LmfInfo != nil {
		object["lmfInfo"], err = json.Marshal(a.LmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lmfInfo': %w", err)
		}
	}

	if a.Load != nil {
		object["load"], err = json.Marshal(a.Load)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'load': %w", err)
		}
	}

	if a.LoadTimeStamp != nil {
		object["loadTimeStamp"], err = json.Marshal(a.LoadTimeStamp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'loadTimeStamp': %w", err)
		}
	}

	if a.Locality != nil {
		object["locality"], err = json.Marshal(a.Locality)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'locality': %w", err)
		}
	}

	if a.NefInfo != nil {
		object["nefInfo"], err = json.Marshal(a.NefInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nefInfo': %w", err)
		}
	}

	object["nfInstanceId"], err = json.Marshal(a.NfInstanceId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfInstanceId': %w", err)
	}

	if a.NfInstanceName != nil {
		object["nfInstanceName"], err = json.Marshal(a.NfInstanceName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfInstanceName': %w", err)
		}
	}

	if a.NfProfileChangesInd != nil {
		object["nfProfileChangesInd"], err = json.Marshal(a.NfProfileChangesInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfProfileChangesInd': %w", err)
		}
	}

	if a.NfProfileChangesSupportInd != nil {
		object["nfProfileChangesSupportInd"], err = json.Marshal(a.NfProfileChangesSupportInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfProfileChangesSupportInd': %w", err)
		}
	}

	if a.NfServiceList != nil {
		object["nfServiceList"], err = json.Marshal(a.NfServiceList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServiceList': %w", err)
		}
	}

	if a.NfServicePersistence != nil {
		object["nfServicePersistence"], err = json.Marshal(a.NfServicePersistence)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServicePersistence': %w", err)
		}
	}

	if a.NfServices != nil {
		object["nfServices"], err = json.Marshal(a.NfServices)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfServices': %w", err)
		}
	}

	if len(a.NfSetIdList) != 0 {
		object["nfSetIdList"], err = json.Marshal(a.NfSetIdList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfSetIdList': %w", err)
		}
	}

	if a.NfSetRecoveryTimeList != nil {
		object["nfSetRecoveryTimeList"], err = json.Marshal(a.NfSetRecoveryTimeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nfSetRecoveryTimeList': %w", err)
		}
	}

	object["nfStatus"], err = json.Marshal(a.NfStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfStatus': %w", err)
	}

	object["nfType"], err = json.Marshal(a.NfType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfType': %w", err)
	}

	if a.NrfInfo != nil {
		object["nrfInfo"], err = json.Marshal(a.NrfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nrfInfo': %w", err)
		}
	}

	if len(a.NsiList) != 0 {
		object["nsiList"], err = json.Marshal(a.NsiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nsiList': %w", err)
		}
	}

	if a.NwdafInfo != nil {
		object["nwdafInfo"], err = json.Marshal(a.NwdafInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nwdafInfo': %w", err)
		}
	}

	if a.OlcHSupportInd != nil {
		object["olcHSupportInd"], err = json.Marshal(a.OlcHSupportInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'olcHSupportInd': %w", err)
		}
	}

	if a.PcfInfo != nil {
		object["pcfInfo"], err = json.Marshal(a.PcfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pcfInfo': %w", err)
		}
	}

	if a.PcfInfoList != nil {
		object["pcfInfoList"], err = json.Marshal(a.PcfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pcfInfoList': %w", err)
		}
	}

	if a.PcscfInfoList != nil {
		object["pcscfInfoList"], err = json.Marshal(a.PcscfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pcscfInfoList': %w", err)
		}
	}

	if len(a.PerPlmnSnssaiList) != 0 {
		object["perPlmnSnssaiList"], err = json.Marshal(a.PerPlmnSnssaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'perPlmnSnssaiList': %w", err)
		}
	}

	if len(a.PlmnList) != 0 {
		object["plmnList"], err = json.Marshal(a.PlmnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'plmnList': %w", err)
		}
	}

	if a.Priority != nil {
		object["priority"], err = json.Marshal(a.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	if a.RecoveryTime != nil {
		object["recoveryTime"], err = json.Marshal(a.RecoveryTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recoveryTime': %w", err)
		}
	}

	if len(a.SNssais) != 0 {
		object["sNssais"], err = json.Marshal(a.SNssais)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sNssais': %w", err)
		}
	}

	if len(a.ScpDomains) != 0 {
		object["scpDomains"], err = json.Marshal(a.ScpDomains)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpDomains': %w", err)
		}
	}

	if a.ScpInfo != nil {
		object["scpInfo"], err = json.Marshal(a.ScpInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpInfo': %w", err)
		}
	}

	if a.ServiceSetRecoveryTimeList != nil {
		object["serviceSetRecoveryTimeList"], err = json.Marshal(a.ServiceSetRecoveryTimeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'serviceSetRecoveryTimeList': %w", err)
		}
	}

	if len(a.ServingScope) != 0 {
		object["servingScope"], err = json.Marshal(a.ServingScope)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingScope': %w", err)
		}
	}

	if a.SmfInfo != nil {
		object["smfInfo"], err = json.Marshal(a.SmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'smfInfo': %w", err)
		}
	}

	if a.SmfInfoList != nil {
		object["smfInfoList"], err = json.Marshal(a.SmfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'smfInfoList': %w", err)
		}
	}

	if len(a.SnpnList) != 0 {
		object["snpnList"], err = json.Marshal(a.SnpnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'snpnList': %w", err)
		}
	}

	if a.UdmInfo != nil {
		object["udmInfo"], err = json.Marshal(a.UdmInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udmInfo': %w", err)
		}
	}

	if a.UdmInfoList != nil {
		object["udmInfoList"], err = json.Marshal(a.UdmInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udmInfoList': %w", err)
		}
	}

	if a.UdrInfo != nil {
		object["udrInfo"], err = json.Marshal(a.UdrInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udrInfo': %w", err)
		}
	}

	if a.UdrInfoList != nil {
		object["udrInfoList"], err = json.Marshal(a.UdrInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udrInfoList': %w", err)
		}
	}

	if a.UdsfInfo != nil {
		object["udsfInfo"], err = json.Marshal(a.UdsfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udsfInfo': %w", err)
		}
	}

	if a.UdsfInfoList != nil {
		object["udsfInfoList"], err = json.Marshal(a.UdsfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'udsfInfoList': %w", err)
		}
	}

	if a.UpfInfo != nil {
		object["upfInfo"], err = json.Marshal(a.UpfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upfInfo': %w", err)
		}
	}

	if a.UpfInfoList != nil {
		object["upfInfoList"], err = json.Marshal(a.UpfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'upfInfoList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NrfInfo. Returns the specified
// element and whether it was found
func (a NrfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NrfInfo
func (a *NrfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NrfInfo to handle AdditionalProperties
func (a *NrfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["servedAmfInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedAmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedAmfInfo': %w", err)
		}
		delete(object, "servedAmfInfo")
	}

	if raw, found := object["servedAmfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedAmfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedAmfInfoList': %w", err)
		}
		delete(object, "servedAmfInfoList")
	}

	if raw, found := object["servedAusfInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedAusfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedAusfInfo': %w", err)
		}
		delete(object, "servedAusfInfo")
	}

	if raw, found := object["servedAusfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedAusfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedAusfInfoList': %w", err)
		}
		delete(object, "servedAusfInfoList")
	}

	if raw, found := object["servedBsfInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedBsfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedBsfInfo': %w", err)
		}
		delete(object, "servedBsfInfo")
	}

	if raw, found := object["servedBsfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedBsfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedBsfInfoList': %w", err)
		}
		delete(object, "servedBsfInfoList")
	}

	if raw, found := object["servedChfInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedChfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedChfInfo': %w", err)
		}
		delete(object, "servedChfInfo")
	}

	if raw, found := object["servedChfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedChfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedChfInfoList': %w", err)
		}
		delete(object, "servedChfInfoList")
	}

	if raw, found := object["servedGmlcInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedGmlcInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedGmlcInfo': %w", err)
		}
		delete(object, "servedGmlcInfo")
	}

	if raw, found := object["servedHssInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedHssInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedHssInfoList': %w", err)
		}
		delete(object, "servedHssInfoList")
	}

	if raw, found := object["servedLmfInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedLmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedLmfInfo': %w", err)
		}
		delete(object, "servedLmfInfo")
	}

	if raw, found := object["servedNefInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedNefInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedNefInfo': %w", err)
		}
		delete(object, "servedNefInfo")
	}

	if raw, found := object["servedNfInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedNfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedNfInfo': %w", err)
		}
		delete(object, "servedNfInfo")
	}

	if raw, found := object["servedNwdafInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedNwdafInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedNwdafInfo': %w", err)
		}
		delete(object, "servedNwdafInfo")
	}

	if raw, found := object["servedPcfInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedPcfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedPcfInfo': %w", err)
		}
		delete(object, "servedPcfInfo")
	}

	if raw, found := object["servedPcfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedPcfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedPcfInfoList': %w", err)
		}
		delete(object, "servedPcfInfoList")
	}

	if raw, found := object["servedPcscfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedPcscfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedPcscfInfoList': %w", err)
		}
		delete(object, "servedPcscfInfoList")
	}

	if raw, found := object["servedScpInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedScpInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedScpInfoList': %w", err)
		}
		delete(object, "servedScpInfoList")
	}

	if raw, found := object["servedSmfInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedSmfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedSmfInfo': %w", err)
		}
		delete(object, "servedSmfInfo")
	}

	if raw, found := object["servedSmfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedSmfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedSmfInfoList': %w", err)
		}
		delete(object, "servedSmfInfoList")
	}

	if raw, found := object["servedUdmInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedUdmInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedUdmInfo': %w", err)
		}
		delete(object, "servedUdmInfo")
	}

	if raw, found := object["servedUdmInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedUdmInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedUdmInfoList': %w", err)
		}
		delete(object, "servedUdmInfoList")
	}

	if raw, found := object["servedUdrInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedUdrInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedUdrInfo': %w", err)
		}
		delete(object, "servedUdrInfo")
	}

	if raw, found := object["servedUdrInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedUdrInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedUdrInfoList': %w", err)
		}
		delete(object, "servedUdrInfoList")
	}

	if raw, found := object["servedUdsfInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedUdsfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedUdsfInfo': %w", err)
		}
		delete(object, "servedUdsfInfo")
	}

	if raw, found := object["servedUdsfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedUdsfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedUdsfInfoList': %w", err)
		}
		delete(object, "servedUdsfInfoList")
	}

	if raw, found := object["servedUpfInfo"]; found {
		err = json.Unmarshal(raw, &a.ServedUpfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'servedUpfInfo': %w", err)
		}
		delete(object, "servedUpfInfo")
	}

	if raw, found := object["servedUpfInfoList"]; found {
		err = json.Unmarshal(raw, &a.ServedUpfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'servedUpfInfoList': %w", err)
		}
		delete(object, "servedUpfInfoList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NrfInfo to handle AdditionalProperties
func (a NrfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ServedAmfInfo != nil {
		object["servedAmfInfo"], err = json.Marshal(a.ServedAmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedAmfInfo': %w", err)
		}
	}

	if a.ServedAmfInfoList != nil {
		object["servedAmfInfoList"], err = json.Marshal(a.ServedAmfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedAmfInfoList': %w", err)
		}
	}

	if a.ServedAusfInfo != nil {
		object["servedAusfInfo"], err = json.Marshal(a.ServedAusfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedAusfInfo': %w", err)
		}
	}

	if a.ServedAusfInfoList != nil {
		object["servedAusfInfoList"], err = json.Marshal(a.ServedAusfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedAusfInfoList': %w", err)
		}
	}

	if a.ServedBsfInfo != nil {
		object["servedBsfInfo"], err = json.Marshal(a.ServedBsfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedBsfInfo': %w", err)
		}
	}

	if a.ServedBsfInfoList != nil {
		object["servedBsfInfoList"], err = json.Marshal(a.ServedBsfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedBsfInfoList': %w", err)
		}
	}

	if a.ServedChfInfo != nil {
		object["servedChfInfo"], err = json.Marshal(a.ServedChfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedChfInfo': %w", err)
		}
	}

	if a.ServedChfInfoList != nil {
		object["servedChfInfoList"], err = json.Marshal(a.ServedChfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedChfInfoList': %w", err)
		}
	}

	if a.ServedGmlcInfo != nil {
		object["servedGmlcInfo"], err = json.Marshal(a.ServedGmlcInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedGmlcInfo': %w", err)
		}
	}

	if a.ServedHssInfoList != nil {
		object["servedHssInfoList"], err = json.Marshal(a.ServedHssInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedHssInfoList': %w", err)
		}
	}

	if a.ServedLmfInfo != nil {
		object["servedLmfInfo"], err = json.Marshal(a.ServedLmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedLmfInfo': %w", err)
		}
	}

	if a.ServedNefInfo != nil {
		object["servedNefInfo"], err = json.Marshal(a.ServedNefInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedNefInfo': %w", err)
		}
	}

	if a.ServedNfInfo != nil {
		object["servedNfInfo"], err = json.Marshal(a.ServedNfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedNfInfo': %w", err)
		}
	}

	if a.ServedNwdafInfo != nil {
		object["servedNwdafInfo"], err = json.Marshal(a.ServedNwdafInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedNwdafInfo': %w", err)
		}
	}

	if a.ServedPcfInfo != nil {
		object["servedPcfInfo"], err = json.Marshal(a.ServedPcfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedPcfInfo': %w", err)
		}
	}

	if a.ServedPcfInfoList != nil {
		object["servedPcfInfoList"], err = json.Marshal(a.ServedPcfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedPcfInfoList': %w", err)
		}
	}

	if a.ServedPcscfInfoList != nil {
		object["servedPcscfInfoList"], err = json.Marshal(a.ServedPcscfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedPcscfInfoList': %w", err)
		}
	}

	if a.ServedScpInfoList != nil {
		object["servedScpInfoList"], err = json.Marshal(a.ServedScpInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedScpInfoList': %w", err)
		}
	}

	if a.ServedSmfInfo != nil {
		object["servedSmfInfo"], err = json.Marshal(a.ServedSmfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedSmfInfo': %w", err)
		}
	}

	if a.ServedSmfInfoList != nil {
		object["servedSmfInfoList"], err = json.Marshal(a.ServedSmfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedSmfInfoList': %w", err)
		}
	}

	if a.ServedUdmInfo != nil {
		object["servedUdmInfo"], err = json.Marshal(a.ServedUdmInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedUdmInfo': %w", err)
		}
	}

	if a.ServedUdmInfoList != nil {
		object["servedUdmInfoList"], err = json.Marshal(a.ServedUdmInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedUdmInfoList': %w", err)
		}
	}

	if a.ServedUdrInfo != nil {
		object["servedUdrInfo"], err = json.Marshal(a.ServedUdrInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedUdrInfo': %w", err)
		}
	}

	if a.ServedUdrInfoList != nil {
		object["servedUdrInfoList"], err = json.Marshal(a.ServedUdrInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedUdrInfoList': %w", err)
		}
	}

	if a.ServedUdsfInfo != nil {
		object["servedUdsfInfo"], err = json.Marshal(a.ServedUdsfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedUdsfInfo': %w", err)
		}
	}

	if a.ServedUdsfInfoList != nil {
		object["servedUdsfInfoList"], err = json.Marshal(a.ServedUdsfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedUdsfInfoList': %w", err)
		}
	}

	if a.ServedUpfInfo != nil {
		object["servedUpfInfo"], err = json.Marshal(a.ServedUpfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedUpfInfo': %w", err)
		}
	}

	if a.ServedUpfInfoList != nil {
		object["servedUpfInfoList"], err = json.Marshal(a.ServedUpfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedUpfInfoList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NwdafCond. Returns the specified
// element and whether it was found
func (a NwdafCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NwdafCond
func (a *NwdafCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NwdafCond to handle AdditionalProperties
func (a *NwdafCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["analyticsIds"]; found {
		err = json.Unmarshal(raw, &a.AnalyticsIds)
		if err != nil {
			return fmt.Errorf("error reading 'analyticsIds': %w", err)
		}
		delete(object, "analyticsIds")
	}

	if raw, found := object["conditionType"]; found {
		err = json.Unmarshal(raw, &a.ConditionType)
		if err != nil {
			return fmt.Errorf("error reading 'conditionType': %w", err)
		}
		delete(object, "conditionType")
	}

	if raw, found := object["snssaiList"]; found {
		err = json.Unmarshal(raw, &a.SnssaiList)
		if err != nil {
			return fmt.Errorf("error reading 'snssaiList': %w", err)
		}
		delete(object, "snssaiList")
	}

	if raw, found := object["taiList"]; found {
		err = json.Unmarshal(raw, &a.TaiList)
		if err != nil {
			return fmt.Errorf("error reading 'taiList': %w", err)
		}
		delete(object, "taiList")
	}

	if raw, found := object["taiRangeList"]; found {
		err = json.Unmarshal(raw, &a.TaiRangeList)
		if err != nil {
			return fmt.Errorf("error reading 'taiRangeList': %w", err)
		}
		delete(object, "taiRangeList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NwdafCond to handle AdditionalProperties
func (a NwdafCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AnalyticsIds) != 0 {
		object["analyticsIds"], err = json.Marshal(a.AnalyticsIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'analyticsIds': %w", err)
		}
	}

	object["conditionType"], err = json.Marshal(a.ConditionType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'conditionType': %w", err)
	}

	if len(a.SnssaiList) != 0 {
		object["snssaiList"], err = json.Marshal(a.SnssaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'snssaiList': %w", err)
		}
	}

	if len(a.TaiList) != 0 {
		object["taiList"], err = json.Marshal(a.TaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'taiList': %w", err)
		}
	}

	if len(a.TaiRangeList) != 0 {
		object["taiRangeList"], err = json.Marshal(a.TaiRangeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'taiRangeList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NwdafInfo. Returns the specified
// element and whether it was found
func (a NwdafInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NwdafInfo
func (a *NwdafInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NwdafInfo to handle AdditionalProperties
func (a *NwdafInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["eventIds"]; found {
		err = json.Unmarshal(raw, &a.EventIds)
		if err != nil {
			return fmt.Errorf("error reading 'eventIds': %w", err)
		}
		delete(object, "eventIds")
	}

	if raw, found := object["nwdafEvents"]; found {
		err = json.Unmarshal(raw, &a.NwdafEvents)
		if err != nil {
			return fmt.Errorf("error reading 'nwdafEvents': %w", err)
		}
		delete(object, "nwdafEvents")
	}

	if raw, found := object["taiList"]; found {
		err = json.Unmarshal(raw, &a.TaiList)
		if err != nil {
			return fmt.Errorf("error reading 'taiList': %w", err)
		}
		delete(object, "taiList")
	}

	if raw, found := object["taiRangeList"]; found {
		err = json.Unmarshal(raw, &a.TaiRangeList)
		if err != nil {
			return fmt.Errorf("error reading 'taiRangeList': %w", err)
		}
		delete(object, "taiRangeList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NwdafInfo to handle AdditionalProperties
func (a NwdafInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.EventIds) != 0 {
		object["eventIds"], err = json.Marshal(a.EventIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'eventIds': %w", err)
		}
	}

	if len(a.NwdafEvents) != 0 {
		object["nwdafEvents"], err = json.Marshal(a.NwdafEvents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nwdafEvents': %w", err)
		}
	}

	if len(a.TaiList) != 0 {
		object["taiList"], err = json.Marshal(a.TaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'taiList': %w", err)
		}
	}

	if len(a.TaiRangeList) != 0 {
		object["taiRangeList"], err = json.Marshal(a.TaiRangeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'taiRangeList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OptionsResponse. Returns the specified
// element and whether it was found
func (a OptionsResponse) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OptionsResponse
func (a *OptionsResponse) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OptionsResponse to handle AdditionalProperties
func (a *OptionsResponse) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["supportedFeatures"]; found {
		err = json.Unmarshal(raw, &a.SupportedFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'supportedFeatures': %w", err)
		}
		delete(object, "supportedFeatures")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OptionsResponse to handle AdditionalProperties
func (a OptionsResponse) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.SupportedFeatures != nil {
		object["supportedFeatures"], err = json.Marshal(a.SupportedFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supportedFeatures': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PcfInfo. Returns the specified
// element and whether it was found
func (a PcfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PcfInfo
func (a *PcfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PcfInfo to handle AdditionalProperties
func (a *PcfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dnnList"]; found {
		err = json.Unmarshal(raw, &a.DnnList)
		if err != nil {
			return fmt.Errorf("error reading 'dnnList': %w", err)
		}
		delete(object, "dnnList")
	}

	if raw, found := object["gpsiRanges"]; found {
		err = json.Unmarshal(raw, &a.GpsiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'gpsiRanges': %w", err)
		}
		delete(object, "gpsiRanges")
	}

	if raw, found := object["groupId"]; found {
		err = json.Unmarshal(raw, &a.GroupId)
		if err != nil {
			return fmt.Errorf("error reading 'groupId': %w", err)
		}
		delete(object, "groupId")
	}

	if raw, found := object["rxDiamHost"]; found {
		err = json.Unmarshal(raw, &a.RxDiamHost)
		if err != nil {
			return fmt.Errorf("error reading 'rxDiamHost': %w", err)
		}
		delete(object, "rxDiamHost")
	}

	if raw, found := object["rxDiamRealm"]; found {
		err = json.Unmarshal(raw, &a.RxDiamRealm)
		if err != nil {
			return fmt.Errorf("error reading 'rxDiamRealm': %w", err)
		}
		delete(object, "rxDiamRealm")
	}

	if raw, found := object["supiRanges"]; found {
		err = json.Unmarshal(raw, &a.SupiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'supiRanges': %w", err)
		}
		delete(object, "supiRanges")
	}

	if raw, found := object["v2xSupportInd"]; found {
		err = json.Unmarshal(raw, &a.V2xSupportInd)
		if err != nil {
			return fmt.Errorf("error reading 'v2xSupportInd': %w", err)
		}
		delete(object, "v2xSupportInd")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PcfInfo to handle AdditionalProperties
func (a PcfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.DnnList) != 0 {
		object["dnnList"], err = json.Marshal(a.DnnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dnnList': %w", err)
		}
	}

	if len(a.GpsiRanges) != 0 {
		object["gpsiRanges"], err = json.Marshal(a.GpsiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gpsiRanges': %w", err)
		}
	}

	if a.GroupId != nil {
		object["groupId"], err = json.Marshal(a.GroupId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupId': %w", err)
		}
	}

	if len(a.RxDiamHost) != 0 {
		object["rxDiamHost"], err = json.Marshal(a.RxDiamHost)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rxDiamHost': %w", err)
		}
	}

	if len(a.RxDiamRealm) != 0 {
		object["rxDiamRealm"], err = json.Marshal(a.RxDiamRealm)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rxDiamRealm': %w", err)
		}
	}

	if len(a.SupiRanges) != 0 {
		object["supiRanges"], err = json.Marshal(a.SupiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supiRanges': %w", err)
		}
	}

	if a.V2xSupportInd != nil {
		object["v2xSupportInd"], err = json.Marshal(a.V2xSupportInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'v2xSupportInd': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PcscfInfo. Returns the specified
// element and whether it was found
func (a PcscfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PcscfInfo
func (a *PcscfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PcscfInfo to handle AdditionalProperties
func (a *PcscfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accessType"]; found {
		err = json.Unmarshal(raw, &a.AccessType)
		if err != nil {
			return fmt.Errorf("error reading 'accessType': %w", err)
		}
		delete(object, "accessType")
	}

	if raw, found := object["dnnList"]; found {
		err = json.Unmarshal(raw, &a.DnnList)
		if err != nil {
			return fmt.Errorf("error reading 'dnnList': %w", err)
		}
		delete(object, "dnnList")
	}

	if raw, found := object["gmFqdn"]; found {
		err = json.Unmarshal(raw, &a.GmFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'gmFqdn': %w", err)
		}
		delete(object, "gmFqdn")
	}

	if raw, found := object["gmIpv4Addresses"]; found {
		err = json.Unmarshal(raw, &a.GmIpv4Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'gmIpv4Addresses': %w", err)
		}
		delete(object, "gmIpv4Addresses")
	}

	if raw, found := object["gmIpv6Addresses"]; found {
		err = json.Unmarshal(raw, &a.GmIpv6Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'gmIpv6Addresses': %w", err)
		}
		delete(object, "gmIpv6Addresses")
	}

	if raw, found := object["servedIpv4AddressRanges"]; found {
		err = json.Unmarshal(raw, &a.ServedIpv4AddressRanges)
		if err != nil {
			return fmt.Errorf("error reading 'servedIpv4AddressRanges': %w", err)
		}
		delete(object, "servedIpv4AddressRanges")
	}

	if raw, found := object["servedIpv6PrefixRanges"]; found {
		err = json.Unmarshal(raw, &a.ServedIpv6PrefixRanges)
		if err != nil {
			return fmt.Errorf("error reading 'servedIpv6PrefixRanges': %w", err)
		}
		delete(object, "servedIpv6PrefixRanges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PcscfInfo to handle AdditionalProperties
func (a PcscfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AccessType) != 0 {
		object["accessType"], err = json.Marshal(a.AccessType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accessType': %w", err)
		}
	}

	if len(a.DnnList) != 0 {
		object["dnnList"], err = json.Marshal(a.DnnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dnnList': %w", err)
		}
	}

	if a.GmFqdn != nil {
		object["gmFqdn"], err = json.Marshal(a.GmFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gmFqdn': %w", err)
		}
	}

	if len(a.GmIpv4Addresses) != 0 {
		object["gmIpv4Addresses"], err = json.Marshal(a.GmIpv4Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gmIpv4Addresses': %w", err)
		}
	}

	if len(a.GmIpv6Addresses) != 0 {
		object["gmIpv6Addresses"], err = json.Marshal(a.GmIpv6Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gmIpv6Addresses': %w", err)
		}
	}

	if len(a.ServedIpv4AddressRanges) != 0 {
		object["servedIpv4AddressRanges"], err = json.Marshal(a.ServedIpv4AddressRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedIpv4AddressRanges': %w", err)
		}
	}

	if len(a.ServedIpv6PrefixRanges) != 0 {
		object["servedIpv6PrefixRanges"], err = json.Marshal(a.ServedIpv6PrefixRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedIpv6PrefixRanges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PfdData. Returns the specified
// element and whether it was found
func (a PfdData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PfdData
func (a *PfdData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PfdData to handle AdditionalProperties
func (a *PfdData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["afIds"]; found {
		err = json.Unmarshal(raw, &a.AfIds)
		if err != nil {
			return fmt.Errorf("error reading 'afIds': %w", err)
		}
		delete(object, "afIds")
	}

	if raw, found := object["appIds"]; found {
		err = json.Unmarshal(raw, &a.AppIds)
		if err != nil {
			return fmt.Errorf("error reading 'appIds': %w", err)
		}
		delete(object, "appIds")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PfdData to handle AdditionalProperties
func (a PfdData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AfIds) != 0 {
		object["afIds"], err = json.Marshal(a.AfIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'afIds': %w", err)
		}
	}

	if len(a.AppIds) != 0 {
		object["appIds"], err = json.Marshal(a.AppIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'appIds': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PlmnRange. Returns the specified
// element and whether it was found
func (a PlmnRange) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PlmnRange
func (a *PlmnRange) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PlmnRange to handle AdditionalProperties
func (a *PlmnRange) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["end"]; found {
		err = json.Unmarshal(raw, &a.End)
		if err != nil {
			return fmt.Errorf("error reading 'end': %w", err)
		}
		delete(object, "end")
	}

	if raw, found := object["pattern"]; found {
		err = json.Unmarshal(raw, &a.Pattern)
		if err != nil {
			return fmt.Errorf("error reading 'pattern': %w", err)
		}
		delete(object, "pattern")
	}

	if raw, found := object["start"]; found {
		err = json.Unmarshal(raw, &a.Start)
		if err != nil {
			return fmt.Errorf("error reading 'start': %w", err)
		}
		delete(object, "start")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PlmnRange to handle AdditionalProperties
func (a PlmnRange) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.End) != 0 {
		object["end"], err = json.Marshal(a.End)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'end': %w", err)
		}
	}

	if a.Pattern != nil {
		object["pattern"], err = json.Marshal(a.Pattern)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pattern': %w", err)
		}
	}

	if len(a.Start) != 0 {
		object["start"], err = json.Marshal(a.Start)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PlmnSnssai. Returns the specified
// element and whether it was found
func (a PlmnSnssai) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PlmnSnssai
func (a *PlmnSnssai) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PlmnSnssai to handle AdditionalProperties
func (a *PlmnSnssai) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nid"]; found {
		err = json.Unmarshal(raw, &a.Nid)
		if err != nil {
			return fmt.Errorf("error reading 'nid': %w", err)
		}
		delete(object, "nid")
	}

	if raw, found := object["plmnId"]; found {
		err = json.Unmarshal(raw, &a.PlmnId)
		if err != nil {
			return fmt.Errorf("error reading 'plmnId': %w", err)
		}
		delete(object, "plmnId")
	}

	if raw, found := object["sNssaiList"]; found {
		err = json.Unmarshal(raw, &a.SNssaiList)
		if err != nil {
			return fmt.Errorf("error reading 'sNssaiList': %w", err)
		}
		delete(object, "sNssaiList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PlmnSnssai to handle AdditionalProperties
func (a PlmnSnssai) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.Nid) != 0 {
		object["nid"], err = json.Marshal(a.Nid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nid': %w", err)
		}
	}

	object["plmnId"], err = json.Marshal(a.PlmnId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'plmnId': %w", err)
	}

	object["sNssaiList"], err = json.Marshal(a.SNssaiList)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'sNssaiList': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ScpDomainCond. Returns the specified
// element and whether it was found
func (a ScpDomainCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ScpDomainCond
func (a *ScpDomainCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ScpDomainCond to handle AdditionalProperties
func (a *ScpDomainCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["scpDomains"]; found {
		err = json.Unmarshal(raw, &a.ScpDomains)
		if err != nil {
			return fmt.Errorf("error reading 'scpDomains': %w", err)
		}
		delete(object, "scpDomains")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ScpDomainCond to handle AdditionalProperties
func (a ScpDomainCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["scpDomains"], err = json.Marshal(a.ScpDomains)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'scpDomains': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ScpDomainInfo. Returns the specified
// element and whether it was found
func (a ScpDomainInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ScpDomainInfo
func (a *ScpDomainInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ScpDomainInfo to handle AdditionalProperties
func (a *ScpDomainInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["scpFqdn"]; found {
		err = json.Unmarshal(raw, &a.ScpFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'scpFqdn': %w", err)
		}
		delete(object, "scpFqdn")
	}

	if raw, found := object["scpIpEndPoints"]; found {
		err = json.Unmarshal(raw, &a.ScpIpEndPoints)
		if err != nil {
			return fmt.Errorf("error reading 'scpIpEndPoints': %w", err)
		}
		delete(object, "scpIpEndPoints")
	}

	if raw, found := object["scpPorts"]; found {
		err = json.Unmarshal(raw, &a.ScpPorts)
		if err != nil {
			return fmt.Errorf("error reading 'scpPorts': %w", err)
		}
		delete(object, "scpPorts")
	}

	if raw, found := object["scpPrefix"]; found {
		err = json.Unmarshal(raw, &a.ScpPrefix)
		if err != nil {
			return fmt.Errorf("error reading 'scpPrefix': %w", err)
		}
		delete(object, "scpPrefix")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ScpDomainInfo to handle AdditionalProperties
func (a ScpDomainInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ScpFqdn != nil {
		object["scpFqdn"], err = json.Marshal(a.ScpFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpFqdn': %w", err)
		}
	}

	if len(a.ScpIpEndPoints) != 0 {
		object["scpIpEndPoints"], err = json.Marshal(a.ScpIpEndPoints)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpIpEndPoints': %w", err)
		}
	}

	if a.ScpPorts != nil {
		object["scpPorts"], err = json.Marshal(a.ScpPorts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpPorts': %w", err)
		}
	}

	if a.ScpPrefix != nil {
		object["scpPrefix"], err = json.Marshal(a.ScpPrefix)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpPrefix': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ScpInfo. Returns the specified
// element and whether it was found
func (a ScpInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ScpInfo
func (a *ScpInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ScpInfo to handle AdditionalProperties
func (a *ScpInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["addressDomains"]; found {
		err = json.Unmarshal(raw, &a.AddressDomains)
		if err != nil {
			return fmt.Errorf("error reading 'addressDomains': %w", err)
		}
		delete(object, "addressDomains")
	}

	if raw, found := object["ipReachability"]; found {
		err = json.Unmarshal(raw, &a.IpReachability)
		if err != nil {
			return fmt.Errorf("error reading 'ipReachability': %w", err)
		}
		delete(object, "ipReachability")
	}

	if raw, found := object["ipv4AddrRanges"]; found {
		err = json.Unmarshal(raw, &a.Ipv4AddrRanges)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4AddrRanges': %w", err)
		}
		delete(object, "ipv4AddrRanges")
	}

	if raw, found := object["ipv4Addresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv4Addresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4Addresses': %w", err)
		}
		delete(object, "ipv4Addresses")
	}

	if raw, found := object["ipv6PrefixRanges"]; found {
		err = json.Unmarshal(raw, &a.Ipv6PrefixRanges)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6PrefixRanges': %w", err)
		}
		delete(object, "ipv6PrefixRanges")
	}

	if raw, found := object["ipv6Prefixes"]; found {
		err = json.Unmarshal(raw, &a.Ipv6Prefixes)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6Prefixes': %w", err)
		}
		delete(object, "ipv6Prefixes")
	}

	if raw, found := object["remotePlmnList"]; found {
		err = json.Unmarshal(raw, &a.RemotePlmnList)
		if err != nil {
			return fmt.Errorf("error reading 'remotePlmnList': %w", err)
		}
		delete(object, "remotePlmnList")
	}

	if raw, found := object["scpDomainInfoList"]; found {
		err = json.Unmarshal(raw, &a.ScpDomainInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'scpDomainInfoList': %w", err)
		}
		delete(object, "scpDomainInfoList")
	}

	if raw, found := object["scpPorts"]; found {
		err = json.Unmarshal(raw, &a.ScpPorts)
		if err != nil {
			return fmt.Errorf("error reading 'scpPorts': %w", err)
		}
		delete(object, "scpPorts")
	}

	if raw, found := object["scpPrefix"]; found {
		err = json.Unmarshal(raw, &a.ScpPrefix)
		if err != nil {
			return fmt.Errorf("error reading 'scpPrefix': %w", err)
		}
		delete(object, "scpPrefix")
	}

	if raw, found := object["servedNfSetIdList"]; found {
		err = json.Unmarshal(raw, &a.ServedNfSetIdList)
		if err != nil {
			return fmt.Errorf("error reading 'servedNfSetIdList': %w", err)
		}
		delete(object, "servedNfSetIdList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ScpInfo to handle AdditionalProperties
func (a ScpInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AddressDomains) != 0 {
		object["addressDomains"], err = json.Marshal(a.AddressDomains)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'addressDomains': %w", err)
		}
	}

	if a.IpReachability != nil {
		object["ipReachability"], err = json.Marshal(a.IpReachability)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipReachability': %w", err)
		}
	}

	if len(a.Ipv4AddrRanges) != 0 {
		object["ipv4AddrRanges"], err = json.Marshal(a.Ipv4AddrRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4AddrRanges': %w", err)
		}
	}

	if len(a.Ipv4Addresses) != 0 {
		object["ipv4Addresses"], err = json.Marshal(a.Ipv4Addresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4Addresses': %w", err)
		}
	}

	if len(a.Ipv6PrefixRanges) != 0 {
		object["ipv6PrefixRanges"], err = json.Marshal(a.Ipv6PrefixRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6PrefixRanges': %w", err)
		}
	}

	if len(a.Ipv6Prefixes) != 0 {
		object["ipv6Prefixes"], err = json.Marshal(a.Ipv6Prefixes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6Prefixes': %w", err)
		}
	}

	if len(a.RemotePlmnList) != 0 {
		object["remotePlmnList"], err = json.Marshal(a.RemotePlmnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'remotePlmnList': %w", err)
		}
	}

	if a.ScpDomainInfoList != nil {
		object["scpDomainInfoList"], err = json.Marshal(a.ScpDomainInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpDomainInfoList': %w", err)
		}
	}

	if a.ScpPorts != nil {
		object["scpPorts"], err = json.Marshal(a.ScpPorts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpPorts': %w", err)
		}
	}

	if a.ScpPrefix != nil {
		object["scpPrefix"], err = json.Marshal(a.ScpPrefix)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'scpPrefix': %w", err)
		}
	}

	if len(a.ServedNfSetIdList) != 0 {
		object["servedNfSetIdList"], err = json.Marshal(a.ServedNfSetIdList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servedNfSetIdList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ServiceNameCond. Returns the specified
// element and whether it was found
func (a ServiceNameCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ServiceNameCond
func (a *ServiceNameCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ServiceNameCond to handle AdditionalProperties
func (a *ServiceNameCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["serviceName"]; found {
		err = json.Unmarshal(raw, &a.ServiceName)
		if err != nil {
			return fmt.Errorf("error reading 'serviceName': %w", err)
		}
		delete(object, "serviceName")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ServiceNameCond to handle AdditionalProperties
func (a ServiceNameCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["serviceName"], err = json.Marshal(a.ServiceName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'serviceName': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmfInfo. Returns the specified
// element and whether it was found
func (a SmfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmfInfo
func (a *SmfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmfInfo to handle AdditionalProperties
func (a *SmfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accessType"]; found {
		err = json.Unmarshal(raw, &a.AccessType)
		if err != nil {
			return fmt.Errorf("error reading 'accessType': %w", err)
		}
		delete(object, "accessType")
	}

	if raw, found := object["pgwFqdn"]; found {
		err = json.Unmarshal(raw, &a.PgwFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'pgwFqdn': %w", err)
		}
		delete(object, "pgwFqdn")
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &a.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
		delete(object, "priority")
	}

	if raw, found := object["sNssaiSmfInfoList"]; found {
		err = json.Unmarshal(raw, &a.SNssaiSmfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'sNssaiSmfInfoList': %w", err)
		}
		delete(object, "sNssaiSmfInfoList")
	}

	if raw, found := object["taiList"]; found {
		err = json.Unmarshal(raw, &a.TaiList)
		if err != nil {
			return fmt.Errorf("error reading 'taiList': %w", err)
		}
		delete(object, "taiList")
	}

	if raw, found := object["taiRangeList"]; found {
		err = json.Unmarshal(raw, &a.TaiRangeList)
		if err != nil {
			return fmt.Errorf("error reading 'taiRangeList': %w", err)
		}
		delete(object, "taiRangeList")
	}

	if raw, found := object["vsmfSupportInd"]; found {
		err = json.Unmarshal(raw, &a.VsmfSupportInd)
		if err != nil {
			return fmt.Errorf("error reading 'vsmfSupportInd': %w", err)
		}
		delete(object, "vsmfSupportInd")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmfInfo to handle AdditionalProperties
func (a SmfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AccessType) != 0 {
		object["accessType"], err = json.Marshal(a.AccessType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accessType': %w", err)
		}
	}

	if a.PgwFqdn != nil {
		object["pgwFqdn"], err = json.Marshal(a.PgwFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pgwFqdn': %w", err)
		}
	}

	if a.Priority != nil {
		object["priority"], err = json.Marshal(a.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	object["sNssaiSmfInfoList"], err = json.Marshal(a.SNssaiSmfInfoList)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'sNssaiSmfInfoList': %w", err)
	}

	if len(a.TaiList) != 0 {
		object["taiList"], err = json.Marshal(a.TaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'taiList': %w", err)
		}
	}

	if len(a.TaiRangeList) != 0 {
		object["taiRangeList"], err = json.Marshal(a.TaiRangeList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'taiRangeList': %w", err)
		}
	}

	if a.VsmfSupportInd != nil {
		object["vsmfSupportInd"], err = json.Marshal(a.VsmfSupportInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vsmfSupportInd': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SnssaiSmfInfoItem. Returns the specified
// element and whether it was found
func (a SnssaiSmfInfoItem) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SnssaiSmfInfoItem
func (a *SnssaiSmfInfoItem) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SnssaiSmfInfoItem to handle AdditionalProperties
func (a *SnssaiSmfInfoItem) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dnnSmfInfoList"]; found {
		err = json.Unmarshal(raw, &a.DnnSmfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'dnnSmfInfoList': %w", err)
		}
		delete(object, "dnnSmfInfoList")
	}

	if raw, found := object["sNssai"]; found {
		err = json.Unmarshal(raw, &a.SNssai)
		if err != nil {
			return fmt.Errorf("error reading 'sNssai': %w", err)
		}
		delete(object, "sNssai")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SnssaiSmfInfoItem to handle AdditionalProperties
func (a SnssaiSmfInfoItem) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["dnnSmfInfoList"], err = json.Marshal(a.DnnSmfInfoList)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'dnnSmfInfoList': %w", err)
	}

	object["sNssai"], err = json.Marshal(a.SNssai)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'sNssai': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SnssaiUpfInfoItem. Returns the specified
// element and whether it was found
func (a SnssaiUpfInfoItem) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SnssaiUpfInfoItem
func (a *SnssaiUpfInfoItem) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SnssaiUpfInfoItem to handle AdditionalProperties
func (a *SnssaiUpfInfoItem) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dnnUpfInfoList"]; found {
		err = json.Unmarshal(raw, &a.DnnUpfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'dnnUpfInfoList': %w", err)
		}
		delete(object, "dnnUpfInfoList")
	}

	if raw, found := object["redundantTransport"]; found {
		err = json.Unmarshal(raw, &a.RedundantTransport)
		if err != nil {
			return fmt.Errorf("error reading 'redundantTransport': %w", err)
		}
		delete(object, "redundantTransport")
	}

	if raw, found := object["sNssai"]; found {
		err = json.Unmarshal(raw, &a.SNssai)
		if err != nil {
			return fmt.Errorf("error reading 'sNssai': %w", err)
		}
		delete(object, "sNssai")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SnssaiUpfInfoItem to handle AdditionalProperties
func (a SnssaiUpfInfoItem) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["dnnUpfInfoList"], err = json.Marshal(a.DnnUpfInfoList)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'dnnUpfInfoList': %w", err)
	}

	if a.RedundantTransport != nil {
		object["redundantTransport"], err = json.Marshal(a.RedundantTransport)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'redundantTransport': %w", err)
		}
	}

	object["sNssai"], err = json.Marshal(a.SNssai)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'sNssai': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SubscriptionData. Returns the specified
// element and whether it was found
func (a SubscriptionData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SubscriptionData
func (a *SubscriptionData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SubscriptionData to handle AdditionalProperties
func (a *SubscriptionData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nfStatusNotificationUri"]; found {
		err = json.Unmarshal(raw, &a.NfStatusNotificationUri)
		if err != nil {
			return fmt.Errorf("error reading 'nfStatusNotificationUri': %w", err)
		}
		delete(object, "nfStatusNotificationUri")
	}

	if raw, found := object["nid"]; found {
		err = json.Unmarshal(raw, &a.Nid)
		if err != nil {
			return fmt.Errorf("error reading 'nid': %w", err)
		}
		delete(object, "nid")
	}

	if raw, found := object["notifCondition"]; found {
		err = json.Unmarshal(raw, &a.NotifCondition)
		if err != nil {
			return fmt.Errorf("error reading 'notifCondition': %w", err)
		}
		delete(object, "notifCondition")
	}

	if raw, found := object["nrfSupportedFeatures"]; found {
		err = json.Unmarshal(raw, &a.NrfSupportedFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'nrfSupportedFeatures': %w", err)
		}
		delete(object, "nrfSupportedFeatures")
	}

	if raw, found := object["plmnId"]; found {
		err = json.Unmarshal(raw, &a.PlmnId)
		if err != nil {
			return fmt.Errorf("error reading 'plmnId': %w", err)
		}
		delete(object, "plmnId")
	}

	if raw, found := object["reqNfFqdn"]; found {
		err = json.Unmarshal(raw, &a.ReqNfFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'reqNfFqdn': %w", err)
		}
		delete(object, "reqNfFqdn")
	}

	if raw, found := object["reqNfInstanceId"]; found {
		err = json.Unmarshal(raw, &a.ReqNfInstanceId)
		if err != nil {
			return fmt.Errorf("error reading 'reqNfInstanceId': %w", err)
		}
		delete(object, "reqNfInstanceId")
	}

	if raw, found := object["reqNfType"]; found {
		err = json.Unmarshal(raw, &a.ReqNfType)
		if err != nil {
			return fmt.Errorf("error reading 'reqNfType': %w", err)
		}
		delete(object, "reqNfType")
	}

	if raw, found := object["reqNotifEvents"]; found {
		err = json.Unmarshal(raw, &a.ReqNotifEvents)
		if err != nil {
			return fmt.Errorf("error reading 'reqNotifEvents': %w", err)
		}
		delete(object, "reqNotifEvents")
	}

	if raw, found := object["reqPerPlmnSnssais"]; found {
		err = json.Unmarshal(raw, &a.ReqPerPlmnSnssais)
		if err != nil {
			return fmt.Errorf("error reading 'reqPerPlmnSnssais': %w", err)
		}
		delete(object, "reqPerPlmnSnssais")
	}

	if raw, found := object["reqPlmnList"]; found {
		err = json.Unmarshal(raw, &a.ReqPlmnList)
		if err != nil {
			return fmt.Errorf("error reading 'reqPlmnList': %w", err)
		}
		delete(object, "reqPlmnList")
	}

	if raw, found := object["reqSnpnList"]; found {
		err = json.Unmarshal(raw, &a.ReqSnpnList)
		if err != nil {
			return fmt.Errorf("error reading 'reqSnpnList': %w", err)
		}
		delete(object, "reqSnpnList")
	}

	if raw, found := object["reqSnssais"]; found {
		err = json.Unmarshal(raw, &a.ReqSnssais)
		if err != nil {
			return fmt.Errorf("error reading 'reqSnssais': %w", err)
		}
		delete(object, "reqSnssais")
	}

	if raw, found := object["requesterFeatures"]; found {
		err = json.Unmarshal(raw, &a.RequesterFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'requesterFeatures': %w", err)
		}
		delete(object, "requesterFeatures")
	}

	if raw, found := object["servingScope"]; found {
		err = json.Unmarshal(raw, &a.ServingScope)
		if err != nil {
			return fmt.Errorf("error reading 'servingScope': %w", err)
		}
		delete(object, "servingScope")
	}

	if raw, found := object["subscrCond"]; found {
		err = json.Unmarshal(raw, &a.SubscrCond)
		if err != nil {
			return fmt.Errorf("error reading 'subscrCond': %w", err)
		}
		delete(object, "subscrCond")
	}

	if raw, found := object["subscriptionId"]; found {
		err = json.Unmarshal(raw, &a.SubscriptionId)
		if err != nil {
			return fmt.Errorf("error reading 'subscriptionId': %w", err)
		}
		delete(object, "subscriptionId")
	}

	if raw, found := object["validityTime"]; found {
		err = json.Unmarshal(raw, &a.ValidityTime)
		if err != nil {
			return fmt.Errorf("error reading 'validityTime': %w", err)
		}
		delete(object, "validityTime")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SubscriptionData to handle AdditionalProperties
func (a SubscriptionData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["nfStatusNotificationUri"], err = json.Marshal(a.NfStatusNotificationUri)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nfStatusNotificationUri': %w", err)
	}

	if len(a.Nid) != 0 {
		object["nid"], err = json.Marshal(a.Nid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nid': %w", err)
		}
	}

	if a.NotifCondition != nil {
		object["notifCondition"], err = json.Marshal(a.NotifCondition)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notifCondition': %w", err)
		}
	}

	if a.NrfSupportedFeatures != nil {
		object["nrfSupportedFeatures"], err = json.Marshal(a.NrfSupportedFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nrfSupportedFeatures': %w", err)
		}
	}

	if a.PlmnId != nil {
		object["plmnId"], err = json.Marshal(a.PlmnId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'plmnId': %w", err)
		}
	}

	if a.ReqNfFqdn != nil {
		object["reqNfFqdn"], err = json.Marshal(a.ReqNfFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reqNfFqdn': %w", err)
		}
	}

	if a.ReqNfInstanceId != nil {
		object["reqNfInstanceId"], err = json.Marshal(a.ReqNfInstanceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reqNfInstanceId': %w", err)
		}
	}

	if a.ReqNfType != nil {
		object["reqNfType"], err = json.Marshal(a.ReqNfType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reqNfType': %w", err)
		}
	}

	if len(a.ReqNotifEvents) != 0 {
		object["reqNotifEvents"], err = json.Marshal(a.ReqNotifEvents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reqNotifEvents': %w", err)
		}
	}

	if len(a.ReqPerPlmnSnssais) != 0 {
		object["reqPerPlmnSnssais"], err = json.Marshal(a.ReqPerPlmnSnssais)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reqPerPlmnSnssais': %w", err)
		}
	}

	if len(a.ReqPlmnList) != 0 {
		object["reqPlmnList"], err = json.Marshal(a.ReqPlmnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reqPlmnList': %w", err)
		}
	}

	if len(a.ReqSnpnList) != 0 {
		object["reqSnpnList"], err = json.Marshal(a.ReqSnpnList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reqSnpnList': %w", err)
		}
	}

	if len(a.ReqSnssais) != 0 {
		object["reqSnssais"], err = json.Marshal(a.ReqSnssais)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reqSnssais': %w", err)
		}
	}

	if a.RequesterFeatures != nil {
		object["requesterFeatures"], err = json.Marshal(a.RequesterFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'requesterFeatures': %w", err)
		}
	}

	if len(a.ServingScope) != 0 {
		object["servingScope"], err = json.Marshal(a.ServingScope)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingScope': %w", err)
		}
	}

	if a.SubscrCond != nil {
		object["subscrCond"], err = json.Marshal(a.SubscrCond)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subscrCond': %w", err)
		}
	}

	if len(a.SubscriptionId) != 0 {
		object["subscriptionId"], err = json.Marshal(a.SubscriptionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subscriptionId': %w", err)
		}
	}

	if a.ValidityTime != nil {
		object["validityTime"], err = json.Marshal(a.ValidityTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'validityTime': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SupiRange. Returns the specified
// element and whether it was found
func (a SupiRange) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SupiRange
func (a *SupiRange) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SupiRange to handle AdditionalProperties
func (a *SupiRange) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["end"]; found {
		err = json.Unmarshal(raw, &a.End)
		if err != nil {
			return fmt.Errorf("error reading 'end': %w", err)
		}
		delete(object, "end")
	}

	if raw, found := object["pattern"]; found {
		err = json.Unmarshal(raw, &a.Pattern)
		if err != nil {
			return fmt.Errorf("error reading 'pattern': %w", err)
		}
		delete(object, "pattern")
	}

	if raw, found := object["start"]; found {
		err = json.Unmarshal(raw, &a.Start)
		if err != nil {
			return fmt.Errorf("error reading 'start': %w", err)
		}
		delete(object, "start")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SupiRange to handle AdditionalProperties
func (a SupiRange) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.End) != 0 {
		object["end"], err = json.Marshal(a.End)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'end': %w", err)
		}
	}

	if a.Pattern != nil {
		object["pattern"], err = json.Marshal(a.Pattern)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pattern': %w", err)
		}
	}

	if len(a.Start) != 0 {
		object["start"], err = json.Marshal(a.Start)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TacRange. Returns the specified
// element and whether it was found
func (a TacRange) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TacRange
func (a *TacRange) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TacRange to handle AdditionalProperties
func (a *TacRange) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["end"]; found {
		err = json.Unmarshal(raw, &a.End)
		if err != nil {
			return fmt.Errorf("error reading 'end': %w", err)
		}
		delete(object, "end")
	}

	if raw, found := object["pattern"]; found {
		err = json.Unmarshal(raw, &a.Pattern)
		if err != nil {
			return fmt.Errorf("error reading 'pattern': %w", err)
		}
		delete(object, "pattern")
	}

	if raw, found := object["start"]; found {
		err = json.Unmarshal(raw, &a.Start)
		if err != nil {
			return fmt.Errorf("error reading 'start': %w", err)
		}
		delete(object, "start")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TacRange to handle AdditionalProperties
func (a TacRange) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.End) != 0 {
		object["end"], err = json.Marshal(a.End)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'end': %w", err)
		}
	}

	if a.Pattern != nil {
		object["pattern"], err = json.Marshal(a.Pattern)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pattern': %w", err)
		}
	}

	if len(a.Start) != 0 {
		object["start"], err = json.Marshal(a.Start)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TaiRange. Returns the specified
// element and whether it was found
func (a TaiRange) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TaiRange
func (a *TaiRange) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TaiRange to handle AdditionalProperties
func (a *TaiRange) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nid"]; found {
		err = json.Unmarshal(raw, &a.Nid)
		if err != nil {
			return fmt.Errorf("error reading 'nid': %w", err)
		}
		delete(object, "nid")
	}

	if raw, found := object["plmnId"]; found {
		err = json.Unmarshal(raw, &a.PlmnId)
		if err != nil {
			return fmt.Errorf("error reading 'plmnId': %w", err)
		}
		delete(object, "plmnId")
	}

	if raw, found := object["tacRangeList"]; found {
		err = json.Unmarshal(raw, &a.TacRangeList)
		if err != nil {
			return fmt.Errorf("error reading 'tacRangeList': %w", err)
		}
		delete(object, "tacRangeList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TaiRange to handle AdditionalProperties
func (a TaiRange) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.Nid) != 0 {
		object["nid"], err = json.Marshal(a.Nid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nid': %w", err)
		}
	}

	object["plmnId"], err = json.Marshal(a.PlmnId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'plmnId': %w", err)
	}

	object["tacRangeList"], err = json.Marshal(a.TacRangeList)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'tacRangeList': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TngfInfo. Returns the specified
// element and whether it was found
func (a TngfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TngfInfo
func (a *TngfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TngfInfo to handle AdditionalProperties
func (a *TngfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["endpointFqdn"]; found {
		err = json.Unmarshal(raw, &a.EndpointFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'endpointFqdn': %w", err)
		}
		delete(object, "endpointFqdn")
	}

	if raw, found := object["ipv4EndpointAddresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv4EndpointAddresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4EndpointAddresses': %w", err)
		}
		delete(object, "ipv4EndpointAddresses")
	}

	if raw, found := object["ipv6EndpointAddresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv6EndpointAddresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6EndpointAddresses': %w", err)
		}
		delete(object, "ipv6EndpointAddresses")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TngfInfo to handle AdditionalProperties
func (a TngfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.EndpointFqdn != nil {
		object["endpointFqdn"], err = json.Marshal(a.EndpointFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'endpointFqdn': %w", err)
		}
	}

	if len(a.Ipv4EndpointAddresses) != 0 {
		object["ipv4EndpointAddresses"], err = json.Marshal(a.Ipv4EndpointAddresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4EndpointAddresses': %w", err)
		}
	}

	if len(a.Ipv6EndpointAddresses) != 0 {
		object["ipv6EndpointAddresses"], err = json.Marshal(a.Ipv6EndpointAddresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6EndpointAddresses': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TwifInfo. Returns the specified
// element and whether it was found
func (a TwifInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TwifInfo
func (a *TwifInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TwifInfo to handle AdditionalProperties
func (a *TwifInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["endpointFqdn"]; found {
		err = json.Unmarshal(raw, &a.EndpointFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'endpointFqdn': %w", err)
		}
		delete(object, "endpointFqdn")
	}

	if raw, found := object["ipv4EndpointAddresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv4EndpointAddresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4EndpointAddresses': %w", err)
		}
		delete(object, "ipv4EndpointAddresses")
	}

	if raw, found := object["ipv6EndpointAddresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv6EndpointAddresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6EndpointAddresses': %w", err)
		}
		delete(object, "ipv6EndpointAddresses")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TwifInfo to handle AdditionalProperties
func (a TwifInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.EndpointFqdn != nil {
		object["endpointFqdn"], err = json.Marshal(a.EndpointFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'endpointFqdn': %w", err)
		}
	}

	if len(a.Ipv4EndpointAddresses) != 0 {
		object["ipv4EndpointAddresses"], err = json.Marshal(a.Ipv4EndpointAddresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4EndpointAddresses': %w", err)
		}
	}

	if len(a.Ipv6EndpointAddresses) != 0 {
		object["ipv6EndpointAddresses"], err = json.Marshal(a.Ipv6EndpointAddresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6EndpointAddresses': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UdmInfo. Returns the specified
// element and whether it was found
func (a UdmInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UdmInfo
func (a *UdmInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UdmInfo to handle AdditionalProperties
func (a *UdmInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["externalGroupIdentifiersRanges"]; found {
		err = json.Unmarshal(raw, &a.ExternalGroupIdentifiersRanges)
		if err != nil {
			return fmt.Errorf("error reading 'externalGroupIdentifiersRanges': %w", err)
		}
		delete(object, "externalGroupIdentifiersRanges")
	}

	if raw, found := object["gpsiRanges"]; found {
		err = json.Unmarshal(raw, &a.GpsiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'gpsiRanges': %w", err)
		}
		delete(object, "gpsiRanges")
	}

	if raw, found := object["groupId"]; found {
		err = json.Unmarshal(raw, &a.GroupId)
		if err != nil {
			return fmt.Errorf("error reading 'groupId': %w", err)
		}
		delete(object, "groupId")
	}

	if raw, found := object["internalGroupIdentifiersRanges"]; found {
		err = json.Unmarshal(raw, &a.InternalGroupIdentifiersRanges)
		if err != nil {
			return fmt.Errorf("error reading 'internalGroupIdentifiersRanges': %w", err)
		}
		delete(object, "internalGroupIdentifiersRanges")
	}

	if raw, found := object["routingIndicators"]; found {
		err = json.Unmarshal(raw, &a.RoutingIndicators)
		if err != nil {
			return fmt.Errorf("error reading 'routingIndicators': %w", err)
		}
		delete(object, "routingIndicators")
	}

	if raw, found := object["supiRanges"]; found {
		err = json.Unmarshal(raw, &a.SupiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'supiRanges': %w", err)
		}
		delete(object, "supiRanges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UdmInfo to handle AdditionalProperties
func (a UdmInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.ExternalGroupIdentifiersRanges) != 0 {
		object["externalGroupIdentifiersRanges"], err = json.Marshal(a.ExternalGroupIdentifiersRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'externalGroupIdentifiersRanges': %w", err)
		}
	}

	if len(a.GpsiRanges) != 0 {
		object["gpsiRanges"], err = json.Marshal(a.GpsiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gpsiRanges': %w", err)
		}
	}

	if a.GroupId != nil {
		object["groupId"], err = json.Marshal(a.GroupId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupId': %w", err)
		}
	}

	if len(a.InternalGroupIdentifiersRanges) != 0 {
		object["internalGroupIdentifiersRanges"], err = json.Marshal(a.InternalGroupIdentifiersRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'internalGroupIdentifiersRanges': %w", err)
		}
	}

	if len(a.RoutingIndicators) != 0 {
		object["routingIndicators"], err = json.Marshal(a.RoutingIndicators)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'routingIndicators': %w", err)
		}
	}

	if len(a.SupiRanges) != 0 {
		object["supiRanges"], err = json.Marshal(a.SupiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supiRanges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UdrInfo. Returns the specified
// element and whether it was found
func (a UdrInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UdrInfo
func (a *UdrInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UdrInfo to handle AdditionalProperties
func (a *UdrInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["externalGroupIdentifiersRanges"]; found {
		err = json.Unmarshal(raw, &a.ExternalGroupIdentifiersRanges)
		if err != nil {
			return fmt.Errorf("error reading 'externalGroupIdentifiersRanges': %w", err)
		}
		delete(object, "externalGroupIdentifiersRanges")
	}

	if raw, found := object["gpsiRanges"]; found {
		err = json.Unmarshal(raw, &a.GpsiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'gpsiRanges': %w", err)
		}
		delete(object, "gpsiRanges")
	}

	if raw, found := object["groupId"]; found {
		err = json.Unmarshal(raw, &a.GroupId)
		if err != nil {
			return fmt.Errorf("error reading 'groupId': %w", err)
		}
		delete(object, "groupId")
	}

	if raw, found := object["supiRanges"]; found {
		err = json.Unmarshal(raw, &a.SupiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'supiRanges': %w", err)
		}
		delete(object, "supiRanges")
	}

	if raw, found := object["supportedDataSets"]; found {
		err = json.Unmarshal(raw, &a.SupportedDataSets)
		if err != nil {
			return fmt.Errorf("error reading 'supportedDataSets': %w", err)
		}
		delete(object, "supportedDataSets")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UdrInfo to handle AdditionalProperties
func (a UdrInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.ExternalGroupIdentifiersRanges) != 0 {
		object["externalGroupIdentifiersRanges"], err = json.Marshal(a.ExternalGroupIdentifiersRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'externalGroupIdentifiersRanges': %w", err)
		}
	}

	if len(a.GpsiRanges) != 0 {
		object["gpsiRanges"], err = json.Marshal(a.GpsiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gpsiRanges': %w", err)
		}
	}

	if a.GroupId != nil {
		object["groupId"], err = json.Marshal(a.GroupId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupId': %w", err)
		}
	}

	if len(a.SupiRanges) != 0 {
		object["supiRanges"], err = json.Marshal(a.SupiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supiRanges': %w", err)
		}
	}

	if len(a.SupportedDataSets) != 0 {
		object["supportedDataSets"], err = json.Marshal(a.SupportedDataSets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supportedDataSets': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UdsfInfo. Returns the specified
// element and whether it was found
func (a UdsfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UdsfInfo
func (a *UdsfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UdsfInfo to handle AdditionalProperties
func (a *UdsfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["groupId"]; found {
		err = json.Unmarshal(raw, &a.GroupId)
		if err != nil {
			return fmt.Errorf("error reading 'groupId': %w", err)
		}
		delete(object, "groupId")
	}

	if raw, found := object["storageIdRanges"]; found {
		err = json.Unmarshal(raw, &a.StorageIdRanges)
		if err != nil {
			return fmt.Errorf("error reading 'storageIdRanges': %w", err)
		}
		delete(object, "storageIdRanges")
	}

	if raw, found := object["supiRanges"]; found {
		err = json.Unmarshal(raw, &a.SupiRanges)
		if err != nil {
			return fmt.Errorf("error reading 'supiRanges': %w", err)
		}
		delete(object, "supiRanges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UdsfInfo to handle AdditionalProperties
func (a UdsfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.GroupId != nil {
		object["groupId"], err = json.Marshal(a.GroupId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupId': %w", err)
		}
	}

	if a.StorageIdRanges != nil {
		object["storageIdRanges"], err = json.Marshal(a.StorageIdRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'storageIdRanges': %w", err)
		}
	}

	if len(a.SupiRanges) != 0 {
		object["supiRanges"], err = json.Marshal(a.SupiRanges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'supiRanges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpfCond. Returns the specified
// element and whether it was found
func (a UpfCond) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpfCond
func (a *UpfCond) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpfCond to handle AdditionalProperties
func (a *UpfCond) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["conditionType"]; found {
		err = json.Unmarshal(raw, &a.ConditionType)
		if err != nil {
			return fmt.Errorf("error reading 'conditionType': %w", err)
		}
		delete(object, "conditionType")
	}

	if raw, found := object["smfServingArea"]; found {
		err = json.Unmarshal(raw, &a.SmfServingArea)
		if err != nil {
			return fmt.Errorf("error reading 'smfServingArea': %w", err)
		}
		delete(object, "smfServingArea")
	}

	if raw, found := object["taiList"]; found {
		err = json.Unmarshal(raw, &a.TaiList)
		if err != nil {
			return fmt.Errorf("error reading 'taiList': %w", err)
		}
		delete(object, "taiList")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpfCond to handle AdditionalProperties
func (a UpfCond) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["conditionType"], err = json.Marshal(a.ConditionType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'conditionType': %w", err)
	}

	if len(a.SmfServingArea) != 0 {
		object["smfServingArea"], err = json.Marshal(a.SmfServingArea)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'smfServingArea': %w", err)
		}
	}

	if len(a.TaiList) != 0 {
		object["taiList"], err = json.Marshal(a.TaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'taiList': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpfInfo. Returns the specified
// element and whether it was found
func (a UpfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpfInfo
func (a *UpfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpfInfo to handle AdditionalProperties
func (a *UpfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["atsssCapability"]; found {
		err = json.Unmarshal(raw, &a.AtsssCapability)
		if err != nil {
			return fmt.Errorf("error reading 'atsssCapability': %w", err)
		}
		delete(object, "atsssCapability")
	}

	if raw, found := object["dataForwarding"]; found {
		err = json.Unmarshal(raw, &a.DataForwarding)
		if err != nil {
			return fmt.Errorf("error reading 'dataForwarding': %w", err)
		}
		delete(object, "dataForwarding")
	}

	if raw, found := object["interfaceUpfInfoList"]; found {
		err = json.Unmarshal(raw, &a.InterfaceUpfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'interfaceUpfInfoList': %w", err)
		}
		delete(object, "interfaceUpfInfoList")
	}

	if raw, found := object["ipups"]; found {
		err = json.Unmarshal(raw, &a.Ipups)
		if err != nil {
			return fmt.Errorf("error reading 'ipups': %w", err)
		}
		delete(object, "ipups")
	}

	if raw, found := object["iwkEpsInd"]; found {
		err = json.Unmarshal(raw, &a.IwkEpsInd)
		if err != nil {
			return fmt.Errorf("error reading 'iwkEpsInd': %w", err)
		}
		delete(object, "iwkEpsInd")
	}

	if raw, found := object["pduSessionTypes"]; found {
		err = json.Unmarshal(raw, &a.PduSessionTypes)
		if err != nil {
			return fmt.Errorf("error reading 'pduSessionTypes': %w", err)
		}
		delete(object, "pduSessionTypes")
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &a.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
		delete(object, "priority")
	}

	if raw, found := object["redundantGtpu"]; found {
		err = json.Unmarshal(raw, &a.RedundantGtpu)
		if err != nil {
			return fmt.Errorf("error reading 'redundantGtpu': %w", err)
		}
		delete(object, "redundantGtpu")
	}

	if raw, found := object["sNssaiUpfInfoList"]; found {
		err = json.Unmarshal(raw, &a.SNssaiUpfInfoList)
		if err != nil {
			return fmt.Errorf("error reading 'sNssaiUpfInfoList': %w", err)
		}
		delete(object, "sNssaiUpfInfoList")
	}

	if raw, found := object["smfServingArea"]; found {
		err = json.Unmarshal(raw, &a.SmfServingArea)
		if err != nil {
			return fmt.Errorf("error reading 'smfServingArea': %w", err)
		}
		delete(object, "smfServingArea")
	}

	if raw, found := object["taiList"]; found {
		err = json.Unmarshal(raw, &a.TaiList)
		if err != nil {
			return fmt.Errorf("error reading 'taiList': %w", err)
		}
		delete(object, "taiList")
	}

	if raw, found := object["tngfInfo"]; found {
		err = json.Unmarshal(raw, &a.TngfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'tngfInfo': %w", err)
		}
		delete(object, "tngfInfo")
	}

	if raw, found := object["twifInfo"]; found {
		err = json.Unmarshal(raw, &a.TwifInfo)
		if err != nil {
			return fmt.Errorf("error reading 'twifInfo': %w", err)
		}
		delete(object, "twifInfo")
	}

	if raw, found := object["ueIpAddrInd"]; found {
		err = json.Unmarshal(raw, &a.UeIpAddrInd)
		if err != nil {
			return fmt.Errorf("error reading 'ueIpAddrInd': %w", err)
		}
		delete(object, "ueIpAddrInd")
	}

	if raw, found := object["wAgfInfo"]; found {
		err = json.Unmarshal(raw, &a.WAgfInfo)
		if err != nil {
			return fmt.Errorf("error reading 'wAgfInfo': %w", err)
		}
		delete(object, "wAgfInfo")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpfInfo to handle AdditionalProperties
func (a UpfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AtsssCapability != nil {
		object["atsssCapability"], err = json.Marshal(a.AtsssCapability)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'atsssCapability': %w", err)
		}
	}

	if a.DataForwarding != nil {
		object["dataForwarding"], err = json.Marshal(a.DataForwarding)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dataForwarding': %w", err)
		}
	}

	if len(a.InterfaceUpfInfoList) != 0 {
		object["interfaceUpfInfoList"], err = json.Marshal(a.InterfaceUpfInfoList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'interfaceUpfInfoList': %w", err)
		}
	}

	if a.Ipups != nil {
		object["ipups"], err = json.Marshal(a.Ipups)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipups': %w", err)
		}
	}

	if a.IwkEpsInd != nil {
		object["iwkEpsInd"], err = json.Marshal(a.IwkEpsInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'iwkEpsInd': %w", err)
		}
	}

	if len(a.PduSessionTypes) != 0 {
		object["pduSessionTypes"], err = json.Marshal(a.PduSessionTypes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pduSessionTypes': %w", err)
		}
	}

	if a.Priority != nil {
		object["priority"], err = json.Marshal(a.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	if a.RedundantGtpu != nil {
		object["redundantGtpu"], err = json.Marshal(a.RedundantGtpu)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'redundantGtpu': %w", err)
		}
	}

	object["sNssaiUpfInfoList"], err = json.Marshal(a.SNssaiUpfInfoList)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'sNssaiUpfInfoList': %w", err)
	}

	if len(a.SmfServingArea) != 0 {
		object["smfServingArea"], err = json.Marshal(a.SmfServingArea)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'smfServingArea': %w", err)
		}
	}

	if len(a.TaiList) != 0 {
		object["taiList"], err = json.Marshal(a.TaiList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'taiList': %w", err)
		}
	}

	if a.TngfInfo != nil {
		object["tngfInfo"], err = json.Marshal(a.TngfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tngfInfo': %w", err)
		}
	}

	if a.TwifInfo != nil {
		object["twifInfo"], err = json.Marshal(a.TwifInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'twifInfo': %w", err)
		}
	}

	if a.UeIpAddrInd != nil {
		object["ueIpAddrInd"], err = json.Marshal(a.UeIpAddrInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ueIpAddrInd': %w", err)
		}
	}

	if a.WAgfInfo != nil {
		object["wAgfInfo"], err = json.Marshal(a.WAgfInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'wAgfInfo': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for VendorSpecificFeature. Returns the specified
// element and whether it was found
func (a VendorSpecificFeature) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for VendorSpecificFeature
func (a *VendorSpecificFeature) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for VendorSpecificFeature to handle AdditionalProperties
func (a *VendorSpecificFeature) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["featureName"]; found {
		err = json.Unmarshal(raw, &a.FeatureName)
		if err != nil {
			return fmt.Errorf("error reading 'featureName': %w", err)
		}
		delete(object, "featureName")
	}

	if raw, found := object["featureVersion"]; found {
		err = json.Unmarshal(raw, &a.FeatureVersion)
		if err != nil {
			return fmt.Errorf("error reading 'featureVersion': %w", err)
		}
		delete(object, "featureVersion")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for VendorSpecificFeature to handle AdditionalProperties
func (a VendorSpecificFeature) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["featureName"], err = json.Marshal(a.FeatureName)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'featureName': %w", err)
	}

	object["featureVersion"], err = json.Marshal(a.FeatureVersion)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'featureVersion': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for WAgfInfo. Returns the specified
// element and whether it was found
func (a WAgfInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for WAgfInfo
func (a *WAgfInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for WAgfInfo to handle AdditionalProperties
func (a *WAgfInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["endpointFqdn"]; found {
		err = json.Unmarshal(raw, &a.EndpointFqdn)
		if err != nil {
			return fmt.Errorf("error reading 'endpointFqdn': %w", err)
		}
		delete(object, "endpointFqdn")
	}

	if raw, found := object["ipv4EndpointAddresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv4EndpointAddresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4EndpointAddresses': %w", err)
		}
		delete(object, "ipv4EndpointAddresses")
	}

	if raw, found := object["ipv6EndpointAddresses"]; found {
		err = json.Unmarshal(raw, &a.Ipv6EndpointAddresses)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6EndpointAddresses': %w", err)
		}
		delete(object, "ipv6EndpointAddresses")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for WAgfInfo to handle AdditionalProperties
func (a WAgfInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.EndpointFqdn != nil {
		object["endpointFqdn"], err = json.Marshal(a.EndpointFqdn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'endpointFqdn': %w", err)
		}
	}

	if len(a.Ipv4EndpointAddresses) != 0 {
		object["ipv4EndpointAddresses"], err = json.Marshal(a.Ipv4EndpointAddresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4EndpointAddresses': %w", err)
		}
	}

	if len(a.Ipv6EndpointAddresses) != 0 {
		object["ipv6EndpointAddresses"], err = json.Marshal(a.Ipv6EndpointAddresses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6EndpointAddresses': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsNfInstanceIdCond returns the union data inside the SubscriptionData_SubscrCond as a NfInstanceIdCond
func (t SubscriptionData_SubscrCond) AsNfInstanceIdCond() (NfInstanceIdCond, error) {
	var body NfInstanceIdCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNfInstanceIdCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided NfInstanceIdCond
func (t *SubscriptionData_SubscrCond) FromNfInstanceIdCond(v NfInstanceIdCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNfInstanceIdCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided NfInstanceIdCond
func (t *SubscriptionData_SubscrCond) MergeNfInstanceIdCond(v NfInstanceIdCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNfInstanceIdListCond returns the union data inside the SubscriptionData_SubscrCond as a NfInstanceIdListCond
func (t SubscriptionData_SubscrCond) AsNfInstanceIdListCond() (NfInstanceIdListCond, error) {
	var body NfInstanceIdListCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNfInstanceIdListCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided NfInstanceIdListCond
func (t *SubscriptionData_SubscrCond) FromNfInstanceIdListCond(v NfInstanceIdListCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNfInstanceIdListCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided NfInstanceIdListCond
func (t *SubscriptionData_SubscrCond) MergeNfInstanceIdListCond(v NfInstanceIdListCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNfTypeCond returns the union data inside the SubscriptionData_SubscrCond as a NfTypeCond
func (t SubscriptionData_SubscrCond) AsNfTypeCond() (NfTypeCond, error) {
	var body NfTypeCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNfTypeCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided NfTypeCond
func (t *SubscriptionData_SubscrCond) FromNfTypeCond(v NfTypeCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNfTypeCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided NfTypeCond
func (t *SubscriptionData_SubscrCond) MergeNfTypeCond(v NfTypeCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServiceNameCond returns the union data inside the SubscriptionData_SubscrCond as a ServiceNameCond
func (t SubscriptionData_SubscrCond) AsServiceNameCond() (ServiceNameCond, error) {
	var body ServiceNameCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServiceNameCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided ServiceNameCond
func (t *SubscriptionData_SubscrCond) FromServiceNameCond(v ServiceNameCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServiceNameCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided ServiceNameCond
func (t *SubscriptionData_SubscrCond) MergeServiceNameCond(v ServiceNameCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAmfCond returns the union data inside the SubscriptionData_SubscrCond as a AmfCond
func (t SubscriptionData_SubscrCond) AsAmfCond() (AmfCond, error) {
	var body AmfCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAmfCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided AmfCond
func (t *SubscriptionData_SubscrCond) FromAmfCond(v AmfCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAmfCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided AmfCond
func (t *SubscriptionData_SubscrCond) MergeAmfCond(v AmfCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsGuamiListCond returns the union data inside the SubscriptionData_SubscrCond as a GuamiListCond
func (t SubscriptionData_SubscrCond) AsGuamiListCond() (GuamiListCond, error) {
	var body GuamiListCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGuamiListCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided GuamiListCond
func (t *SubscriptionData_SubscrCond) FromGuamiListCond(v GuamiListCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGuamiListCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided GuamiListCond
func (t *SubscriptionData_SubscrCond) MergeGuamiListCond(v GuamiListCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkSliceCond returns the union data inside the SubscriptionData_SubscrCond as a NetworkSliceCond
func (t SubscriptionData_SubscrCond) AsNetworkSliceCond() (NetworkSliceCond, error) {
	var body NetworkSliceCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkSliceCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided NetworkSliceCond
func (t *SubscriptionData_SubscrCond) FromNetworkSliceCond(v NetworkSliceCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkSliceCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided NetworkSliceCond
func (t *SubscriptionData_SubscrCond) MergeNetworkSliceCond(v NetworkSliceCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNfGroupCond returns the union data inside the SubscriptionData_SubscrCond as a NfGroupCond
func (t SubscriptionData_SubscrCond) AsNfGroupCond() (NfGroupCond, error) {
	var body NfGroupCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNfGroupCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided NfGroupCond
func (t *SubscriptionData_SubscrCond) FromNfGroupCond(v NfGroupCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNfGroupCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided NfGroupCond
func (t *SubscriptionData_SubscrCond) MergeNfGroupCond(v NfGroupCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNfSetCond returns the union data inside the SubscriptionData_SubscrCond as a NfSetCond
func (t SubscriptionData_SubscrCond) AsNfSetCond() (NfSetCond, error) {
	var body NfSetCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNfSetCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided NfSetCond
func (t *SubscriptionData_SubscrCond) FromNfSetCond(v NfSetCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNfSetCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided NfSetCond
func (t *SubscriptionData_SubscrCond) MergeNfSetCond(v NfSetCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNfServiceSetCond returns the union data inside the SubscriptionData_SubscrCond as a NfServiceSetCond
func (t SubscriptionData_SubscrCond) AsNfServiceSetCond() (NfServiceSetCond, error) {
	var body NfServiceSetCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNfServiceSetCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided NfServiceSetCond
func (t *SubscriptionData_SubscrCond) FromNfServiceSetCond(v NfServiceSetCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNfServiceSetCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided NfServiceSetCond
func (t *SubscriptionData_SubscrCond) MergeNfServiceSetCond(v NfServiceSetCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpfCond returns the union data inside the SubscriptionData_SubscrCond as a UpfCond
func (t SubscriptionData_SubscrCond) AsUpfCond() (UpfCond, error) {
	var body UpfCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpfCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided UpfCond
func (t *SubscriptionData_SubscrCond) FromUpfCond(v UpfCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpfCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided UpfCond
func (t *SubscriptionData_SubscrCond) MergeUpfCond(v UpfCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsScpDomainCond returns the union data inside the SubscriptionData_SubscrCond as a ScpDomainCond
func (t SubscriptionData_SubscrCond) AsScpDomainCond() (ScpDomainCond, error) {
	var body ScpDomainCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScpDomainCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided ScpDomainCond
func (t *SubscriptionData_SubscrCond) FromScpDomainCond(v ScpDomainCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScpDomainCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided ScpDomainCond
func (t *SubscriptionData_SubscrCond) MergeScpDomainCond(v ScpDomainCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNwdafCond returns the union data inside the SubscriptionData_SubscrCond as a NwdafCond
func (t SubscriptionData_SubscrCond) AsNwdafCond() (NwdafCond, error) {
	var body NwdafCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNwdafCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided NwdafCond
func (t *SubscriptionData_SubscrCond) FromNwdafCond(v NwdafCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNwdafCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided NwdafCond
func (t *SubscriptionData_SubscrCond) MergeNwdafCond(v NwdafCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNefCond returns the union data inside the SubscriptionData_SubscrCond as a NefCond
func (t SubscriptionData_SubscrCond) AsNefCond() (NefCond, error) {
	var body NefCond
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNefCond overwrites any union data inside the SubscriptionData_SubscrCond as the provided NefCond
func (t *SubscriptionData_SubscrCond) FromNefCond(v NefCond) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNefCond performs a merge with any union data inside the SubscriptionData_SubscrCond, using the provided NefCond
func (t *SubscriptionData_SubscrCond) MergeNefCond(v NefCond) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SubscriptionData_SubscrCond) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SubscriptionData_SubscrCond) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetNFInstances request
	GetNFInstances(ctx context.Context, params *GetNFInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OptionsNFInstances request
	OptionsNFInstances(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeregisterNFInstance request
	DeregisterNFInstance(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNFInstance request
	GetNFInstance(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *GetNFInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNFInstanceWithBody request with any body
	UpdateNFInstanceWithBody(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *UpdateNFInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNFInstanceWithApplicationJSONPatchPlusJSONBody(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *UpdateNFInstanceParams, body UpdateNFInstanceApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterNFInstanceWithBody request with any body
	RegisterNFInstanceWithBody(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *RegisterNFInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterNFInstance(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *RegisterNFInstanceParams, body RegisterNFInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSubscriptionWithBody request with any body
	CreateSubscriptionWithBody(ctx context.Context, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSubscription(ctx context.Context, params *CreateSubscriptionParams, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubscription request
	RemoveSubscription(ctx context.Context, subscriptionID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSubscriptionWithBody request with any body
	UpdateSubscriptionWithBody(ctx context.Context, subscriptionID string, params *UpdateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSubscriptionWithApplicationJSONPatchPlusJSONBody(ctx context.Context, subscriptionID string, params *UpdateSubscriptionParams, body UpdateSubscriptionApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetNFInstances(ctx context.Context, params *GetNFInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNFInstancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OptionsNFInstances(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOptionsNFInstancesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeregisterNFInstance(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeregisterNFInstanceRequest(c.Server, nfInstanceID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNFInstance(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *GetNFInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNFInstanceRequest(c.Server, nfInstanceID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNFInstanceWithBody(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *UpdateNFInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNFInstanceRequestWithBody(c.Server, nfInstanceID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNFInstanceWithApplicationJSONPatchPlusJSONBody(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *UpdateNFInstanceParams, body UpdateNFInstanceApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNFInstanceRequestWithApplicationJSONPatchPlusJSONBody(c.Server, nfInstanceID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterNFInstanceWithBody(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *RegisterNFInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterNFInstanceRequestWithBody(c.Server, nfInstanceID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterNFInstance(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *RegisterNFInstanceParams, body RegisterNFInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterNFInstanceRequest(c.Server, nfInstanceID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscriptionWithBody(ctx context.Context, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSubscription(ctx context.Context, params *CreateSubscriptionParams, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSubscriptionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubscription(ctx context.Context, subscriptionID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubscriptionRequest(c.Server, subscriptionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubscriptionWithBody(ctx context.Context, subscriptionID string, params *UpdateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubscriptionRequestWithBody(c.Server, subscriptionID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSubscriptionWithApplicationJSONPatchPlusJSONBody(ctx context.Context, subscriptionID string, params *UpdateSubscriptionParams, body UpdateSubscriptionApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSubscriptionRequestWithApplicationJSONPatchPlusJSONBody(c.Server, subscriptionID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetNFInstancesRequest generates requests for GetNFInstances
func NewGetNFInstancesRequest(server string, params *GetNFInstancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nf-instances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NfType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nf-type", runtime.ParamLocationQuery, *params.NfType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOptionsNFInstancesRequest generates requests for OptionsNFInstances
func NewOptionsNFInstancesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nf-instances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("OPTIONS", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeregisterNFInstanceRequest generates requests for DeregisterNFInstance
func NewDeregisterNFInstanceRequest(server string, nfInstanceID externalRef0.NfInstanceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nfInstanceID", runtime.ParamLocationPath, nfInstanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nf-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNFInstanceRequest generates requests for GetNFInstance
func NewGetNFInstanceRequest(server string, nfInstanceID externalRef0.NfInstanceId, params *GetNFInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nfInstanceID", runtime.ParamLocationPath, nfInstanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nf-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequesterFeatures != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester-features", runtime.ParamLocationQuery, *params.RequesterFeatures); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNFInstanceRequestWithApplicationJSONPatchPlusJSONBody calls the generic UpdateNFInstance builder with application/json-patch+json body
func NewUpdateNFInstanceRequestWithApplicationJSONPatchPlusJSONBody(server string, nfInstanceID externalRef0.NfInstanceId, params *UpdateNFInstanceParams, body UpdateNFInstanceApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNFInstanceRequestWithBody(server, nfInstanceID, params, "application/json-patch+json", bodyReader)
}

// NewUpdateNFInstanceRequestWithBody generates requests for UpdateNFInstance with any type of body
func NewUpdateNFInstanceRequestWithBody(server string, nfInstanceID externalRef0.NfInstanceId, params *UpdateNFInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nfInstanceID", runtime.ParamLocationPath, nfInstanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nf-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.ContentEncoding != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Encoding", runtime.ParamLocationHeader, *params.ContentEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Encoding", headerParam0)
		}

		if params.AcceptEncoding != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, *params.AcceptEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Encoding", headerParam1)
		}

		if params.IfMatch != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam2)
		}

	}

	return req, nil
}

// NewRegisterNFInstanceRequest calls the generic RegisterNFInstance builder with application/json body
func NewRegisterNFInstanceRequest(server string, nfInstanceID externalRef0.NfInstanceId, params *RegisterNFInstanceParams, body RegisterNFInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterNFInstanceRequestWithBody(server, nfInstanceID, params, "application/json", bodyReader)
}

// NewRegisterNFInstanceRequestWithBody generates requests for RegisterNFInstance with any type of body
func NewRegisterNFInstanceRequestWithBody(server string, nfInstanceID externalRef0.NfInstanceId, params *RegisterNFInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "nfInstanceID", runtime.ParamLocationPath, nfInstanceID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nf-instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.ContentEncoding != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Encoding", runtime.ParamLocationHeader, *params.ContentEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Encoding", headerParam0)
		}

		if params.AcceptEncoding != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, *params.AcceptEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Encoding", headerParam1)
		}

	}

	return req, nil
}

// NewCreateSubscriptionRequest calls the generic CreateSubscription builder with application/json body
func NewCreateSubscriptionRequest(server string, params *CreateSubscriptionParams, body CreateSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSubscriptionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSubscriptionRequestWithBody generates requests for CreateSubscription with any type of body
func NewCreateSubscriptionRequestWithBody(server string, params *CreateSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.ContentEncoding != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Encoding", runtime.ParamLocationHeader, *params.ContentEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Encoding", headerParam0)
		}

		if params.AcceptEncoding != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, *params.AcceptEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Encoding", headerParam1)
		}

	}

	return req, nil
}

// NewRemoveSubscriptionRequest generates requests for RemoveSubscription
func NewRemoveSubscriptionRequest(server string, subscriptionID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionID", runtime.ParamLocationPath, subscriptionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSubscriptionRequestWithApplicationJSONPatchPlusJSONBody calls the generic UpdateSubscription builder with application/json-patch+json body
func NewUpdateSubscriptionRequestWithApplicationJSONPatchPlusJSONBody(server string, subscriptionID string, params *UpdateSubscriptionParams, body UpdateSubscriptionApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSubscriptionRequestWithBody(server, subscriptionID, params, "application/json-patch+json", bodyReader)
}

// NewUpdateSubscriptionRequestWithBody generates requests for UpdateSubscription with any type of body
func NewUpdateSubscriptionRequestWithBody(server string, subscriptionID string, params *UpdateSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscriptionID", runtime.ParamLocationPath, subscriptionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.ContentEncoding != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Encoding", runtime.ParamLocationHeader, *params.ContentEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Content-Encoding", headerParam0)
		}

		if params.AcceptEncoding != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, *params.AcceptEncoding)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Encoding", headerParam1)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetNFInstancesWithResponse request
	GetNFInstancesWithResponse(ctx context.Context, params *GetNFInstancesParams, reqEditors ...RequestEditorFn) (*GetNFInstancesResponse, error)

	// OptionsNFInstancesWithResponse request
	OptionsNFInstancesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OptionsNFInstancesResponse, error)

	// DeregisterNFInstanceWithResponse request
	DeregisterNFInstanceWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, reqEditors ...RequestEditorFn) (*DeregisterNFInstanceResponse, error)

	// GetNFInstanceWithResponse request
	GetNFInstanceWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *GetNFInstanceParams, reqEditors ...RequestEditorFn) (*GetNFInstanceResponse, error)

	// UpdateNFInstanceWithBodyWithResponse request with any body
	UpdateNFInstanceWithBodyWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *UpdateNFInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNFInstanceResponse, error)

	UpdateNFInstanceWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *UpdateNFInstanceParams, body UpdateNFInstanceApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNFInstanceResponse, error)

	// RegisterNFInstanceWithBodyWithResponse request with any body
	RegisterNFInstanceWithBodyWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *RegisterNFInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterNFInstanceResponse, error)

	RegisterNFInstanceWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *RegisterNFInstanceParams, body RegisterNFInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterNFInstanceResponse, error)

	// CreateSubscriptionWithBodyWithResponse request with any body
	CreateSubscriptionWithBodyWithResponse(ctx context.Context, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	CreateSubscriptionWithResponse(ctx context.Context, params *CreateSubscriptionParams, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error)

	// RemoveSubscriptionWithResponse request
	RemoveSubscriptionWithResponse(ctx context.Context, subscriptionID string, reqEditors ...RequestEditorFn) (*RemoveSubscriptionResponse, error)

	// UpdateSubscriptionWithBodyWithResponse request with any body
	UpdateSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionID string, params *UpdateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubscriptionResponse, error)

	UpdateSubscriptionWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, subscriptionID string, params *UpdateSubscriptionParams, body UpdateSubscriptionApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubscriptionResponse, error)
}

type GetNFInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	Application3gppHalJSON200 *struct {
		// Links List of the URI of NF instances. It has two members whose names are item and self. The item one contains an array of URIs.
		Links                *map[string]externalRef0.LinksValueSchema `json:"_links,omitempty"`
		AdditionalProperties map[string]interface{}                    `json:"-"`
	}
	JSON307                   *externalRef0.RedirectResponse
	JSON308                   *externalRef0.RedirectResponse
	ApplicationproblemJSON400 *externalRef0.N400
	ApplicationproblemJSON401 *externalRef0.N401
	ApplicationproblemJSON403 *externalRef0.N403
	ApplicationproblemJSON404 *externalRef0.N404
	ApplicationproblemJSON411 *externalRef0.N411
	ApplicationproblemJSON413 *externalRef0.N413
	ApplicationproblemJSON415 *externalRef0.N415
	ApplicationproblemJSON429 *externalRef0.N429
	ApplicationproblemJSON500 *externalRef0.N500
	ApplicationproblemJSON501 *externalRef0.N501
	ApplicationproblemJSON503 *externalRef0.N503
}

// Status returns HTTPResponse.Status
func (r GetNFInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNFInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OptionsNFInstancesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *OptionsResponse
	JSON307                   *externalRef0.RedirectResponse
	JSON308                   *externalRef0.RedirectResponse
	ApplicationproblemJSON400 *externalRef0.N400
	ApplicationproblemJSON401 *externalRef0.N401
	ApplicationproblemJSON403 *externalRef0.N403
	ApplicationproblemJSON404 *externalRef0.N404
	ApplicationproblemJSON429 *externalRef0.N429
	ApplicationproblemJSON500 *externalRef0.N500
	ApplicationproblemJSON501 *externalRef0.N501
	ApplicationproblemJSON503 *externalRef0.N503
}

// Status returns HTTPResponse.Status
func (r OptionsNFInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OptionsNFInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeregisterNFInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON307                   *externalRef0.RedirectResponse
	JSON308                   *externalRef0.RedirectResponse
	ApplicationproblemJSON400 *externalRef0.N400
	ApplicationproblemJSON401 *externalRef0.N401
	ApplicationproblemJSON403 *externalRef0.N403
	ApplicationproblemJSON404 *externalRef0.N404
	ApplicationproblemJSON411 *externalRef0.N411
	ApplicationproblemJSON429 *externalRef0.N429
	ApplicationproblemJSON500 *externalRef0.N500
	ApplicationproblemJSON501 *externalRef0.N501
	ApplicationproblemJSON503 *externalRef0.N503
}

// Status returns HTTPResponse.Status
func (r DeregisterNFInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeregisterNFInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNFInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *NFProfile
	JSON307                   *externalRef0.RedirectResponse
	JSON308                   *externalRef0.RedirectResponse
	ApplicationproblemJSON400 *externalRef0.N400
	ApplicationproblemJSON401 *externalRef0.N401
	ApplicationproblemJSON403 *externalRef0.N403
	ApplicationproblemJSON404 *externalRef0.N404
	ApplicationproblemJSON411 *externalRef0.N411
	ApplicationproblemJSON413 *externalRef0.N413
	ApplicationproblemJSON415 *externalRef0.N415
	ApplicationproblemJSON429 *externalRef0.N429
	ApplicationproblemJSON500 *externalRef0.N500
	ApplicationproblemJSON501 *externalRef0.N501
	ApplicationproblemJSON503 *externalRef0.N503
}

// Status returns HTTPResponse.Status
func (r GetNFInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNFInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNFInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *NFProfile
	JSON307                   *externalRef0.RedirectResponse
	JSON308                   *externalRef0.RedirectResponse
	ApplicationproblemJSON400 *externalRef0.N400
	ApplicationproblemJSON403 *externalRef0.N403
	ApplicationproblemJSON404 *externalRef0.N404
	ApplicationproblemJSON409 *externalRef0.N409
	ApplicationproblemJSON411 *externalRef0.N411
	ApplicationproblemJSON412 *externalRef0.N412
	ApplicationproblemJSON413 *externalRef0.N413
	ApplicationproblemJSON415 *externalRef0.N415
	ApplicationproblemJSON429 *externalRef0.N429
	ApplicationproblemJSON500 *externalRef0.N500
	ApplicationproblemJSON501 *externalRef0.N501
	ApplicationproblemJSON503 *externalRef0.N503
}

// Status returns HTTPResponse.Status
func (r UpdateNFInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNFInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterNFInstanceResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *NFProfile
	JSON201                   *NFProfile
	JSON307                   *externalRef0.RedirectResponse
	JSON308                   *externalRef0.RedirectResponse
	ApplicationproblemJSON400 *externalRef0.N400
	ApplicationproblemJSON401 *externalRef0.N401
	ApplicationproblemJSON403 *externalRef0.N403
	ApplicationproblemJSON404 *externalRef0.N404
	ApplicationproblemJSON411 *externalRef0.N411
	ApplicationproblemJSON413 *externalRef0.N413
	ApplicationproblemJSON415 *externalRef0.N415
	ApplicationproblemJSON429 *externalRef0.N429
	ApplicationproblemJSON500 *externalRef0.N500
	ApplicationproblemJSON501 *externalRef0.N501
	ApplicationproblemJSON503 *externalRef0.N503
}

// Status returns HTTPResponse.Status
func (r RegisterNFInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterNFInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *SubscriptionData
	JSON307                   *externalRef0.RedirectResponse
	JSON308                   *externalRef0.RedirectResponse
	ApplicationproblemJSON400 *externalRef0.N400
	ApplicationproblemJSON401 *externalRef0.N401
	ApplicationproblemJSON403 *externalRef0.N403
	ApplicationproblemJSON404 *externalRef0.N404
	ApplicationproblemJSON411 *externalRef0.N411
	ApplicationproblemJSON413 *externalRef0.N413
	ApplicationproblemJSON415 *externalRef0.N415
	ApplicationproblemJSON429 *externalRef0.N429
	ApplicationproblemJSON500 *externalRef0.N500
	ApplicationproblemJSON501 *externalRef0.N501
	ApplicationproblemJSON503 *externalRef0.N503
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON307                   *externalRef0.RedirectResponse
	JSON308                   *externalRef0.RedirectResponse
	ApplicationproblemJSON400 *externalRef0.N400
	ApplicationproblemJSON401 *externalRef0.N401
	ApplicationproblemJSON403 *externalRef0.N403
	ApplicationproblemJSON404 *externalRef0.N404
	ApplicationproblemJSON411 *externalRef0.N411
	ApplicationproblemJSON413 *externalRef0.N413
	ApplicationproblemJSON415 *externalRef0.N415
	ApplicationproblemJSON429 *externalRef0.N429
	ApplicationproblemJSON500 *externalRef0.N500
	ApplicationproblemJSON501 *externalRef0.N501
	ApplicationproblemJSON503 *externalRef0.N503
}

// Status returns HTTPResponse.Status
func (r RemoveSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSubscriptionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SubscriptionData
	JSON307                   *externalRef0.RedirectResponse
	JSON308                   *externalRef0.RedirectResponse
	ApplicationproblemJSON400 *externalRef0.N400
	ApplicationproblemJSON403 *externalRef0.N403
	ApplicationproblemJSON404 *externalRef0.N404
	ApplicationproblemJSON411 *externalRef0.N411
	ApplicationproblemJSON413 *externalRef0.N413
	ApplicationproblemJSON415 *externalRef0.N415
	ApplicationproblemJSON429 *externalRef0.N429
	ApplicationproblemJSON500 *externalRef0.N500
	ApplicationproblemJSON501 *externalRef0.N501
	ApplicationproblemJSON503 *externalRef0.N503
}

// Status returns HTTPResponse.Status
func (r UpdateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetNFInstancesWithResponse request returning *GetNFInstancesResponse
func (c *ClientWithResponses) GetNFInstancesWithResponse(ctx context.Context, params *GetNFInstancesParams, reqEditors ...RequestEditorFn) (*GetNFInstancesResponse, error) {
	rsp, err := c.GetNFInstances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNFInstancesResponse(rsp)
}

// OptionsNFInstancesWithResponse request returning *OptionsNFInstancesResponse
func (c *ClientWithResponses) OptionsNFInstancesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OptionsNFInstancesResponse, error) {
	rsp, err := c.OptionsNFInstances(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOptionsNFInstancesResponse(rsp)
}

// DeregisterNFInstanceWithResponse request returning *DeregisterNFInstanceResponse
func (c *ClientWithResponses) DeregisterNFInstanceWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, reqEditors ...RequestEditorFn) (*DeregisterNFInstanceResponse, error) {
	rsp, err := c.DeregisterNFInstance(ctx, nfInstanceID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeregisterNFInstanceResponse(rsp)
}

// GetNFInstanceWithResponse request returning *GetNFInstanceResponse
func (c *ClientWithResponses) GetNFInstanceWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *GetNFInstanceParams, reqEditors ...RequestEditorFn) (*GetNFInstanceResponse, error) {
	rsp, err := c.GetNFInstance(ctx, nfInstanceID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNFInstanceResponse(rsp)
}

// UpdateNFInstanceWithBodyWithResponse request with arbitrary body returning *UpdateNFInstanceResponse
func (c *ClientWithResponses) UpdateNFInstanceWithBodyWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *UpdateNFInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNFInstanceResponse, error) {
	rsp, err := c.UpdateNFInstanceWithBody(ctx, nfInstanceID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNFInstanceResponse(rsp)
}

func (c *ClientWithResponses) UpdateNFInstanceWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *UpdateNFInstanceParams, body UpdateNFInstanceApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNFInstanceResponse, error) {
	rsp, err := c.UpdateNFInstanceWithApplicationJSONPatchPlusJSONBody(ctx, nfInstanceID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNFInstanceResponse(rsp)
}

// RegisterNFInstanceWithBodyWithResponse request with arbitrary body returning *RegisterNFInstanceResponse
func (c *ClientWithResponses) RegisterNFInstanceWithBodyWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *RegisterNFInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterNFInstanceResponse, error) {
	rsp, err := c.RegisterNFInstanceWithBody(ctx, nfInstanceID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterNFInstanceResponse(rsp)
}

func (c *ClientWithResponses) RegisterNFInstanceWithResponse(ctx context.Context, nfInstanceID externalRef0.NfInstanceId, params *RegisterNFInstanceParams, body RegisterNFInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterNFInstanceResponse, error) {
	rsp, err := c.RegisterNFInstance(ctx, nfInstanceID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterNFInstanceResponse(rsp)
}

// CreateSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateSubscriptionResponse
func (c *ClientWithResponses) CreateSubscriptionWithBodyWithResponse(ctx context.Context, params *CreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscriptionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) CreateSubscriptionWithResponse(ctx context.Context, params *CreateSubscriptionParams, body CreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSubscriptionResponse, error) {
	rsp, err := c.CreateSubscription(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSubscriptionResponse(rsp)
}

// RemoveSubscriptionWithResponse request returning *RemoveSubscriptionResponse
func (c *ClientWithResponses) RemoveSubscriptionWithResponse(ctx context.Context, subscriptionID string, reqEditors ...RequestEditorFn) (*RemoveSubscriptionResponse, error) {
	rsp, err := c.RemoveSubscription(ctx, subscriptionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubscriptionResponse(rsp)
}

// UpdateSubscriptionWithBodyWithResponse request with arbitrary body returning *UpdateSubscriptionResponse
func (c *ClientWithResponses) UpdateSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionID string, params *UpdateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSubscriptionResponse, error) {
	rsp, err := c.UpdateSubscriptionWithBody(ctx, subscriptionID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) UpdateSubscriptionWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, subscriptionID string, params *UpdateSubscriptionParams, body UpdateSubscriptionApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSubscriptionResponse, error) {
	rsp, err := c.UpdateSubscriptionWithApplicationJSONPatchPlusJSONBody(ctx, subscriptionID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSubscriptionResponse(rsp)
}

// ParseGetNFInstancesResponse parses an HTTP response from a GetNFInstancesWithResponse call
func ParseGetNFInstancesResponse(rsp *http.Response) (*GetNFInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNFInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Links List of the URI of NF instances. It has two members whose names are item and self. The item one contains an array of URIs.
			Links                *map[string]externalRef0.LinksValueSchema `json:"_links,omitempty"`
			AdditionalProperties map[string]interface{}                    `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.Application3gppHalJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef0.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseOptionsNFInstancesResponse parses an HTTP response from a OptionsNFInstancesWithResponse call
func ParseOptionsNFInstancesResponse(rsp *http.Response) (*OptionsNFInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OptionsNFInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef0.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseDeregisterNFInstanceResponse parses an HTTP response from a DeregisterNFInstanceWithResponse call
func ParseDeregisterNFInstanceResponse(rsp *http.Response) (*DeregisterNFInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeregisterNFInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef0.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseGetNFInstanceResponse parses an HTTP response from a GetNFInstanceWithResponse call
func ParseGetNFInstanceResponse(rsp *http.Response) (*GetNFInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNFInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NFProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef0.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseUpdateNFInstanceResponse parses an HTTP response from a UpdateNFInstanceWithResponse call
func ParseUpdateNFInstanceResponse(rsp *http.Response) (*UpdateNFInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNFInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NFProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef0.N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest externalRef0.N412
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef0.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseRegisterNFInstanceResponse parses an HTTP response from a RegisterNFInstanceWithResponse call
func ParseRegisterNFInstanceResponse(rsp *http.Response) (*RegisterNFInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterNFInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NFProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NFProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef0.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseCreateSubscriptionResponse parses an HTTP response from a CreateSubscriptionWithResponse call
func ParseCreateSubscriptionResponse(rsp *http.Response) (*CreateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SubscriptionData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef0.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseRemoveSubscriptionResponse parses an HTTP response from a RemoveSubscriptionWithResponse call
func ParseRemoveSubscriptionResponse(rsp *http.Response) (*RemoveSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef0.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ParseUpdateSubscriptionResponse parses an HTTP response from a UpdateSubscriptionWithResponse call
func ParseUpdateSubscriptionResponse(rsp *http.Response) (*UpdateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscriptionData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.RedirectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest externalRef0.N501
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieves a collection of NF Instances
	// (GET /nf-instances)
	GetNFInstances(c *gin.Context, params GetNFInstancesParams)
	// Discover communication options supported by NRF for NF Instances
	// (OPTIONS /nf-instances)
	OptionsNFInstances(c *gin.Context)
	// Deregisters a given NF Instance
	// (DELETE /nf-instances/{nfInstanceID})
	DeregisterNFInstance(c *gin.Context, nfInstanceID externalRef0.NfInstanceId)
	// Read the profile of a given NF Instance
	// (GET /nf-instances/{nfInstanceID})
	GetNFInstance(c *gin.Context, nfInstanceID externalRef0.NfInstanceId, params GetNFInstanceParams)
	// Update NF Instance profile
	// (PATCH /nf-instances/{nfInstanceID})
	UpdateNFInstance(c *gin.Context, nfInstanceID externalRef0.NfInstanceId, params UpdateNFInstanceParams)
	// Register a new NF Instance
	// (PUT /nf-instances/{nfInstanceID})
	RegisterNFInstance(c *gin.Context, nfInstanceID externalRef0.NfInstanceId, params RegisterNFInstanceParams)
	// Create a new subscription
	// (POST /subscriptions)
	CreateSubscription(c *gin.Context, params CreateSubscriptionParams)
	// Deletes a subscription
	// (DELETE /subscriptions/{subscriptionID})
	RemoveSubscription(c *gin.Context, subscriptionID string)
	// Updates a subscription
	// (PATCH /subscriptions/{subscriptionID})
	UpdateSubscription(c *gin.Context, subscriptionID string, params UpdateSubscriptionParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetNFInstances operation middleware
func (siw *ServerInterfaceWrapper) GetNFInstances(c *gin.Context) {

	var err error

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-nfm"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNFInstancesParams

	// ------------- Optional query parameter "nf-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "nf-type", c.Request.URL.Query(), &params.NfType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nf-type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetNFInstances(c, params)
}

// OptionsNFInstances operation middleware
func (siw *ServerInterfaceWrapper) OptionsNFInstances(c *gin.Context) {

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-nfm"})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.OptionsNFInstances(c)
}

// DeregisterNFInstance operation middleware
func (siw *ServerInterfaceWrapper) DeregisterNFInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "nfInstanceID" -------------
	var nfInstanceID externalRef0.NfInstanceId

	err = runtime.BindStyledParameter("simple", false, "nfInstanceID", c.Param("nfInstanceID"), &nfInstanceID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nfInstanceID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-nfm"})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeregisterNFInstance(c, nfInstanceID)
}

// GetNFInstance operation middleware
func (siw *ServerInterfaceWrapper) GetNFInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "nfInstanceID" -------------
	var nfInstanceID externalRef0.NfInstanceId

	err = runtime.BindStyledParameter("simple", false, "nfInstanceID", c.Param("nfInstanceID"), &nfInstanceID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nfInstanceID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-nfm"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetNFInstanceParams

	// ------------- Optional query parameter "requester-features" -------------

	err = runtime.BindQueryParameter("form", true, false, "requester-features", c.Request.URL.Query(), &params.RequesterFeatures)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter requester-features: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetNFInstance(c, nfInstanceID, params)
}

// UpdateNFInstance operation middleware
func (siw *ServerInterfaceWrapper) UpdateNFInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "nfInstanceID" -------------
	var nfInstanceID externalRef0.NfInstanceId

	err = runtime.BindStyledParameter("simple", false, "nfInstanceID", c.Param("nfInstanceID"), &nfInstanceID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nfInstanceID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-nfm"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateNFInstanceParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Content-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-Encoding")]; found {
		var ContentEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Content-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Content-Encoding", runtime.ParamLocationHeader, valueList[0], &ContentEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Content-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.ContentEncoding = &ContentEncoding

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, valueList[0], &AcceptEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for If-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter If-Match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateNFInstance(c, nfInstanceID, params)
}

// RegisterNFInstance operation middleware
func (siw *ServerInterfaceWrapper) RegisterNFInstance(c *gin.Context) {

	var err error

	// ------------- Path parameter "nfInstanceID" -------------
	var nfInstanceID externalRef0.NfInstanceId

	err = runtime.BindStyledParameter("simple", false, "nfInstanceID", c.Param("nfInstanceID"), &nfInstanceID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nfInstanceID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-nfm"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RegisterNFInstanceParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Content-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-Encoding")]; found {
		var ContentEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Content-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Content-Encoding", runtime.ParamLocationHeader, valueList[0], &ContentEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Content-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.ContentEncoding = &ContentEncoding

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, valueList[0], &AcceptEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RegisterNFInstance(c, nfInstanceID, params)
}

// CreateSubscription operation middleware
func (siw *ServerInterfaceWrapper) CreateSubscription(c *gin.Context) {

	var err error

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-nfm"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateSubscriptionParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Content-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-Encoding")]; found {
		var ContentEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Content-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Content-Encoding", runtime.ParamLocationHeader, valueList[0], &ContentEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Content-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.ContentEncoding = &ContentEncoding

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, valueList[0], &AcceptEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateSubscription(c, params)
}

// RemoveSubscription operation middleware
func (siw *ServerInterfaceWrapper) RemoveSubscription(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionID" -------------
	var subscriptionID string

	err = runtime.BindStyledParameter("simple", false, "subscriptionID", c.Param("subscriptionID"), &subscriptionID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-nfm"})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RemoveSubscription(c, subscriptionID)
}

// UpdateSubscription operation middleware
func (siw *ServerInterfaceWrapper) UpdateSubscription(c *gin.Context) {

	var err error

	// ------------- Path parameter "subscriptionID" -------------
	var subscriptionID string

	err = runtime.BindStyledParameter("simple", false, "subscriptionID", c.Param("subscriptionID"), &subscriptionID)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter subscriptionID: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientCredentialsScopes, []string{"nnrf-nfm"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateSubscriptionParams

	headers := c.Request.Header

	// ------------- Optional header parameter "Content-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-Encoding")]; found {
		var ContentEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Content-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Content-Encoding", runtime.ParamLocationHeader, valueList[0], &ContentEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Content-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.ContentEncoding = &ContentEncoding

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Accept-Encoding, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Accept-Encoding", runtime.ParamLocationHeader, valueList[0], &AcceptEncoding)
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Accept-Encoding: %w", err), http.StatusBadRequest)
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateSubscription(c, subscriptionID, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/nf-instances", wrapper.GetNFInstances)
	router.OPTIONS(options.BaseURL+"/nf-instances", wrapper.OptionsNFInstances)
	router.DELETE(options.BaseURL+"/nf-instances/:nfInstanceID", wrapper.DeregisterNFInstance)
	router.GET(options.BaseURL+"/nf-instances/:nfInstanceID", wrapper.GetNFInstance)
	router.PATCH(options.BaseURL+"/nf-instances/:nfInstanceID", wrapper.UpdateNFInstance)
	router.PUT(options.BaseURL+"/nf-instances/:nfInstanceID", wrapper.RegisterNFInstance)
	router.POST(options.BaseURL+"/subscriptions", wrapper.CreateSubscription)
	router.DELETE(options.BaseURL+"/subscriptions/:subscriptionID", wrapper.RemoveSubscription)
	router.PATCH(options.BaseURL+"/subscriptions/:subscriptionID", wrapper.UpdateSubscription)
}

type GetNFInstancesRequestObject struct {
	Params GetNFInstancesParams
}

type GetNFInstancesResponseObject interface {
	VisitGetNFInstancesResponse(w http.ResponseWriter) error
}

type GetNFInstances200Application3gppHalPlusJSONResponse struct {
	// Links List of the URI of NF instances. It has two members whose names are item and self. The item one contains an array of URIs.
	Links                *map[string]externalRef0.LinksValueSchema `json:"_links,omitempty"`
	AdditionalProperties map[string]interface{}                    `json:"-"`
}

func (response GetNFInstances200Application3gppHalPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/3gppHal+json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances307ResponseHeaders struct {
	Location string
}

type GetNFInstances307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers GetNFInstances307ResponseHeaders
}

func (response GetNFInstances307JSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetNFInstances308ResponseHeaders struct {
	Location string
}

type GetNFInstances308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers GetNFInstances308ResponseHeaders
}

func (response GetNFInstances308JSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetNFInstances400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances400ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances401ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances403ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances404ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances406Response externalRef0.N406Response

func (response GetNFInstances406Response) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.WriteHeader(406)
	return nil
}

type GetNFInstances411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances411ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances413ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances415ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances429ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances500ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances501ApplicationProblemPlusJSONResponse struct {
	externalRef0.N501ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances501ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstances503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response GetNFInstances503ApplicationProblemPlusJSONResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstancesdefaultResponse struct {
	StatusCode int
}

func (response GetNFInstancesdefaultResponse) VisitGetNFInstancesResponse(w http.ResponseWriter) error {
	w.WriteHeader(response.StatusCode)
	return nil
}

type OptionsNFInstancesRequestObject struct {
}

type OptionsNFInstancesResponseObject interface {
	VisitOptionsNFInstancesResponse(w http.ResponseWriter) error
}

type OptionsNFInstances200ResponseHeaders struct {
	AcceptEncoding string
}

type OptionsNFInstances200JSONResponse struct {
	Body    OptionsResponse
	Headers OptionsNFInstances200ResponseHeaders
}

func (response OptionsNFInstances200JSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Accept-Encoding", fmt.Sprint(response.Headers.AcceptEncoding))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type OptionsNFInstances204ResponseHeaders struct {
	AcceptEncoding string
}

type OptionsNFInstances204Response struct {
	Headers OptionsNFInstances204ResponseHeaders
}

func (response OptionsNFInstances204Response) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Accept-Encoding", fmt.Sprint(response.Headers.AcceptEncoding))
	w.WriteHeader(204)
	return nil
}

type OptionsNFInstances307ResponseHeaders struct {
	Location string
}

type OptionsNFInstances307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers OptionsNFInstances307ResponseHeaders
}

func (response OptionsNFInstances307JSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type OptionsNFInstances308ResponseHeaders struct {
	Location string
}

type OptionsNFInstances308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers OptionsNFInstances308ResponseHeaders
}

func (response OptionsNFInstances308JSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type OptionsNFInstances400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response OptionsNFInstances400ApplicationProblemPlusJSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type OptionsNFInstances401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response OptionsNFInstances401ApplicationProblemPlusJSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type OptionsNFInstances403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response OptionsNFInstances403ApplicationProblemPlusJSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type OptionsNFInstances404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response OptionsNFInstances404ApplicationProblemPlusJSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type OptionsNFInstances405Response externalRef0.N405Response

func (response OptionsNFInstances405Response) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.WriteHeader(405)
	return nil
}

type OptionsNFInstances429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response OptionsNFInstances429ApplicationProblemPlusJSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type OptionsNFInstances500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response OptionsNFInstances500ApplicationProblemPlusJSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type OptionsNFInstances501ApplicationProblemPlusJSONResponse struct {
	externalRef0.N501ApplicationProblemPlusJSONResponse
}

func (response OptionsNFInstances501ApplicationProblemPlusJSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type OptionsNFInstances503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response OptionsNFInstances503ApplicationProblemPlusJSONResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type OptionsNFInstancesdefaultResponse struct {
	StatusCode int
}

func (response OptionsNFInstancesdefaultResponse) VisitOptionsNFInstancesResponse(w http.ResponseWriter) error {
	w.WriteHeader(response.StatusCode)
	return nil
}

type DeregisterNFInstanceRequestObject struct {
	NfInstanceID externalRef0.NfInstanceId `json:"nfInstanceID"`
}

type DeregisterNFInstanceResponseObject interface {
	VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error
}

type DeregisterNFInstance204Response struct {
}

func (response DeregisterNFInstance204Response) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeregisterNFInstance307ResponseHeaders struct {
	Location string
}

type DeregisterNFInstance307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers DeregisterNFInstance307ResponseHeaders
}

func (response DeregisterNFInstance307JSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeregisterNFInstance308ResponseHeaders struct {
	Location string
}

type DeregisterNFInstance308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers DeregisterNFInstance308ResponseHeaders
}

func (response DeregisterNFInstance308JSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeregisterNFInstance400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response DeregisterNFInstance400ApplicationProblemPlusJSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeregisterNFInstance401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response DeregisterNFInstance401ApplicationProblemPlusJSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type DeregisterNFInstance403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response DeregisterNFInstance403ApplicationProblemPlusJSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeregisterNFInstance404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response DeregisterNFInstance404ApplicationProblemPlusJSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeregisterNFInstance411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response DeregisterNFInstance411ApplicationProblemPlusJSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(response)
}

type DeregisterNFInstance429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response DeregisterNFInstance429ApplicationProblemPlusJSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type DeregisterNFInstance500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response DeregisterNFInstance500ApplicationProblemPlusJSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeregisterNFInstance501ApplicationProblemPlusJSONResponse struct {
	externalRef0.N501ApplicationProblemPlusJSONResponse
}

func (response DeregisterNFInstance501ApplicationProblemPlusJSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type DeregisterNFInstance503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response DeregisterNFInstance503ApplicationProblemPlusJSONResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type DeregisterNFInstancedefaultResponse struct {
	StatusCode int
}

func (response DeregisterNFInstancedefaultResponse) VisitDeregisterNFInstanceResponse(w http.ResponseWriter) error {
	w.WriteHeader(response.StatusCode)
	return nil
}

type GetNFInstanceRequestObject struct {
	NfInstanceID externalRef0.NfInstanceId `json:"nfInstanceID"`
	Params       GetNFInstanceParams
}

type GetNFInstanceResponseObject interface {
	VisitGetNFInstanceResponse(w http.ResponseWriter) error
}

type GetNFInstance200ResponseHeaders struct {
	ETag string
}

type GetNFInstance200JSONResponse struct {
	Body    NFProfile
	Headers GetNFInstance200ResponseHeaders
}

func (response GetNFInstance200JSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("ETag", fmt.Sprint(response.Headers.ETag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetNFInstance307ResponseHeaders struct {
	Location string
}

type GetNFInstance307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers GetNFInstance307ResponseHeaders
}

func (response GetNFInstance307JSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetNFInstance308ResponseHeaders struct {
	Location string
}

type GetNFInstance308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers GetNFInstance308ResponseHeaders
}

func (response GetNFInstance308JSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetNFInstance400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance400ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstance401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance401ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstance403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance403ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstance404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance404ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstance406Response externalRef0.N406Response

func (response GetNFInstance406Response) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.WriteHeader(406)
	return nil
}

type GetNFInstance411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance411ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstance413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance413ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstance415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance415ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstance429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance429ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstance500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance500ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstance501ApplicationProblemPlusJSONResponse struct {
	externalRef0.N501ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance501ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstance503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response GetNFInstance503ApplicationProblemPlusJSONResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type GetNFInstancedefaultResponse struct {
	StatusCode int
}

func (response GetNFInstancedefaultResponse) VisitGetNFInstanceResponse(w http.ResponseWriter) error {
	w.WriteHeader(response.StatusCode)
	return nil
}

type UpdateNFInstanceRequestObject struct {
	NfInstanceID externalRef0.NfInstanceId `json:"nfInstanceID"`
	Params       UpdateNFInstanceParams
	Body         *UpdateNFInstanceApplicationJSONPatchPlusJSONRequestBody
}

type UpdateNFInstanceResponseObject interface {
	VisitUpdateNFInstanceResponse(w http.ResponseWriter) error
}

type UpdateNFInstance200ResponseHeaders struct {
	AcceptEncoding  string
	ContentEncoding string
	ETag            string
}

type UpdateNFInstance200JSONResponse struct {
	Body    NFProfile
	Headers UpdateNFInstance200ResponseHeaders
}

func (response UpdateNFInstance200JSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Accept-Encoding", fmt.Sprint(response.Headers.AcceptEncoding))
	w.Header().Set("Content-Encoding", fmt.Sprint(response.Headers.ContentEncoding))
	w.Header().Set("ETag", fmt.Sprint(response.Headers.ETag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateNFInstance204ResponseHeaders struct {
	AcceptEncoding string
}

type UpdateNFInstance204Response struct {
	Headers UpdateNFInstance204ResponseHeaders
}

func (response UpdateNFInstance204Response) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Accept-Encoding", fmt.Sprint(response.Headers.AcceptEncoding))
	w.WriteHeader(204)
	return nil
}

type UpdateNFInstance307ResponseHeaders struct {
	Location string
}

type UpdateNFInstance307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers UpdateNFInstance307ResponseHeaders
}

func (response UpdateNFInstance307JSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateNFInstance308ResponseHeaders struct {
	Location string
}

type UpdateNFInstance308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers UpdateNFInstance308ResponseHeaders
}

func (response UpdateNFInstance308JSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateNFInstance400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance400ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance403ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance404ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance409ApplicationProblemPlusJSONResponse struct {
	externalRef0.N409ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance409ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance411ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance412ApplicationProblemPlusJSONResponse struct {
	externalRef0.N412ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance412ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(412)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance413ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance415ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance429ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance500ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance501ApplicationProblemPlusJSONResponse struct {
	externalRef0.N501ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance501ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstance503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response UpdateNFInstance503ApplicationProblemPlusJSONResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type UpdateNFInstancedefaultResponse struct {
	StatusCode int
}

func (response UpdateNFInstancedefaultResponse) VisitUpdateNFInstanceResponse(w http.ResponseWriter) error {
	w.WriteHeader(response.StatusCode)
	return nil
}

type RegisterNFInstanceRequestObject struct {
	NfInstanceID externalRef0.NfInstanceId `json:"nfInstanceID"`
	Params       RegisterNFInstanceParams
	Body         *RegisterNFInstanceJSONRequestBody
}

type RegisterNFInstanceResponseObject interface {
	VisitRegisterNFInstanceResponse(w http.ResponseWriter) error
}

type RegisterNFInstance200ResponseHeaders struct {
	AcceptEncoding  string
	ContentEncoding string
	ETag            string
}

type RegisterNFInstance200JSONResponse struct {
	Body    NFProfile
	Headers RegisterNFInstance200ResponseHeaders
}

func (response RegisterNFInstance200JSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Accept-Encoding", fmt.Sprint(response.Headers.AcceptEncoding))
	w.Header().Set("Content-Encoding", fmt.Sprint(response.Headers.ContentEncoding))
	w.Header().Set("ETag", fmt.Sprint(response.Headers.ETag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type RegisterNFInstance201ResponseHeaders struct {
	AcceptEncoding  string
	ContentEncoding string
	ETag            string
	Location        string
}

type RegisterNFInstance201JSONResponse struct {
	Body    NFProfile
	Headers RegisterNFInstance201ResponseHeaders
}

func (response RegisterNFInstance201JSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Accept-Encoding", fmt.Sprint(response.Headers.AcceptEncoding))
	w.Header().Set("Content-Encoding", fmt.Sprint(response.Headers.ContentEncoding))
	w.Header().Set("ETag", fmt.Sprint(response.Headers.ETag))
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response.Body)
}

type RegisterNFInstance307ResponseHeaders struct {
	Location string
}

type RegisterNFInstance307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers RegisterNFInstance307ResponseHeaders
}

func (response RegisterNFInstance307JSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type RegisterNFInstance308ResponseHeaders struct {
	Location string
}

type RegisterNFInstance308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers RegisterNFInstance308ResponseHeaders
}

func (response RegisterNFInstance308JSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type RegisterNFInstance400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance400ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstance401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance401ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstance403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance403ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstance404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance404ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstance411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance411ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstance413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance413ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstance415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance415ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstance429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance429ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstance500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance500ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstance501ApplicationProblemPlusJSONResponse struct {
	externalRef0.N501ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance501ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstance503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response RegisterNFInstance503ApplicationProblemPlusJSONResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type RegisterNFInstancedefaultResponse struct {
	StatusCode int
}

func (response RegisterNFInstancedefaultResponse) VisitRegisterNFInstanceResponse(w http.ResponseWriter) error {
	w.WriteHeader(response.StatusCode)
	return nil
}

type CreateSubscriptionRequestObject struct {
	Params CreateSubscriptionParams
	Body   *CreateSubscriptionJSONRequestBody
}

type CreateSubscriptionResponseObject interface {
	VisitCreateSubscriptionResponse(w http.ResponseWriter) error
}

type CreateSubscription201ResponseHeaders struct {
	AcceptEncoding  string
	ContentEncoding string
	Location        string
}

type CreateSubscription201JSONResponse struct {
	Body    SubscriptionData
	Headers CreateSubscription201ResponseHeaders
}

func (response CreateSubscription201JSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Accept-Encoding", fmt.Sprint(response.Headers.AcceptEncoding))
	w.Header().Set("Content-Encoding", fmt.Sprint(response.Headers.ContentEncoding))
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateSubscription307ResponseHeaders struct {
	Location string
}

type CreateSubscription307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers CreateSubscription307ResponseHeaders
}

func (response CreateSubscription307JSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateSubscription308ResponseHeaders struct {
	Location string
}

type CreateSubscription308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers CreateSubscription308ResponseHeaders
}

func (response CreateSubscription308JSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateSubscription400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription400ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscription401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription401ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscription403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription403ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscription404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription404ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscription411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription411ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscription413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription413ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscription415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription415ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscription429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription429ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscription500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription500ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscription501ApplicationProblemPlusJSONResponse struct {
	externalRef0.N501ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription501ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscription503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response CreateSubscription503ApplicationProblemPlusJSONResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type CreateSubscriptiondefaultResponse struct {
	StatusCode int
}

func (response CreateSubscriptiondefaultResponse) VisitCreateSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(response.StatusCode)
	return nil
}

type RemoveSubscriptionRequestObject struct {
	SubscriptionID string `json:"subscriptionID"`
}

type RemoveSubscriptionResponseObject interface {
	VisitRemoveSubscriptionResponse(w http.ResponseWriter) error
}

type RemoveSubscription204Response struct {
}

func (response RemoveSubscription204Response) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type RemoveSubscription307ResponseHeaders struct {
	Location string
}

type RemoveSubscription307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers RemoveSubscription307ResponseHeaders
}

func (response RemoveSubscription307JSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type RemoveSubscription308ResponseHeaders struct {
	Location string
}

type RemoveSubscription308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers RemoveSubscription308ResponseHeaders
}

func (response RemoveSubscription308JSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type RemoveSubscription400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription400ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscription401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription401ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscription403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription403ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscription404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription404ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscription411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription411ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscription413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription413ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscription415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription415ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscription429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription429ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscription500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription500ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscription501ApplicationProblemPlusJSONResponse struct {
	externalRef0.N501ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription501ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscription503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response RemoveSubscription503ApplicationProblemPlusJSONResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type RemoveSubscriptiondefaultResponse struct {
	StatusCode int
}

func (response RemoveSubscriptiondefaultResponse) VisitRemoveSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(response.StatusCode)
	return nil
}

type UpdateSubscriptionRequestObject struct {
	SubscriptionID string `json:"subscriptionID"`
	Params         UpdateSubscriptionParams
	Body           *UpdateSubscriptionApplicationJSONPatchPlusJSONRequestBody
}

type UpdateSubscriptionResponseObject interface {
	VisitUpdateSubscriptionResponse(w http.ResponseWriter) error
}

type UpdateSubscription200ResponseHeaders struct {
	AcceptEncoding  string
	ContentEncoding string
}

type UpdateSubscription200JSONResponse struct {
	Body    SubscriptionData
	Headers UpdateSubscription200ResponseHeaders
}

func (response UpdateSubscription200JSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Accept-Encoding", fmt.Sprint(response.Headers.AcceptEncoding))
	w.Header().Set("Content-Encoding", fmt.Sprint(response.Headers.ContentEncoding))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateSubscription204ResponseHeaders struct {
	AcceptEncoding string
}

type UpdateSubscription204Response struct {
	Headers UpdateSubscription204ResponseHeaders
}

func (response UpdateSubscription204Response) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Accept-Encoding", fmt.Sprint(response.Headers.AcceptEncoding))
	w.WriteHeader(204)
	return nil
}

type UpdateSubscription307ResponseHeaders struct {
	Location string
}

type UpdateSubscription307JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers UpdateSubscription307ResponseHeaders
}

func (response UpdateSubscription307JSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateSubscription308ResponseHeaders struct {
	Location string
}

type UpdateSubscription308JSONResponse struct {
	Body    externalRef0.RedirectResponse
	Headers UpdateSubscription308ResponseHeaders
}

func (response UpdateSubscription308JSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateSubscription400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response UpdateSubscription400ApplicationProblemPlusJSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSubscription403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response UpdateSubscription403ApplicationProblemPlusJSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSubscription404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response UpdateSubscription404ApplicationProblemPlusJSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSubscription411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response UpdateSubscription411ApplicationProblemPlusJSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSubscription413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response UpdateSubscription413ApplicationProblemPlusJSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSubscription415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response UpdateSubscription415ApplicationProblemPlusJSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSubscription429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response UpdateSubscription429ApplicationProblemPlusJSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSubscription500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response UpdateSubscription500ApplicationProblemPlusJSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSubscription501ApplicationProblemPlusJSONResponse struct {
	externalRef0.N501ApplicationProblemPlusJSONResponse
}

func (response UpdateSubscription501ApplicationProblemPlusJSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(501)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSubscription503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response UpdateSubscription503ApplicationProblemPlusJSONResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSubscriptiondefaultResponse struct {
	StatusCode int
}

func (response UpdateSubscriptiondefaultResponse) VisitUpdateSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(response.StatusCode)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Retrieves a collection of NF Instances
	// (GET /nf-instances)
	GetNFInstances(ctx context.Context, request GetNFInstancesRequestObject) (GetNFInstancesResponseObject, error)
	// Discover communication options supported by NRF for NF Instances
	// (OPTIONS /nf-instances)
	OptionsNFInstances(ctx context.Context, request OptionsNFInstancesRequestObject) (OptionsNFInstancesResponseObject, error)
	// Deregisters a given NF Instance
	// (DELETE /nf-instances/{nfInstanceID})
	DeregisterNFInstance(ctx context.Context, request DeregisterNFInstanceRequestObject) (DeregisterNFInstanceResponseObject, error)
	// Read the profile of a given NF Instance
	// (GET /nf-instances/{nfInstanceID})
	GetNFInstance(ctx context.Context, request GetNFInstanceRequestObject) (GetNFInstanceResponseObject, error)
	// Update NF Instance profile
	// (PATCH /nf-instances/{nfInstanceID})
	UpdateNFInstance(ctx context.Context, request UpdateNFInstanceRequestObject) (UpdateNFInstanceResponseObject, error)
	// Register a new NF Instance
	// (PUT /nf-instances/{nfInstanceID})
	RegisterNFInstance(ctx context.Context, request RegisterNFInstanceRequestObject) (RegisterNFInstanceResponseObject, error)
	// Create a new subscription
	// (POST /subscriptions)
	CreateSubscription(ctx context.Context, request CreateSubscriptionRequestObject) (CreateSubscriptionResponseObject, error)
	// Deletes a subscription
	// (DELETE /subscriptions/{subscriptionID})
	RemoveSubscription(ctx context.Context, request RemoveSubscriptionRequestObject) (RemoveSubscriptionResponseObject, error)
	// Updates a subscription
	// (PATCH /subscriptions/{subscriptionID})
	UpdateSubscription(ctx context.Context, request UpdateSubscriptionRequestObject) (UpdateSubscriptionResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// GetNFInstances operation middleware
func (sh *strictHandler) GetNFInstances(ctx *gin.Context, params GetNFInstancesParams) {
	var request GetNFInstancesRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetNFInstances(ctx, request.(GetNFInstancesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetNFInstances")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetNFInstancesResponseObject); ok {
		if err := validResponse.VisitGetNFInstancesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// OptionsNFInstances operation middleware
func (sh *strictHandler) OptionsNFInstances(ctx *gin.Context) {
	var request OptionsNFInstancesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.OptionsNFInstances(ctx, request.(OptionsNFInstancesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "OptionsNFInstances")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(OptionsNFInstancesResponseObject); ok {
		if err := validResponse.VisitOptionsNFInstancesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeregisterNFInstance operation middleware
func (sh *strictHandler) DeregisterNFInstance(ctx *gin.Context, nfInstanceID externalRef0.NfInstanceId) {
	var request DeregisterNFInstanceRequestObject

	request.NfInstanceID = nfInstanceID

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeregisterNFInstance(ctx, request.(DeregisterNFInstanceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeregisterNFInstance")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeregisterNFInstanceResponseObject); ok {
		if err := validResponse.VisitDeregisterNFInstanceResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetNFInstance operation middleware
func (sh *strictHandler) GetNFInstance(ctx *gin.Context, nfInstanceID externalRef0.NfInstanceId, params GetNFInstanceParams) {
	var request GetNFInstanceRequestObject

	request.NfInstanceID = nfInstanceID
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetNFInstance(ctx, request.(GetNFInstanceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetNFInstance")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetNFInstanceResponseObject); ok {
		if err := validResponse.VisitGetNFInstanceResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateNFInstance operation middleware
func (sh *strictHandler) UpdateNFInstance(ctx *gin.Context, nfInstanceID externalRef0.NfInstanceId, params UpdateNFInstanceParams) {
	var request UpdateNFInstanceRequestObject

	request.NfInstanceID = nfInstanceID
	request.Params = params

	var body UpdateNFInstanceApplicationJSONPatchPlusJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateNFInstance(ctx, request.(UpdateNFInstanceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateNFInstance")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UpdateNFInstanceResponseObject); ok {
		if err := validResponse.VisitUpdateNFInstanceResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// RegisterNFInstance operation middleware
func (sh *strictHandler) RegisterNFInstance(ctx *gin.Context, nfInstanceID externalRef0.NfInstanceId, params RegisterNFInstanceParams) {
	var request RegisterNFInstanceRequestObject

	request.NfInstanceID = nfInstanceID
	request.Params = params

	var body RegisterNFInstanceJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RegisterNFInstance(ctx, request.(RegisterNFInstanceRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RegisterNFInstance")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(RegisterNFInstanceResponseObject); ok {
		if err := validResponse.VisitRegisterNFInstanceResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateSubscription operation middleware
func (sh *strictHandler) CreateSubscription(ctx *gin.Context, params CreateSubscriptionParams) {
	var request CreateSubscriptionRequestObject

	request.Params = params

	var body CreateSubscriptionJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateSubscription(ctx, request.(CreateSubscriptionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateSubscription")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateSubscriptionResponseObject); ok {
		if err := validResponse.VisitCreateSubscriptionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// RemoveSubscription operation middleware
func (sh *strictHandler) RemoveSubscription(ctx *gin.Context, subscriptionID string) {
	var request RemoveSubscriptionRequestObject

	request.SubscriptionID = subscriptionID

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RemoveSubscription(ctx, request.(RemoveSubscriptionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RemoveSubscription")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(RemoveSubscriptionResponseObject); ok {
		if err := validResponse.VisitRemoveSubscriptionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateSubscription operation middleware
func (sh *strictHandler) UpdateSubscription(ctx *gin.Context, subscriptionID string, params UpdateSubscriptionParams) {
	var request UpdateSubscriptionRequestObject

	request.SubscriptionID = subscriptionID
	request.Params = params

	var body UpdateSubscriptionApplicationJSONPatchPlusJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateSubscription(ctx, request.(UpdateSubscriptionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateSubscription")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UpdateSubscriptionResponseObject); ok {
		if err := validResponse.VisitUpdateSubscriptionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}
