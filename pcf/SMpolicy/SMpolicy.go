// Package SMpolicy provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package SMpolicy

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	externalRef0 "github.com/ShouheiNishi/openapi5g/commondata"
	externalRef1 "github.com/ShouheiNishi/openapi5g/northbound/commondata"
	externalRef2 "github.com/ShouheiNishi/openapi5g/pcf/authorization"
	externalRef3 "github.com/ShouheiNishi/openapi5g/smf/session"
	externalRef4 "github.com/ShouheiNishi/openapi5g/udr/policy"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

const (
	OAuth2ClientcredentialsScopes = "oAuth2Clientcredentials.Scopes"
)

// Defines values for AfSigProtocol0.
const (
	NOINFORMATION AfSigProtocol0 = "NO_INFORMATION"
	SIP           AfSigProtocol0 = "SIP"
)

// Defines values for AtsssCapability.
const (
	AtsssCapabilityATSSSLL                            AtsssCapability = "ATSSS_LL"
	AtsssCapabilityMPTCPATSSSLL                       AtsssCapability = "MPTCP_ATSSS_LL"
	AtsssCapabilityMPTCPATSSSLLWITHASMODEDLUL         AtsssCapability = "MPTCP_ATSSS_LL_WITH_ASMODE_DLUL"
	AtsssCapabilityMPTCPATSSSLLWITHASMODEUL           AtsssCapability = "MPTCP_ATSSS_LL_WITH_ASMODE_UL"
	AtsssCapabilityMPTCPATSSSLLWITHEXSDMODEDLASMODEUL AtsssCapability = "MPTCP_ATSSS_LL_WITH_EXSDMODE_DL_ASMODE_UL"
)

// Defines values for CreditManagementStatus.
const (
	AUTHREJECTED     CreditManagementStatus = "AUTH_REJECTED"
	CREDITCTRLNOTAPP CreditManagementStatus = "CREDIT_CTRL_NOT_APP"
	ENDUSERSERDENIED CreditManagementStatus = "END_USER_SER_DENIED"
	RATINGFAILED     CreditManagementStatus = "RATING_FAILED"
	USERUNKNOWN      CreditManagementStatus = "USER_UNKNOWN"
)

// Defines values for FailureCause.
const (
	PCCQOSFLOWEVENT    FailureCause = "PCC_QOS_FLOW_EVENT"
	PCCRULEEVENT       FailureCause = "PCC_RULE_EVENT"
	POLDECERROR        FailureCause = "POL_DEC_ERROR"
	RULEPERMANENTERROR FailureCause = "RULE_PERMANENT_ERROR"
	RULETEMPORARYERROR FailureCause = "RULE_TEMPORARY_ERROR"
)

// Defines values for FailureCode.
const (
	FailureCodeAPPIDERR           FailureCode = "APP_ID_ERR"
	FailureCodeCMAUTHREJ          FailureCode = "CM_AUTH_REJ"
	FailureCodeCMCREDITCONNOTAPP  FailureCode = "CM_CREDIT_CON_NOT_APP"
	FailureCodeCMENDUSERSERDENIED FailureCode = "CM_END_USER_SER_DENIED"
	FailureCodeCMRATFAILED        FailureCode = "CM_RAT_FAILED"
	FailureCodeCMUSERUNK          FailureCode = "CM_USER_UNK"
	FailureCodeFILTERRES          FailureCode = "FILTER_RES"
	FailureCodeINCORFLOWINFO      FailureCode = "INCOR_FLOW_INFO"
	FailureCodeMAXNRQoSFLOW       FailureCode = "MAX_NR_QoS_FLOW"
	FailureCodeMISSFLOWINFO       FailureCode = "MISS_FLOW_INFO"
	FailureCodeMISSREDISERADDR    FailureCode = "MISS_REDI_SER_ADDR"
	FailureCodeNFMAL              FailureCode = "NF_MAL"
	FailureCodeNOQOSFLOWBOUND     FailureCode = "NO_QOS_FLOW_BOUND"
	FailureCodePSTOCSHAN          FailureCode = "PS_TO_CS_HAN"
	FailureCodeRAGRERR            FailureCode = "RA_GR_ERR"
	FailureCodeRESALLOFAIL        FailureCode = "RES_ALLO_FAIL"
	FailureCodeRESLIM             FailureCode = "RES_LIM"
	FailureCodeSERIDERR           FailureCode = "SER_ID_ERR"
	FailureCodeUESTASUSP          FailureCode = "UE_STA_SUSP"
	FailureCodeUNKRULEID          FailureCode = "UNK_RULE_ID"
	FailureCodeUNSUCCQOSVAL       FailureCode = "UNSUCC_QOS_VAL"
)

// Defines values for FlowDirection.
const (
	FlowDirectionBIDIRECTIONAL FlowDirection = "BIDIRECTIONAL"
	FlowDirectionDOWNLINK      FlowDirection = "DOWNLINK"
	FlowDirectionUNSPECIFIED   FlowDirection = "UNSPECIFIED"
	FlowDirectionUPLINK        FlowDirection = "UPLINK"
)

// Defines values for FlowDirectionRm.
const (
	FlowDirectionRmBIDIRECTIONAL FlowDirectionRm = "BIDIRECTIONAL"
	FlowDirectionRmDOWNLINK      FlowDirectionRm = "DOWNLINK"
	FlowDirectionRmUNSPECIFIED   FlowDirectionRm = "UNSPECIFIED"
	FlowDirectionRmUPLINK        FlowDirectionRm = "UPLINK"
)

// Defines values for MaPduIndication.
const (
	MAPDUNETWORKUPGRADEALLOWED MaPduIndication = "MA_PDU_NETWORK_UPGRADE_ALLOWED"
	MAPDUREQUEST               MaPduIndication = "MA_PDU_REQUEST"
)

// Defines values for MeteringMethod0.
const (
	DURATION       MeteringMethod0 = "DURATION"
	DURATIONVOLUME MeteringMethod0 = "DURATION_VOLUME"
	EVENT          MeteringMethod0 = "EVENT"
	VOLUME         MeteringMethod0 = "VOLUME"
)

// Defines values for MulticastAccessControl.
const (
	ALLOWED    MulticastAccessControl = "ALLOWED"
	NOTALLOWED MulticastAccessControl = "NOT_ALLOWED"
)

// Defines values for NetLocAccessSupport.
const (
	ANRNOTSUPPORTED NetLocAccessSupport = "ANR_NOT_SUPPORTED"
	LOCNOTSUPPORTED NetLocAccessSupport = "LOC_NOT_SUPPORTED"
	TZRNOTSUPPORTED NetLocAccessSupport = "TZR_NOT_SUPPORTED"
)

// Defines values for NotificationControlIndication.
const (
	NotificationControlIndicationDDDSTATUS  NotificationControlIndication = "DDD_STATUS"
	NotificationControlIndicationDDNFAILURE NotificationControlIndication = "DDN_FAILURE"
)

// Defines values for PduSessionRelCause.
const (
	PSTOCSHO PduSessionRelCause = "PS_TO_CS_HO"
)

// Defines values for PolicyControlRequestTrigger.
const (
	PolicyControlRequestTriggerACTYCH                        PolicyControlRequestTrigger = "AC_TY_CH"
	PolicyControlRequestTriggerANCHCOR                       PolicyControlRequestTrigger = "AN_CH_COR"
	PolicyControlRequestTriggerANINFO                        PolicyControlRequestTrigger = "AN_INFO"
	PolicyControlRequestTriggerAPPSTA                        PolicyControlRequestTrigger = "APP_STA"
	PolicyControlRequestTriggerAPPSTO                        PolicyControlRequestTrigger = "APP_STO"
	PolicyControlRequestTriggerAUTHPROFCH                    PolicyControlRequestTrigger = "AUTH_PROF_CH"
	PolicyControlRequestTriggerCMSESFAIL                     PolicyControlRequestTrigger = "CM_SES_FAIL"
	PolicyControlRequestTriggerDDNDELIVERYSTATUS             PolicyControlRequestTrigger = "DDN_DELIVERY_STATUS"
	PolicyControlRequestTriggerDDNDELIVERYSTATUSCANCELLATION PolicyControlRequestTrigger = "DDN_DELIVERY_STATUS_CANCELLATION"
	PolicyControlRequestTriggerDDNFAILURE                    PolicyControlRequestTrigger = "DDN_FAILURE"
	PolicyControlRequestTriggerDDNFAILURECANCELLATION        PolicyControlRequestTrigger = "DDN_FAILURE_CANCELLATION"
	PolicyControlRequestTriggerDEFQOSCH                      PolicyControlRequestTrigger = "DEF_QOS_CH"
	PolicyControlRequestTriggerEPSFALLBACK                   PolicyControlRequestTrigger = "EPS_FALLBACK"
	PolicyControlRequestTriggerGROUPIDLISTCHG                PolicyControlRequestTrigger = "GROUP_ID_LIST_CHG"
	PolicyControlRequestTriggerMAPDU                         PolicyControlRequestTrigger = "MA_PDU"
	PolicyControlRequestTriggerN5GRGJOIN                     PolicyControlRequestTrigger = "5G_RG_JOIN"
	PolicyControlRequestTriggerN5GRGLEAVE                    PolicyControlRequestTrigger = "5G_RG_LEAVE"
	PolicyControlRequestTriggerNOCREDIT                      PolicyControlRequestTrigger = "NO_CREDIT"
	PolicyControlRequestTriggerNUMOFPACKETFILTER             PolicyControlRequestTrigger = "NUM_OF_PACKET_FILTER"
	PolicyControlRequestTriggerPLMNCH                        PolicyControlRequestTrigger = "PLMN_CH"
	PolicyControlRequestTriggerPRACH                         PolicyControlRequestTrigger = "PRA_CH"
	PolicyControlRequestTriggerPSDAOFF                       PolicyControlRequestTrigger = "PS_DA_OFF"
	PolicyControlRequestTriggerQOSMONITORING                 PolicyControlRequestTrigger = "QOS_MONITORING"
	PolicyControlRequestTriggerQOSNOTIF                      PolicyControlRequestTrigger = "QOS_NOTIF"
	PolicyControlRequestTriggerRATTYCH                       PolicyControlRequestTrigger = "RAT_TY_CH"
	PolicyControlRequestTriggerREALLOOFCREDIT                PolicyControlRequestTrigger = "REALLO_OF_CREDIT"
	PolicyControlRequestTriggerREFQOSINDCH                   PolicyControlRequestTrigger = "REF_QOS_IND_CH"
	PolicyControlRequestTriggerRESMORE                       PolicyControlRequestTrigger = "RES_MO_RE"
	PolicyControlRequestTriggerRESRELEASE                    PolicyControlRequestTrigger = "RES_RELEASE"
	PolicyControlRequestTriggerRETIMEOUT                     PolicyControlRequestTrigger = "RE_TIMEOUT"
	PolicyControlRequestTriggerSAREACH                       PolicyControlRequestTrigger = "SAREA_CH"
	PolicyControlRequestTriggerSCELLCH                       PolicyControlRequestTrigger = "SCELL_CH"
	PolicyControlRequestTriggerSCNNCH                        PolicyControlRequestTrigger = "SCNN_CH"
	PolicyControlRequestTriggerSEAMBRCH                      PolicyControlRequestTrigger = "SE_AMBR_CH"
	PolicyControlRequestTriggerSUCCRESALLO                   PolicyControlRequestTrigger = "SUCC_RES_ALLO"
	PolicyControlRequestTriggerTSNBRIDGEINFO                 PolicyControlRequestTrigger = "TSN_BRIDGE_INFO"
	PolicyControlRequestTriggerUEIPCH                        PolicyControlRequestTrigger = "UE_IP_CH"
	PolicyControlRequestTriggerUEMACCH                       PolicyControlRequestTrigger = "UE_MAC_CH"
	PolicyControlRequestTriggerUESTATUSRESUME                PolicyControlRequestTrigger = "UE_STATUS_RESUME"
	PolicyControlRequestTriggerUETZCH                        PolicyControlRequestTrigger = "UE_TZ_CH"
	PolicyControlRequestTriggerUSRE                          PolicyControlRequestTrigger = "US_RE"
	PolicyControlRequestTriggerVPLMNQOSCH                    PolicyControlRequestTrigger = "VPLMN_QOS_CH"
)

// Defines values for PolicyDecisionFailureCode.
const (
	CHGDECSERR     PolicyDecisionFailureCode = "CHG_DECS_ERR"
	CONDATAERR     PolicyDecisionFailureCode = "CON_DATA_ERR"
	QOSDECSERR     PolicyDecisionFailureCode = "QOS_DECS_ERR"
	QOSMONDECSERR  PolicyDecisionFailureCode = "QOS_MON_DECS_ERR"
	TRACTRLDECSERR PolicyDecisionFailureCode = "TRA_CTRL_DECS_ERR"
	USAMONDECSERR  PolicyDecisionFailureCode = "USA_MON_DECS_ERR"
)

// Defines values for QosFlowUsage.
const (
	GENERAL QosFlowUsage = "GENERAL"
	IMSSIG  QosFlowUsage = "IMS_SIG"
)

// Defines values for RedirectAddressType.
const (
	IPV4ADDR RedirectAddressType = "IPV4_ADDR"
	IPV6ADDR RedirectAddressType = "IPV6_ADDR"
	SIPURI   RedirectAddressType = "SIP_URI"
	URL      RedirectAddressType = "URL"
)

// Defines values for ReportingFrequency.
const (
	EVENTTRIGGERED ReportingFrequency = "EVENT_TRIGGERED"
	PERIODIC       ReportingFrequency = "PERIODIC"
)

// Defines values for ReportingLevel0.
const (
	RATGRLEVEL   ReportingLevel0 = "RAT_GR_LEVEL"
	SERIDLEVEL   ReportingLevel0 = "SER_ID_LEVEL"
	SPONCONLEVEL ReportingLevel0 = "SPON_CON_LEVEL"
)

// Defines values for RequestedQosMonitoringParameter.
const (
	DOWNLINK  RequestedQosMonitoringParameter = "DOWNLINK"
	ROUNDTRIP RequestedQosMonitoringParameter = "ROUND_TRIP"
	UPLINK    RequestedQosMonitoringParameter = "UPLINK"
)

// Defines values for RequestedRuleDataType.
const (
	CHID        RequestedRuleDataType = "CH_ID"
	EPSFALLBACK RequestedRuleDataType = "EPS_FALLBACK"
	MSTIMEZONE  RequestedRuleDataType = "MS_TIME_ZONE"
	RESRELEASE  RequestedRuleDataType = "RES_RELEASE"
	SUCCRESALLO RequestedRuleDataType = "SUCC_RES_ALLO"
	USERLOCINFO RequestedRuleDataType = "USER_LOC_INFO"
)

// Defines values for RuleOperation.
const (
	CREATEPCCRULE                           RuleOperation = "CREATE_PCC_RULE"
	DELETEPCCRULE                           RuleOperation = "DELETE_PCC_RULE"
	MODIFYPCCRULEANDADDPACKETFILTERS        RuleOperation = "MODIFY_PCC_RULE_AND_ADD_PACKET_FILTERS"
	MODIFYPCCRULEANDDELETEPACKETFILTERS     RuleOperation = "MODIFY_ PCC_RULE_AND_DELETE_PACKET_FILTERS"
	MODIFYPCCRULEANDREPLACEPACKETFILTERS    RuleOperation = "MODIFY_ PCC_RULE_AND_REPLACE_PACKET_FILTERS"
	MODIFYPCCRULEWITHOUTMODIFYPACKETFILTERS RuleOperation = "MODIFY_PCC_RULE_WITHOUT_MODIFY_PACKET_FILTERS"
)

// Defines values for RuleStatus.
const (
	ACTIVE   RuleStatus = "ACTIVE"
	INACTIVE RuleStatus = "INACTIVE"
)

// Defines values for SessionRuleFailureCode.
const (
	SessionRuleFailureCodeNFMAL        SessionRuleFailureCode = "NF_MAL"
	SessionRuleFailureCodeRESLIM       SessionRuleFailureCode = "RES_LIM"
	SessionRuleFailureCodeUESTASUSP    SessionRuleFailureCode = "UE_STA_SUSP"
	SessionRuleFailureCodeUNSUCCQOSVAL SessionRuleFailureCode = "UNSUCC_QOS_VAL"
)

// Defines values for SmPolicyAssociationReleaseCause.
const (
	INSUFFICIENTRES           SmPolicyAssociationReleaseCause = "INSUFFICIENT_RES"
	UESUBSCRIPTION            SmPolicyAssociationReleaseCause = "UE_SUBSCRIPTION"
	UNSPECIFIED               SmPolicyAssociationReleaseCause = "UNSPECIFIED"
	VALIDATIONCONDITIONNOTMET SmPolicyAssociationReleaseCause = "VALIDATION_CONDITION_NOT_MET"
)

// Defines values for SteerModeValue.
const (
	ACTIVESTANDBY SteerModeValue = "ACTIVE_STANDBY"
	LOADBALANCING SteerModeValue = "LOAD_BALANCING"
	PRIORITYBASED SteerModeValue = "PRIORITY_BASED"
	SMALLESTDELAY SteerModeValue = "SMALLEST_DELAY"
)

// Defines values for SteeringFunctionality.
const (
	SteeringFunctionalityATSSSLL SteeringFunctionality = "ATSSS_LL"
	SteeringFunctionalityMPTCP   SteeringFunctionality = "MPTCP"
)

// N5GSmCause defines model for 5GSmCause.
type N5GSmCause = externalRef0.Uinteger

// AccNetChId defines model for AccNetChId.
type AccNetChId struct {
	AccNetChaIdValue externalRef0.ChargingId `json:"accNetChaIdValue"`

	// RefPccRuleIds Contains the identifier of the PCC rule(s) associated to the provided Access Network Charging Identifier.
	RefPccRuleIds []string `json:"refPccRuleIds,omitempty"`

	// SessionChScope When it is included and set to true, indicates the Access Network Charging Identifier applies to the whole PDU Session
	SessionChScope       *bool                  `json:"sessionChScope,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AccNetChargingAddress Describes the network entity within the access network performing charging
type AccNetChargingAddress struct {
	AnChargIpv4Addr      externalRef0.Ipv4Addr  `json:"anChargIpv4Addr,omitempty"`
	AnChargIpv6Addr      *externalRef0.Ipv6Addr `json:"anChargIpv6Addr,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AccuUsageReport defines model for AccuUsageReport.
type AccuUsageReport struct {
	NextTimeUsage *externalRef0.DurationSec `json:"nextTimeUsage,omitempty"`

	// NextVolUsage Unsigned integer identifying a volume in units of bytes.
	NextVolUsage *externalRef1.Volume `json:"nextVolUsage,omitempty"`

	// NextVolUsageDownlink Unsigned integer identifying a volume in units of bytes.
	NextVolUsageDownlink *externalRef1.Volume `json:"nextVolUsageDownlink,omitempty"`

	// NextVolUsageUplink Unsigned integer identifying a volume in units of bytes.
	NextVolUsageUplink *externalRef1.Volume `json:"nextVolUsageUplink,omitempty"`

	// RefUmIds An id referencing UsageMonitoringData objects associated with this usage report.
	RefUmIds  string                    `json:"refUmIds"`
	TimeUsage *externalRef0.DurationSec `json:"timeUsage,omitempty"`

	// VolUsage Unsigned integer identifying a volume in units of bytes.
	VolUsage *externalRef1.Volume `json:"volUsage,omitempty"`

	// VolUsageDownlink Unsigned integer identifying a volume in units of bytes.
	VolUsageDownlink *externalRef1.Volume `json:"volUsageDownlink,omitempty"`

	// VolUsageUplink Unsigned integer identifying a volume in units of bytes.
	VolUsageUplink       *externalRef1.Volume   `json:"volUsageUplink,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AdditionalAccessInfo defines model for AdditionalAccessInfo.
type AdditionalAccessInfo struct {
	AccessType           externalRef0.AccessType `json:"accessType"`
	RatType              *externalRef0.RatType   `json:"ratType,omitempty"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// AfSigProtocol Possible values are - NO_INFORMATION: Indicate that no information about the AF signalling protocol is being provided.  - SIP: Indicate that the signalling protocol is Session Initiation Protocol.
type AfSigProtocol struct {
	union json.RawMessage
}

// AfSigProtocol0 defines model for AfSigProtocol.0.
type AfSigProtocol0 string

// AfSigProtocol2 This string provides forward-compatibility with future extensions to the enumeration but is not used to encode content defined in the present version of this API.
type AfSigProtocol2 = string

// AppDetectionInfo defines model for AppDetectionInfo.
type AppDetectionInfo struct {
	// AppId A reference to the application detection filter configured at the UPF
	AppId string `json:"appId"`

	// InstanceId Identifier sent by the SMF in order to allow correlation of application Start and Stop events to the specific service data flow description, if service data flow descriptions are deducible.
	InstanceId *string `json:"instanceId,omitempty"`

	// SdfDescriptions Contains the detected service data flow descriptions if they are deducible.
	SdfDescriptions      []FlowInformation      `json:"sdfDescriptions,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ApplicationDescriptor defines model for ApplicationDescriptor.
type ApplicationDescriptor = externalRef0.Bytes

// AtsssCapability defines model for AtsssCapability.
type AtsssCapability string

// AuthorizedDefaultQos defines model for AuthorizedDefaultQos.
type AuthorizedDefaultQos struct {
	N5qi                 *externalRef0.N5Qi                 `json:"5qi,omitempty"`
	Arp                  *externalRef0.Arp                  `json:"arp,omitempty"`
	AverWindow           *externalRef0.AverWindowRm         `json:"averWindow"`
	ExtMaxDataBurstVol   *externalRef0.ExtMaxDataBurstVolRm `json:"extMaxDataBurstVol"`
	GbrDl                *externalRef0.BitRateRm            `json:"gbrDl"`
	GbrUl                *externalRef0.BitRateRm            `json:"gbrUl"`
	MaxDataBurstVol      *externalRef0.MaxDataBurstVolRm    `json:"maxDataBurstVol"`
	MaxbrDl              *externalRef0.BitRateRm            `json:"maxbrDl"`
	MaxbrUl              *externalRef0.BitRateRm            `json:"maxbrUl"`
	PriorityLevel        *externalRef0.N5QiPriorityLevelRm  `json:"priorityLevel"`
	AdditionalProperties map[string]interface{}             `json:"-"`
}

// BridgeManagementContainer defines model for BridgeManagementContainer.
type BridgeManagementContainer struct {
	BridgeManCont        externalRef0.Bytes     `json:"bridgeManCont"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ChargingData defines model for ChargingData.
type ChargingData struct {
	AfChargId            *externalRef0.ApplicationChargingId `json:"afChargId,omitempty"`
	AfChargingIdentifier *externalRef0.ChargingId            `json:"afChargingIdentifier,omitempty"`

	// AppSvcProvId Indicates the application service provider identity.
	AppSvcProvId *string `json:"appSvcProvId,omitempty"`

	// ChgId Univocally identifies the charging control policy data within a PDU session.
	ChgId string `json:"chgId"`

	// MeteringMethod Possible values are - DURATION: Indicates that the duration of the service data flow traffic shall be metered. - VOLUME: Indicates that volume of the service data flow traffic shall be metered. - DURATION_VOLUME: Indicates that the duration and the volume of the service data flow traffic shall be metered. - EVENT: Indicates that events of the service data flow traffic shall be metered.
	MeteringMethod *MeteringMethod `json:"meteringMethod,omitempty"`

	// Offline Indicates the offline charging is applicable to the PCC rule when it is included and set to true.
	Offline *bool `json:"offline,omitempty"`

	// Online Indicates the online charging is applicable to the PCC rule when it is included and set to true.
	Online      *bool                     `json:"online,omitempty"`
	RatingGroup *externalRef0.RatingGroup `json:"ratingGroup,omitempty"`

	// ReportingLevel Possible values are - SER_ID_LEVEL: Indicates that the usage shall be reported on service id and rating group combination level. - RAT_GR_LEVEL: Indicates that the usage shall be reported on rating group level. - SPON_CON_LEVEL: Indicates that the usage shall be reported on sponsor identity and rating group combination level.
	ReportingLevel *ReportingLevel `json:"reportingLevel,omitempty"`

	// SdfHandl Indicates whether the service data flow is allowed to start while the SMF is waiting for the response to the credit request.
	SdfHandl  *bool                   `json:"sdfHandl,omitempty"`
	ServiceId *externalRef0.ServiceId `json:"serviceId,omitempty"`

	// SponsorId Indicates the sponsor identity.
	SponsorId            *string                `json:"sponsorId,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ChargingInformation defines model for ChargingInformation.
type ChargingInformation struct {
	PrimaryChfAddress      externalRef0.Uri           `json:"primaryChfAddress"`
	PrimaryChfInstanceId   *externalRef0.NfInstanceId `json:"primaryChfInstanceId,omitempty"`
	PrimaryChfSetId        *externalRef0.NfSetId      `json:"primaryChfSetId,omitempty"`
	SecondaryChfAddress    externalRef0.Uri           `json:"secondaryChfAddress"`
	SecondaryChfInstanceId *externalRef0.NfInstanceId `json:"secondaryChfInstanceId,omitempty"`
	SecondaryChfSetId      *externalRef0.NfSetId      `json:"secondaryChfSetId,omitempty"`
	AdditionalProperties   map[string]interface{}     `json:"-"`
}

// ConditionData defines model for ConditionData.
type ConditionData struct {
	AccessType     externalRef0.AccessType  `json:"accessType,omitempty"`
	ActivationTime *externalRef0.DateTimeRm `json:"activationTime"`

	// CondId Uniquely identifies the condition data within a PDU session.
	CondId               string                   `json:"condId"`
	DeactivationTime     *externalRef0.DateTimeRm `json:"deactivationTime"`
	RatType              *externalRef0.RatType    `json:"ratType,omitempty"`
	AdditionalProperties map[string]interface{}   `json:"-"`
}

// CreditManagementStatus defines model for CreditManagementStatus.
type CreditManagementStatus string

// DownlinkDataNotificationControl Contains the downlink data notification control information.
type DownlinkDataNotificationControl struct {
	NotifCtrlInds        []NotificationControlIndication     `json:"notifCtrlInds,omitempty"`
	TypesOfNotif         []externalRef0.DlDataDeliveryStatus `json:"typesOfNotif,omitempty"`
	AdditionalProperties map[string]interface{}              `json:"-"`
}

// DownlinkDataNotificationControlRm this data type is defined in the same way as the DownlinkDataNotificationControl data type, but with the OpenAPI nullable property set to true.
type DownlinkDataNotificationControlRm struct {
	NotifCtrlInds        *[]NotificationControlIndication     `json:"notifCtrlInds"`
	TypesOfNotif         *[]externalRef0.DlDataDeliveryStatus `json:"typesOfNotif"`
	AdditionalProperties map[string]interface{}               `json:"-"`
}

// EpsRanNasRelCause Defines the EPS RAN/NAS release cause.
type EpsRanNasRelCause = string

// ErrorReport defines model for ErrorReport.
type ErrorReport struct {
	AltQosParamId *string                      `json:"altQosParamId,omitempty"`
	Error         *externalRef0.ProblemDetails `json:"error,omitempty"`

	// PolDecFailureReports Used to report failure of the policy decision and/or condition data.
	PolDecFailureReports []PolicyDecisionFailureCode `json:"polDecFailureReports,omitempty"`

	// RuleReports Used to report the PCC rule failure.
	RuleReports []RuleReport `json:"ruleReports,omitempty"`

	// SessRuleReports Used to report the session rule failure.
	SessRuleReports      []SessionRuleReport    `json:"sessRuleReports,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// FailureCause defines model for FailureCause.
type FailureCause string

// FailureCode Possible values are
//   - UNK_RULE_ID: Indicates that the pre-provisioned PCC rule could not be successfully activated because the PCC rule identifier is unknown to the SMF.
//   - RA_GR_ERR: Indicate that the PCC rule could not be successfully installed or enforced because the Rating Group specified within the Charging Data policy decision which the PCC rule refers to is unknown or, invalid.
//   - SER_ID_ERR: Indicate that the PCC rule could not be successfully installed or enforced because the Service Identifier specified within the Charging Data policy decision which the PCC rule refers to is invalid, unknown, or not applicable to the service being charged.
//   - NF_MAL: Indicate that the PCC rule could not be successfully installed (for those provisioned from the PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to SMF/UPF malfunction.
//   - RES_LIM: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to a limitation of resources at the SMF/UPF.
//   - MAX_NR_QoS_FLOW: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to the fact that the maximum number of QoS flows has been reached for the PDU session.
//   - MISS_FLOW_INFO: Indicate that the PCC rule could not be successfully installed or enforced because neither the "flowInfos" attribute nor the "appId" attribute is specified within the PccRule data structure by the PCF during the first install request of the PCC rule.
//   - RES_ALLO_FAIL: Indicate that the PCC rule could not be successfully installed or maintained since the QoS flow establishment/modification failed, or the QoS flow was released.
//   - UNSUCC_QOS_VAL: indicate that the QoS validation has failed or when Guaranteed Bandwidth > Max-Requested-Bandwidth.
//   - INCOR_FLOW_INFO: Indicate that the PCC rule could not be successfully installed or modified at the SMF because the provided flow information is not supported by the network (e.g. the provided IP address(es) or Ipv6 prefix(es) do not correspond to an IP version applicable for the PDU session).
//   - PS_TO_CS_HAN: Indicate that the PCC rule could not be maintained because of PS to CS handover.
//   - APP_ID_ERR: Indicate that the rule could not be successfully installed or enforced because the Application Identifier is invalid, unknown, or not applicable to the application required for detection.
//   - NO_QOS_FLOW_BOUND: Indicate that there is no QoS flow which the SMF can bind the PCC rule(s) to.
//   - FILTER_RES: Indicate that the Flow Information within the "flowInfos" attribute cannot be handled by the SMF because any of the restrictions defined in subclause 5.4.2 of 3GPP TS 29.212 was not met.
//   - MISS_REDI_SER_ADDR: Indicate that the PCC rule could not be successfully installed or enforced at the SMF because there is no valid Redirect Server Address within the Traffic Control Data policy decision which the PCC rule refers to provided by the PCF and no preconfigured redirection address for this PCC rule at the SMF.
//   - CM_END_USER_SER_DENIED: Indicate that the charging system denied the service request due to service restrictions (e.g. terminate rating group) or limitations related to the end-user, for example the end-user's account could not cover the requested service.
//   - CM_CREDIT_CON_NOT_APP: Indicate that the charging system determined that the service can be granted to the end user but no further credit control is needed for the service (e.g. service is free of charge or is treated for offline charging).
//   - CM_AUTH_REJ: Indicate that the charging system denied the service request in order to terminate the service for which credit is requested.
//   - CM_USER_UNK: Indicate that the specified end user could not be found in the charging system.
//   - CM_RAT_FAILED: Indicate that the charging system cannot rate the service request due to insufficient rating input, incorrect AVP combination or due to an attribute or an attribute value that is not recognized or supported in the rating.
//   - UE_STA_SUSP: Indicates that the UE is in suspend state.
type FailureCode string

// FlowDescription Defines a packet filter for an IP flow.
type FlowDescription = string

// FlowDirection Possible values are - DOWNLINK: The corresponding filter applies for traffic to the UE. - UPLINK: The corresponding filter applies for traffic from the UE. - BIDIRECTIONAL: The corresponding filter applies for traffic both to and from the UE. - UNSPECIFIED: The corresponding filter applies for traffic to the UE (downlink), but has no specific direction declared. The service data flow detection shall apply the filter for uplink traffic as if the filter was bidirectional. The PCF shall not use the value UNSPECIFIED in filters created by the network in NW-initiated procedures. The PCF shall only include the value UNSPECIFIED in filters in UE-initiated procedures if the same value is received from the SMF.
type FlowDirection string

// FlowDirectionRm Possible values are - DOWNLINK: The corresponding filter applies for traffic to the UE. - UPLINK: The corresponding filter applies for traffic from the UE. - BIDIRECTIONAL: The corresponding filter applies for traffic both to and from the UE. - UNSPECIFIED: The corresponding filter applies for traffic to the UE (downlink), but has no specific direction declared. The service data flow detection shall apply the filter for uplink traffic as if the filter was bidirectional. The PCF shall not use the value UNSPECIFIED in filters created by the network in NW-initiated procedures. The PCF shall only include the value UNSPECIFIED in filters in UE-initiated procedures if the same value is received from the SMF.
type FlowDirectionRm string

// FlowInformation defines model for FlowInformation.
type FlowInformation struct {
	// EthFlowDescription Identifies an Ethernet flow
	EthFlowDescription *externalRef2.EthFlowDescription `json:"ethFlowDescription,omitempty"`

	// FlowDescription Defines a packet filter for an IP flow.
	FlowDescription *FlowDescription `json:"flowDescription,omitempty"`

	// FlowDirection Possible values are - DOWNLINK: The corresponding filter applies for traffic to the UE. - UPLINK: The corresponding filter applies for traffic from the UE. - BIDIRECTIONAL: The corresponding filter applies for traffic both to and from the UE. - UNSPECIFIED: The corresponding filter applies for traffic to the UE (downlink), but has no specific direction declared. The service data flow detection shall apply the filter for uplink traffic as if the filter was bidirectional. The PCF shall not use the value UNSPECIFIED in filters created by the network in NW-initiated procedures. The PCF shall only include the value UNSPECIFIED in filters in UE-initiated procedures if the same value is received from the SMF.
	FlowDirection *FlowDirectionRm `json:"flowDirection,omitempty"`

	// FlowLabel the Ipv6 flow label header field.
	FlowLabel *string `json:"flowLabel"`

	// PackFiltId An identifier of packet filter.
	PackFiltId *string `json:"packFiltId,omitempty"`

	// PacketFilterUsage The packet shall be sent to the UE.
	PacketFilterUsage *bool `json:"packetFilterUsage,omitempty"`

	// Spi the security parameter index of the IPSec packet.
	Spi *string `json:"spi"`

	// TosTrafficClass Contains the Ipv4 Type-of-Service and mask field or the Ipv6 Traffic-Class field and mask field.
	TosTrafficClass      *string                `json:"tosTrafficClass"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// IpMulticastAddressInfo defines model for IpMulticastAddressInfo.
type IpMulticastAddressInfo struct {
	Ipv4MulAddr          externalRef0.Ipv4Addr  `json:"ipv4MulAddr,omitempty"`
	Ipv6MulAddr          *externalRef0.Ipv6Addr `json:"ipv6MulAddr,omitempty"`
	SrcIpv4Addr          externalRef0.Ipv4Addr  `json:"srcIpv4Addr,omitempty"`
	SrcIpv6Addr          *externalRef0.Ipv6Addr `json:"srcIpv6Addr,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// MaPduIndication defines model for MaPduIndication.
type MaPduIndication string

// MeteringMethod Possible values are - DURATION: Indicates that the duration of the service data flow traffic shall be metered. - VOLUME: Indicates that volume of the service data flow traffic shall be metered. - DURATION_VOLUME: Indicates that the duration and the volume of the service data flow traffic shall be metered. - EVENT: Indicates that events of the service data flow traffic shall be metered.
type MeteringMethod struct {
	union json.RawMessage
}

// MeteringMethod0 defines model for MeteringMethod.0.
type MeteringMethod0 string

// MeteringMethod2 This string provides forward-compatibility with future extensions to the enumeration but is not used to encode content defined in the present version of this API.
type MeteringMethod2 = string

// MulticastAccessControl defines model for MulticastAccessControl.
type MulticastAccessControl string

// NetLocAccessSupport Possible values are - ANR_NOT_SUPPORTED: Indicates that the access network does not support the report of access network information. - TZR_NOT_SUPPORTED: Indicates that the access network does not support the report of UE time zone. - LOC_NOT_SUPPORTED: Indicates that the access network does not support the report of UE Location (or PLMN Id).
type NetLocAccessSupport string

// NotificationControlIndication defines model for NotificationControlIndication.
type NotificationControlIndication string

// PacketFilterContent Defines a packet filter for an IP flow.
type PacketFilterContent = string

// PacketFilterInfo defines model for PacketFilterInfo.
type PacketFilterInfo struct {
	// FlowDirection Possible values are - DOWNLINK: The corresponding filter applies for traffic to the UE. - UPLINK: The corresponding filter applies for traffic from the UE. - BIDIRECTIONAL: The corresponding filter applies for traffic both to and from the UE. - UNSPECIFIED: The corresponding filter applies for traffic to the UE (downlink), but has no specific direction declared. The service data flow detection shall apply the filter for uplink traffic as if the filter was bidirectional. The PCF shall not use the value UNSPECIFIED in filters created by the network in NW-initiated procedures. The PCF shall only include the value UNSPECIFIED in filters in UE-initiated procedures if the same value is received from the SMF.
	FlowDirection *FlowDirection `json:"flowDirection,omitempty"`

	// FlowLabel The Ipv6 flow label header field.
	FlowLabel *string `json:"flowLabel,omitempty"`

	// PackFiltCont Defines a packet filter for an IP flow.
	PackFiltCont *PacketFilterContent `json:"packFiltCont,omitempty"`

	// PackFiltId An identifier of packet filter.
	PackFiltId *string `json:"packFiltId,omitempty"`

	// Spi The security parameter index of the IPSec packet.
	Spi *string `json:"spi,omitempty"`

	// TosTrafficClass Contains the Ipv4 Type-of-Service and mask field or the Ipv6 Traffic-Class field and mask field.
	TosTrafficClass      *string                `json:"tosTrafficClass,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PartialSuccessReport defines model for PartialSuccessReport.
type PartialSuccessReport struct {
	FailureCause FailureCause `json:"failureCause"`

	// PolicyDecFailureReports Contains the type(s) of failed policy decision and/or condition data.
	PolicyDecFailureReports []PolicyDecisionFailureCode `json:"policyDecFailureReports,omitempty"`

	// RuleReports Information about the PCC rules provisioned by the PCF not successfully installed/activated.
	RuleReports []RuleReport `json:"ruleReports,omitempty"`

	// SessRuleReports Information about the session rules provisioned by the PCF not successfully installed.
	SessRuleReports      []SessionRuleReport    `json:"sessRuleReports,omitempty"`
	UeCampingRep         *UeCampingRep          `json:"ueCampingRep,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PccRule defines model for PccRule.
type PccRule struct {
	AddrPreserInd *bool `json:"addrPreserInd"`

	// AfSigProtocol Possible values are - NO_INFORMATION: Indicate that no information about the AF signalling protocol is being provided.  - SIP: Indicate that the signalling protocol is Session Initiation Protocol.
	AfSigProtocol *AfSigProtocol         `json:"afSigProtocol,omitempty"`
	AppDescriptor *ApplicationDescriptor `json:"appDescriptor,omitempty"`

	// AppId A reference to the application detection filter configured at the UPF.
	AppId *string `json:"appId,omitempty"`

	// AppReloc Indication of application relocation possibility.
	AppReloc *bool `json:"appReloc,omitempty"`

	// ContVer Represents the content version of some content.
	ContVer *externalRef2.ContentVersion `json:"contVer,omitempty"`

	// DdNotifCtrl Contains the downlink data notification control information.
	DdNotifCtrl *DownlinkDataNotificationControl `json:"ddNotifCtrl,omitempty"`

	// DdNotifCtrl2 this data type is defined in the same way as the DownlinkDataNotificationControl data type, but with the OpenAPI nullable property set to true.
	DdNotifCtrl2 *DownlinkDataNotificationControlRm `json:"ddNotifCtrl2"`
	DisUeNotif   *bool                              `json:"disUeNotif"`

	// FlowInfos An array of IP flow packet filter information.
	FlowInfos []FlowInformation `json:"flowInfos,omitempty"`

	// PccRuleId Univocally identifies the PCC rule within a PDU session.
	PccRuleId  string                 `json:"pccRuleId"`
	Precedence *externalRef0.Uinteger `json:"precedence,omitempty"`

	// RefAltQosParams A Reference to the QosData policy decision type for the Alternative QoS parameter sets of the service data flow.
	RefAltQosParams []string `json:"refAltQosParams,omitempty"`

	// RefChgData A reference to the ChargingData policy decision type. It is the chgId described in subclause 5.6.2.11.
	RefChgData *[]string `json:"refChgData"`

	// RefChgN3gData A reference to the ChargingData policy decision type only applicable to Non-3GPP access if "ATSSS" feature is supported. It is the chgId described in subclause 5.6.2.11.
	RefChgN3gData *[]string `json:"refChgN3gData"`

	// RefCondData A reference to the condition data. It is the condId described in subclause 5.6.2.9.
	RefCondData *string `json:"refCondData"`

	// RefQosData A reference to the QosData policy decision type. It is the qosId described in subclause 5.6.2.8.
	RefQosData []string `json:"refQosData,omitempty"`

	// RefQosMon A reference to the QosMonitoringData policy decision type. It is the qmId described in subclause 5.6.2.40.
	RefQosMon *[]string `json:"refQosMon"`

	// RefTcData A reference to the TrafficControlData policy decision type. It is the tcId described in subclause 5.6.2.10.
	RefTcData []string `json:"refTcData,omitempty"`

	// RefUmData A reference to UsageMonitoringData policy decision type. It is the umId described in subclause 5.6.2.12.
	RefUmData *[]string `json:"refUmData"`

	// RefUmN3gData A reference to UsageMonitoringData policy decision type only applicable to Non-3GPP access if "ATSSS" feature is supported. It is the umId described in subclause 5.6.2.12.
	RefUmN3gData *[]string `json:"refUmN3gData"`

	// TscaiInputDl Indicates TSC Traffic pattern.
	TscaiInputDl *externalRef2.TscaiInputContainer `json:"tscaiInputDl"`

	// TscaiInputUl Indicates TSC Traffic pattern.
	TscaiInputUl         *externalRef2.TscaiInputContainer `json:"tscaiInputUl"`
	AdditionalProperties map[string]interface{}            `json:"-"`
}

// PduSessionRelCause defines model for PduSessionRelCause.
type PduSessionRelCause string

// PolicyControlRequestTrigger Possible values are - PLMN_CH: PLMN Change - RES_MO_RE: A request for resource modification has been received by the SMF. The SMF always reports to the PCF. - AC_TY_CH: Access Type Change - UE_IP_CH: UE IP address change. The SMF always reports to the PCF. - UE_MAC_CH: A new UE MAC address is detected or a used UE MAC address is inactive for a specific period - AN_CH_COR: Access Network Charging Correlation Information - US_RE: The PDU Session or the Monitoring key specific resources consumed by a UE either reached the threshold or needs to be reported for other reasons. - APP_STA: The start of application traffic has been detected. - APP_STO: The stop of application traffic has been detected. - AN_INFO: Access Network Information report - CM_SES_FAIL: Credit management session failure - PS_DA_OFF: The SMF reports when the 3GPP PS Data Off status changes. The SMF always reports to the PCF. - DEF_QOS_CH: Default QoS Change. The SMF always reports to the PCF. - SE_AMBR_CH: Session AMBR Change. The SMF always reports to the PCF. - QOS_NOTIF: The SMF notify the PCF when receiving notification from RAN that QoS targets of the QoS Flow cannot be guranteed or gurateed again. - NO_CREDIT: Out of credit - REALLO_OF_CREDIT: Reallocation of credit - PRA_CH: Change of UE presence in Presence Reporting Area - SAREA_CH: Location Change with respect to the Serving Area - SCNN_CH: Location Change with respect to the Serving CN node - RE_TIMEOUT: Indicates the SMF generated the request because there has been a PCC revalidation timeout - RES_RELEASE: Indicate that the SMF can inform the PCF of the outcome of the release of resources for those rules that require so. - SUCC_RES_ALLO: Indicates that the requested rule data is the successful resource allocation. - RAT_TY_CH: RAT Type Change. - REF_QOS_IND_CH: Reflective QoS indication Change - NUM_OF_PACKET_FILTER: Indicates that the SMF shall report the number of supported packet filter for signalled QoS rules - UE_STATUS_RESUME: Indicates that the UE’s status is resumed. - UE_TZ_CH: UE Time Zone Change - AUTH_PROF_CH: The DN-AAA authorization profile index has changed - QOS_MONITORING: Indicate that the SMF notifies the PCF of the QoS Monitoring information. - SCELL_CH: Location Change with respect to the Serving Cell. - EPS_FALLBACK: EPS Fallback report is enabled in the SMF. - MA_PDU: UE Indicates that the SMF notifies the PCF of the MA PDU session request - TSN_BRIDGE_INFO: 5GS Bridge information available - 5G_RG_JOIN: The 5G-RG has joined to an IP Multicast Group. - 5G_RG_LEAVE: The 5G-RG has left an IP Multicast Group. - DDN_FAILURE: Event subscription for DDN Failure event received. - DDN_DELIVERY_STATUS: Event subscription for DDN Delivery Status received. - GROUP_ID_LIST_CHG: UE Internal Group Identifier(s) has changed: the SMF reports that UDM provided list of group Ids has changed. - DDN_FAILURE_CANCELLATION: The event subscription for DDN Failure event is cancelled. - DDN_DELIVERY_STATUS_CANCELLATION: The event subscription for DDD STATUS is cancelled. - VPLMN_QOS_CH: Change of the QoS supported in the VPLMN.
type PolicyControlRequestTrigger string

// PolicyDecisionFailureCode defines model for PolicyDecisionFailureCode.
type PolicyDecisionFailureCode string

// PortManagementContainer defines model for PortManagementContainer.
type PortManagementContainer struct {
	PortManCont          externalRef0.Bytes     `json:"portManCont"`
	PortNum              TsnPortNumber          `json:"portNum"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// QosCharacteristics defines model for QosCharacteristics.
type QosCharacteristics struct {
	N5qi                 externalRef0.N5Qi               `json:"5qi"`
	AveragingWindow      externalRef0.AverWindow         `json:"averagingWindow,omitempty"`
	ExtMaxDataBurstVol   externalRef0.ExtMaxDataBurstVol `json:"extMaxDataBurstVol,omitempty"`
	MaxDataBurstVol      externalRef0.MaxDataBurstVol    `json:"maxDataBurstVol,omitempty"`
	PacketDelayBudget    externalRef0.PacketDelBudget    `json:"packetDelayBudget"`
	PacketErrorRate      externalRef0.PacketErrRate      `json:"packetErrorRate"`
	PriorityLevel        externalRef0.N5QiPriorityLevel  `json:"priorityLevel"`
	ResourceType         externalRef0.QosResourceType    `json:"resourceType"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// QosData defines model for QosData.
type QosData struct {
	N5qi       *externalRef0.N5Qi         `json:"5qi,omitempty"`
	Arp        *externalRef0.Arp          `json:"arp,omitempty"`
	AverWindow *externalRef0.AverWindowRm `json:"averWindow"`

	// DefQosFlowIndication Indicates that the dynamic PCC rule shall always have its binding with the QoS Flow associated with the default QoS rule
	DefQosFlowIndication *bool                              `json:"defQosFlowIndication,omitempty"`
	ExtMaxDataBurstVol   *externalRef0.ExtMaxDataBurstVolRm `json:"extMaxDataBurstVol"`
	GbrDl                *externalRef0.BitRateRm            `json:"gbrDl"`
	GbrUl                *externalRef0.BitRateRm            `json:"gbrUl"`
	MaxDataBurstVol      *externalRef0.MaxDataBurstVolRm    `json:"maxDataBurstVol"`
	MaxPacketLossRateDl  *externalRef0.PacketLossRateRm     `json:"maxPacketLossRateDl"`
	MaxPacketLossRateUl  *externalRef0.PacketLossRateRm     `json:"maxPacketLossRateUl"`
	MaxbrDl              *externalRef0.BitRateRm            `json:"maxbrDl"`
	MaxbrUl              *externalRef0.BitRateRm            `json:"maxbrUl"`
	PacketDelayBudget    externalRef0.PacketDelBudget       `json:"packetDelayBudget,omitempty"`
	PacketErrorRate      externalRef0.PacketErrRate         `json:"packetErrorRate,omitempty"`
	PriorityLevel        *externalRef0.N5QiPriorityLevelRm  `json:"priorityLevel"`

	// Qnc Indicates whether notifications are requested from 3GPP NG-RAN when the GFBR can no longer (or again) be guaranteed for a QoS Flow during the lifetime of the QoS Flow.
	Qnc *bool `json:"qnc,omitempty"`

	// QosId Univocally identifies the QoS control policy data within a PDU session.
	QosId string `json:"qosId"`

	// ReflectiveQos Indicates whether the QoS information is reflective for the corresponding service data flow.
	ReflectiveQos *bool `json:"reflectiveQos,omitempty"`

	// SharingKeyDl Indicates, by containing the same value, what PCC rules may share resource in downlink direction.
	SharingKeyDl *string `json:"sharingKeyDl,omitempty"`

	// SharingKeyUl Indicates, by containing the same value, what PCC rules may share resource in uplink direction.
	SharingKeyUl         *string                `json:"sharingKeyUl,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// QosFlowUsage Possible values are - GENERAL: Indicate no specific QoS flow usage information is available.  - IMS_SIG: Indicate that the QoS flow is used for IMS signalling only.
type QosFlowUsage string

// QosMonitoringData defines model for QosMonitoringData.
type QosMonitoringData struct {
	NotifyCorreId *string           `json:"notifyCorreId,omitempty"`
	NotifyUri     *externalRef0.Uri `json:"notifyUri,omitempty"`

	// QmId Univocally identifies the QoS monitoring policy data within a PDU session.
	QmId      string                      `json:"qmId"`
	RepFreqs  []ReportingFrequency        `json:"repFreqs"`
	RepPeriod *externalRef0.DurationSecRm `json:"repPeriod"`

	// RepThreshDl Indicates the period of time in units of miliiseconds for DL packet delay.
	RepThreshDl *int `json:"repThreshDl"`

	// RepThreshRp Indicates the period of time in units of miliiseconds for round trip packet delay.
	RepThreshRp *int `json:"repThreshRp"`

	// RepThreshUl Indicates the period of time in units of miliiseconds for UL packet delay.
	RepThreshUl *int `json:"repThreshUl"`

	// ReqQosMonParams indicates the UL packet delay, DL packet delay and/or round trip packet delay between the UE and the UPF is to be monitored when the QoS Monitoring for URLLC is enabled for the service data flow.
	ReqQosMonParams      []RequestedQosMonitoringParameter `json:"reqQosMonParams"`
	WaitTime             *externalRef0.DurationSecRm       `json:"waitTime"`
	AdditionalProperties map[string]interface{}            `json:"-"`
}

// QosMonitoringReport defines model for QosMonitoringReport.
type QosMonitoringReport struct {
	DlDelays []int `json:"dlDelays,omitempty"`

	// RefPccRuleIds An array of PCC rule id references to the PCC rules associated with the QoS monitoring report.
	RefPccRuleIds        []string               `json:"refPccRuleIds"`
	RtDelays             []int                  `json:"rtDelays,omitempty"`
	UlDelays             []int                  `json:"ulDelays,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// QosNotificationControlInfo defines model for QosNotificationControlInfo.
type QosNotificationControlInfo struct {
	AltQosParamId *string `json:"altQosParamId,omitempty"`

	// ContVer Represents the content version of some content.
	ContVer   *externalRef2.ContentVersion `json:"contVer,omitempty"`
	NotifType externalRef2.QosNotifType    `json:"notifType"`

	// RefPccRuleIds An array of PCC rule id references to the PCC rules associated with the QoS notification control info.
	RefPccRuleIds        []string               `json:"refPccRuleIds"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RanNasRelCause defines model for RanNasRelCause.
type RanNasRelCause struct {
	N5gMmCause *externalRef0.N5GMmCause `json:"5gMmCause,omitempty"`
	N5gSmCause *N5GSmCause              `json:"5gSmCause,omitempty"`

	// EpsCause Defines the EPS RAN/NAS release cause.
	EpsCause             *EpsRanNasRelCause      `json:"epsCause,omitempty"`
	NgApCause            *externalRef0.NgApCause `json:"ngApCause,omitempty"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// RedirectAddressType Possible values are - IPV4_ADDR: Indicates that the address type is in the form of "dotted-decimal" IPv4 address. - IPV6_ADDR: Indicates that the address type is in the form of IPv6 address. - URL: Indicates that the address type is in the form of Uniform Resource Locator. - SIP_URI: Indicates that the address type is in the form of SIP Uniform Resource Identifier.
type RedirectAddressType string

// RedirectInformation defines model for RedirectInformation.
type RedirectInformation struct {
	// RedirectAddressType Possible values are - IPV4_ADDR: Indicates that the address type is in the form of "dotted-decimal" IPv4 address. - IPV6_ADDR: Indicates that the address type is in the form of IPv6 address. - URL: Indicates that the address type is in the form of Uniform Resource Locator. - SIP_URI: Indicates that the address type is in the form of SIP Uniform Resource Identifier.
	RedirectAddressType *RedirectAddressType `json:"redirectAddressType,omitempty"`

	// RedirectEnabled Indicates the redirect is enable.
	RedirectEnabled *bool `json:"redirectEnabled,omitempty"`

	// RedirectServerAddress Indicates the address of the redirect server. If "redirectAddressType" attribute indicates the IPV4_ADDR, the encoding is the same as the Ipv4Addr data type defined in 3GPP TS 29.571.If "redirectAddressType" attribute indicates the IPV6_ADDR, the encoding is the same as the Ipv6Addr data type defined in 3GPP TS 29.571.If "redirectAddressType" attribute indicates the URL or SIP_URI, the encoding is the same as the Uri data type defined in 3GPP TS 29.571.
	RedirectServerAddress *string                `json:"redirectServerAddress,omitempty"`
	AdditionalProperties  map[string]interface{} `json:"-"`
}

// ReportingFrequency defines model for ReportingFrequency.
type ReportingFrequency string

// ReportingLevel Possible values are - SER_ID_LEVEL: Indicates that the usage shall be reported on service id and rating group combination level. - RAT_GR_LEVEL: Indicates that the usage shall be reported on rating group level. - SPON_CON_LEVEL: Indicates that the usage shall be reported on sponsor identity and rating group combination level.
type ReportingLevel struct {
	union json.RawMessage
}

// ReportingLevel0 defines model for ReportingLevel.0.
type ReportingLevel0 string

// ReportingLevel2 This string provides forward-compatibility with future extensions to the enumeration but is not used to encode content defined in the present version of this API.
type ReportingLevel2 = string

// RequestedQos defines model for RequestedQos.
type RequestedQos struct {
	N5qi                 externalRef0.N5Qi      `json:"5qi"`
	GbrDl                externalRef0.BitRate   `json:"gbrDl,omitempty"`
	GbrUl                externalRef0.BitRate   `json:"gbrUl,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RequestedQosMonitoringParameter defines model for RequestedQosMonitoringParameter.
type RequestedQosMonitoringParameter string

// RequestedRuleData defines model for RequestedRuleData.
type RequestedRuleData struct {
	// RefPccRuleIds An array of PCC rule id references to the PCC rules associated with the control data.
	RefPccRuleIds []string `json:"refPccRuleIds"`

	// ReqData Array of requested rule data type elements indicating what type of rule data is requested for the corresponding referenced PCC rules.
	ReqData              []RequestedRuleDataType `json:"reqData"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// RequestedRuleDataType Possible values are - CH_ID: Indicates that the requested rule data is the charging identifier.  - MS_TIME_ZONE: Indicates that the requested access network info type is the UE's timezone. - USER_LOC_INFO: Indicates that the requested access network info type is the UE's location. - RES_RELEASE: Indicates that the requested rule data is the result of the release of resource. - SUCC_RES_ALLO: Indicates that the requested rule data is the successful resource allocation. - EPS_FALLBACK: Indicates that the requested rule data is the report of QoS flow rejection due to EPS fallback.
type RequestedRuleDataType string

// RequestedUsageData defines model for RequestedUsageData.
type RequestedUsageData struct {
	// AllUmIds This boolean indicates whether requested usage data applies to all usage monitoring data instances. When it's not included, it means requested usage data shall only apply to the usage monitoring data instances referenced by the refUmIds attribute.
	AllUmIds *bool `json:"allUmIds,omitempty"`

	// RefUmIds An array of usage monitoring data id references to the usage monitoring data instances for which the PCF is requesting a usage report. This attribute shall only be provided when allUmIds is not set to true.
	RefUmIds             []string               `json:"refUmIds,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RuleOperation Possible values are - CREATE_PCC_RULE: Indicates to create a new PCC rule to reserve the resource requested by the UE.  - DELETE_PCC_RULE: Indicates to delete a PCC rule corresponding to reserve the resource requested by the UE. - MODIFY_PCC_RULE_AND_ADD_PACKET_FILTERS: Indicates to modify the PCC rule by adding new packet filter(s). - MODIFY_ PCC_RULE_AND_REPLACE_PACKET_FILTERS: Indicates to modify the PCC rule by replacing the existing packet filter(s). - MODIFY_ PCC_RULE_AND_DELETE_PACKET_FILTERS: Indicates to modify the PCC rule by deleting the existing packet filter(s). - MODIFY_PCC_RULE_WITHOUT_MODIFY_PACKET_FILTERS: Indicates to modify the PCC rule by modifying the QoS of the PCC rule.
type RuleOperation string

// RuleReport defines model for RuleReport.
type RuleReport struct {
	// ContVers Indicates the version of a PCC rule.
	ContVers []externalRef2.ContentVersion `json:"contVers,omitempty"`

	// FailureCode Possible values are
	//   - UNK_RULE_ID: Indicates that the pre-provisioned PCC rule could not be successfully activated because the PCC rule identifier is unknown to the SMF.
	//   - RA_GR_ERR: Indicate that the PCC rule could not be successfully installed or enforced because the Rating Group specified within the Charging Data policy decision which the PCC rule refers to is unknown or, invalid.
	//   - SER_ID_ERR: Indicate that the PCC rule could not be successfully installed or enforced because the Service Identifier specified within the Charging Data policy decision which the PCC rule refers to is invalid, unknown, or not applicable to the service being charged.
	//   - NF_MAL: Indicate that the PCC rule could not be successfully installed (for those provisioned from the PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to SMF/UPF malfunction.
	//   - RES_LIM: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to a limitation of resources at the SMF/UPF.
	//   - MAX_NR_QoS_FLOW: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to the fact that the maximum number of QoS flows has been reached for the PDU session.
	//   - MISS_FLOW_INFO: Indicate that the PCC rule could not be successfully installed or enforced because neither the "flowInfos" attribute nor the "appId" attribute is specified within the PccRule data structure by the PCF during the first install request of the PCC rule.
	//   - RES_ALLO_FAIL: Indicate that the PCC rule could not be successfully installed or maintained since the QoS flow establishment/modification failed, or the QoS flow was released.
	//   - UNSUCC_QOS_VAL: indicate that the QoS validation has failed or when Guaranteed Bandwidth > Max-Requested-Bandwidth.
	//   - INCOR_FLOW_INFO: Indicate that the PCC rule could not be successfully installed or modified at the SMF because the provided flow information is not supported by the network (e.g. the provided IP address(es) or Ipv6 prefix(es) do not correspond to an IP version applicable for the PDU session).
	//   - PS_TO_CS_HAN: Indicate that the PCC rule could not be maintained because of PS to CS handover.
	//   - APP_ID_ERR: Indicate that the rule could not be successfully installed or enforced because the Application Identifier is invalid, unknown, or not applicable to the application required for detection.
	//   - NO_QOS_FLOW_BOUND: Indicate that there is no QoS flow which the SMF can bind the PCC rule(s) to.
	//   - FILTER_RES: Indicate that the Flow Information within the "flowInfos" attribute cannot be handled by the SMF because any of the restrictions defined in subclause 5.4.2 of 3GPP TS 29.212 was not met.
	//   - MISS_REDI_SER_ADDR: Indicate that the PCC rule could not be successfully installed or enforced at the SMF because there is no valid Redirect Server Address within the Traffic Control Data policy decision which the PCC rule refers to provided by the PCF and no preconfigured redirection address for this PCC rule at the SMF.
	//   - CM_END_USER_SER_DENIED: Indicate that the charging system denied the service request due to service restrictions (e.g. terminate rating group) or limitations related to the end-user, for example the end-user's account could not cover the requested service.
	//   - CM_CREDIT_CON_NOT_APP: Indicate that the charging system determined that the service can be granted to the end user but no further credit control is needed for the service (e.g. service is free of charge or is treated for offline charging).
	//   - CM_AUTH_REJ: Indicate that the charging system denied the service request in order to terminate the service for which credit is requested.
	//   - CM_USER_UNK: Indicate that the specified end user could not be found in the charging system.
	//   - CM_RAT_FAILED: Indicate that the charging system cannot rate the service request due to insufficient rating input, incorrect AVP combination or due to an attribute or an attribute value that is not recognized or supported in the rating.
	//   - UE_STA_SUSP: Indicates that the UE is in suspend state.
	FailureCode *FailureCode `json:"failureCode,omitempty"`

	// FinUnitAct Original reference TS32291_Nchf_ConvergedCharging.yaml#/components/schemas/FinalUnitAction
	FinUnitAct *string `json:"finUnitAct,omitempty"`

	// PccRuleIds Contains the identifier of the affected PCC rule(s).
	PccRuleIds []string `json:"pccRuleIds"`

	// RanNasRelCauses indicates the RAN or NAS release cause code information.
	RanNasRelCauses []RanNasRelCause `json:"ranNasRelCauses,omitempty"`

	// RuleStatus Possible values are - ACTIVE: Indicates that the PCC rule(s) are successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF), or the session rule(s) are successfully installed  - INACTIVE: Indicates that the PCC rule(s) are removed (for those provisioned from PCF) or inactive (for those pre-defined in SMF) or the session rule(s) are removed.
	RuleStatus           RuleStatus             `json:"ruleStatus"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RuleStatus Possible values are - ACTIVE: Indicates that the PCC rule(s) are successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF), or the session rule(s) are successfully installed  - INACTIVE: Indicates that the PCC rule(s) are removed (for those provisioned from PCF) or inactive (for those pre-defined in SMF) or the session rule(s) are removed.
type RuleStatus string

// ServingNfIdentity defines model for ServingNfIdentity.
type ServingNfIdentity struct {
	// AnGwAddr describes the address of the access network gateway control node
	AnGwAddr             *externalRef2.AnGwAddress  `json:"anGwAddr,omitempty"`
	Guami                *externalRef0.Guami        `json:"guami,omitempty"`
	ServNfInstId         *externalRef0.NfInstanceId `json:"servNfInstId,omitempty"`
	AdditionalProperties map[string]interface{}     `json:"-"`
}

// SessionRule defines model for SessionRule.
type SessionRule struct {
	AuthDefQos   *AuthorizedDefaultQos `json:"authDefQos,omitempty"`
	AuthSessAmbr *externalRef0.Ambr    `json:"authSessAmbr,omitempty"`

	// RefCondData A reference to the condition data. It is the condId described in subclause 5.6.2.9.
	RefCondData *string `json:"refCondData"`

	// RefUmData A reference to UsageMonitoringData policy decision type. It is the umId described in subclause 5.6.2.12.
	RefUmData *string `json:"refUmData"`

	// RefUmN3gData A reference to UsageMonitoringData policy decision type to apply for Non-3GPP access. It is the umId described in subclause 5.6.2.12.
	RefUmN3gData *string `json:"refUmN3gData"`

	// SessRuleId Univocally identifies the session rule within a PDU session.
	SessRuleId           string                 `json:"sessRuleId"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SessionRuleFailureCode Possible values are
//   - NF_MAL: Indicate that the PCC rule could not be successfully installed (for those provisioned from the PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to SMF/UPF malfunction.
//   - RES_LIM: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to a limitation of resources at the SMF/UPF.
//   - UNSUCC_QOS_VAL: indicate that the QoS validation has failed.
//   - UE_STA_SUSP: Indicates that the UE is in suspend state.
type SessionRuleFailureCode string

// SessionRuleReport defines model for SessionRuleReport.
type SessionRuleReport struct {
	// PolicyDecFailureReports Contains the type(s) of failed policy decision and/or condition data.
	PolicyDecFailureReports []PolicyDecisionFailureCode `json:"policyDecFailureReports,omitempty"`

	// RuleIds Contains the identifier of the affected session rule(s).
	RuleIds []string `json:"ruleIds"`

	// RuleStatus Possible values are - ACTIVE: Indicates that the PCC rule(s) are successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF), or the session rule(s) are successfully installed  - INACTIVE: Indicates that the PCC rule(s) are removed (for those provisioned from PCF) or inactive (for those pre-defined in SMF) or the session rule(s) are removed.
	RuleStatus RuleStatus `json:"ruleStatus"`

	// SessRuleFailureCode Possible values are
	//   - NF_MAL: Indicate that the PCC rule could not be successfully installed (for those provisioned from the PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to SMF/UPF malfunction.
	//   - RES_LIM: Indicate that the PCC rule could not be successfully installed (for those provisioned from PCF) or activated (for those pre-defined in SMF) or enforced (for those already successfully installed) due to a limitation of resources at the SMF/UPF.
	//   - UNSUCC_QOS_VAL: indicate that the QoS validation has failed.
	//   - UE_STA_SUSP: Indicates that the UE is in suspend state.
	SessRuleFailureCode  *SessionRuleFailureCode `json:"sessRuleFailureCode,omitempty"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// SmPolicyAssociationReleaseCause defines model for SmPolicyAssociationReleaseCause.
type SmPolicyAssociationReleaseCause string

// SmPolicyContextData defines model for SmPolicyContextData.
type SmPolicyContextData struct {
	// N3gppPsDataOffStatus If it is included and set to true, the 3GPP PS Data Off is activated by the UE.
	N3gppPsDataOffStatus *bool                   `json:"3gppPsDataOffStatus,omitempty"`
	AccNetChId           *AccNetChId             `json:"accNetChId,omitempty"`
	AccessType           externalRef0.AccessType `json:"accessType,omitempty"`
	AddAccessInfo        *AdditionalAccessInfo   `json:"addAccessInfo,omitempty"`
	AtsssCapab           *AtsssCapability        `json:"atsssCapab,omitempty"`

	// AuthProfIndex Indicates the DN-AAA authorization profile index
	AuthProfIndex *string `json:"authProfIndex,omitempty"`

	// ChargEntityAddr Describes the network entity within the access network performing charging
	ChargEntityAddr         *AccNetChargingAddress `json:"chargEntityAddr,omitempty"`
	Chargingcharacteristics *string                `json:"chargingcharacteristics,omitempty"`
	Dnn                     externalRef0.Dnn       `json:"dnn"`

	// DnnSelMode Possible values are - VERIFIED - UE_DNN_NOT_VERIFIED - NW_DNN_NOT_VERIFIED
	DnnSelMode  *externalRef3.DnnSelectionMode `json:"dnnSelMode,omitempty"`
	Gpsi        externalRef0.Gpsi              `json:"gpsi,omitempty"`
	InterGrpIds []externalRef0.GroupId         `json:"interGrpIds,omitempty"`

	// InvalidSupi When this attribute is included and set to true, it indicates that the supi attribute contains an invalid value.This attribute shall be present if the SUPI is not available in the SMF or the SUPI is unauthenticated. When present it shall be set to true for an invalid SUPI and false (default) for a valid SUPI.
	InvalidSupi *bool `json:"invalidSupi,omitempty"`

	// IpDomain Indicates the IPv4 address domain
	IpDomain           *string                     `json:"ipDomain,omitempty"`
	Ipv4Address        externalRef0.Ipv4Addr       `json:"ipv4Address,omitempty"`
	Ipv4FrameRouteList []externalRef0.Ipv4AddrMask `json:"ipv4FrameRouteList,omitempty"`
	Ipv6AddressPrefix  *externalRef0.Ipv6Prefix    `json:"ipv6AddressPrefix,omitempty"`
	Ipv6FrameRouteList []externalRef0.Ipv6Prefix   `json:"ipv6FrameRouteList,omitempty"`
	MaPduInd           *MaPduIndication            `json:"maPduInd,omitempty"`
	NotificationUri    externalRef0.Uri            `json:"notificationUri"`

	// NumOfPackFilter Contains the number of supported packet filter for signalled QoS rules.
	NumOfPackFilter *int `json:"numOfPackFilter,omitempty"`

	// Offline If it is included and set to true, the offline charging is applied to the PDU session.
	Offline *bool `json:"offline,omitempty"`

	// Online If it is included and set to true, the online charging is applied to the PDU session.
	Online         *bool                       `json:"online,omitempty"`
	PduSessionId   externalRef0.PduSessionId   `json:"pduSessionId"`
	PduSessionType externalRef0.PduSessionType `json:"pduSessionType"`
	Pei            externalRef0.Pei            `json:"pei,omitempty"`

	// QosFlowUsage Possible values are - GENERAL: Indicate no specific QoS flow usage information is available.  - IMS_SIG: Indicate that the QoS flow is used for IMS signalling only.
	QosFlowUsage *QosFlowUsage          `json:"qosFlowUsage,omitempty"`
	RatType      *externalRef0.RatType  `json:"ratType,omitempty"`
	RecoveryTime *externalRef0.DateTime `json:"recoveryTime,omitempty"`

	// RefQosIndication If it is included and set to true, the reflective QoS is supported by the UE.
	RefQosIndication     *bool                              `json:"refQosIndication,omitempty"`
	ServNfId             *ServingNfIdentity                 `json:"servNfId,omitempty"`
	ServingNetwork       *externalRef0.PlmnIdNid            `json:"servingNetwork,omitempty"`
	SliceInfo            externalRef0.Snssai                `json:"sliceInfo"`
	SmfId                *externalRef0.NfInstanceId         `json:"smfId,omitempty"`
	SubsDefQos           *externalRef0.SubscribedDefaultQos `json:"subsDefQos,omitempty"`
	SubsSessAmbr         *externalRef0.Ambr                 `json:"subsSessAmbr,omitempty"`
	Supi                 externalRef0.Supi                  `json:"supi"`
	SuppFeat             *externalRef0.SupportedFeatures    `json:"suppFeat,omitempty"`
	TraceReq             *externalRef0.TraceData            `json:"traceReq"`
	UeTimeZone           *externalRef0.TimeZone             `json:"ueTimeZone,omitempty"`
	UserLocationInfo     *externalRef0.UserLocation         `json:"userLocationInfo,omitempty"`
	VplmnQos             *externalRef3.VplmnQos             `json:"vplmnQos,omitempty"`
	AdditionalProperties map[string]interface{}             `json:"-"`
}

// SmPolicyControl defines model for SmPolicyControl.
type SmPolicyControl struct {
	Context              SmPolicyContextData    `json:"context"`
	Policy               SmPolicyDecision       `json:"policy"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SmPolicyDecision defines model for SmPolicyDecision.
type SmPolicyDecision struct {
	ChargingInfo *ChargingInformation `json:"chargingInfo,omitempty"`

	// ChgDecs Map of Charging data policy decisions.
	ChgDecs *map[string]*ChargingData `json:"chgDecs"`

	// Conds A map of condition data with the content being as described in subclause 5.6.2.9.
	Conds     *map[string]*ConditionData `json:"conds"`
	Ipv4Index *externalRef4.IpIndex      `json:"ipv4Index,omitempty"`
	Ipv6Index *externalRef4.IpIndex      `json:"ipv6Index,omitempty"`

	// LastReqRuleData Defines the last list of rule control data requested by the PCF.
	LastReqRuleData  []RequestedRuleData `json:"lastReqRuleData,omitempty"`
	LastReqUsageData *RequestedUsageData `json:"lastReqUsageData,omitempty"`

	// Offline Indicates the offline charging is applicable to the PDU session when it is included and set to true.
	Offline *bool `json:"offline,omitempty"`

	// Online Indicates the online charging is applicable to the PDU session when it is included and set to true.
	Online *bool `json:"online,omitempty"`

	// PccRules A map of PCC rules with the content being the PCCRule as described in subclause 5.6.2.6.
	PccRules *map[string]*PccRule `json:"pccRules"`

	// PcscfRestIndication If it is included and set to true, it indicates the P-CSCF Restoration is requested.
	PcscfRestIndication *bool `json:"pcscfRestIndication,omitempty"`

	// PolicyCtrlReqTriggers Defines the policy control request triggers subscribed by the PCF.
	PolicyCtrlReqTriggers *[]PolicyControlRequestTrigger `json:"policyCtrlReqTriggers"`

	// PraInfos Map of PRA information.
	PraInfos *map[string]*externalRef0.PresenceInfoRm `json:"praInfos"`

	// QosChars Map of QoS characteristics for non standard 5QIs. This map uses the 5QI values as keys.
	QosChars *map[string]QosCharacteristics `json:"qosChars,omitempty"`

	// QosDecs Map of QoS data policy decisions.
	QosDecs *map[string]*QosData `json:"qosDecs,omitempty"`

	// QosFlowUsage Possible values are - GENERAL: Indicate no specific QoS flow usage information is available.  - IMS_SIG: Indicate that the QoS flow is used for IMS signalling only.
	QosFlowUsage *QosFlowUsage `json:"qosFlowUsage,omitempty"`

	// QosMonDecs Map of QoS Monitoring data policy decisions.
	QosMonDecs *map[string]*QosMonitoringData `json:"qosMonDecs"`

	// RedSessIndication Indicates whether the PDU session is a redundant PDU session. If absent it means the PDU session is not a redundant PDU session.
	RedSessIndication  *bool                            `json:"redSessIndication,omitempty"`
	ReflectiveQoSTimer *externalRef0.DurationSec        `json:"reflectiveQoSTimer,omitempty"`
	RelCause           *SmPolicyAssociationReleaseCause `json:"relCause,omitempty"`
	RevalidationTime   *externalRef0.DateTime           `json:"revalidationTime,omitempty"`

	// SessRules A map of Sessionrules with the content being the SessionRule as described in subclause 5.6.2.7.
	SessRules *map[string]*SessionRule        `json:"sessRules,omitempty"`
	SuppFeat  *externalRef0.SupportedFeatures `json:"suppFeat,omitempty"`

	// TraffContDecs Map of Traffic Control data policy decisions.
	TraffContDecs       *map[string]*TrafficControlData `json:"traffContDecs,omitempty"`
	TsnBridgeManCont    *BridgeManagementContainer      `json:"tsnBridgeManCont,omitempty"`
	TsnPortManContDstt  *PortManagementContainer        `json:"tsnPortManContDstt,omitempty"`
	TsnPortManContNwtts []PortManagementContainer       `json:"tsnPortManContNwtts,omitempty"`

	// UmDecs Map of Usage Monitoring data policy decisions.
	UmDecs               *map[string]*UsageMonitoringData `json:"umDecs"`
	AdditionalProperties map[string]interface{}           `json:"-"`
}

// SmPolicyDeleteData defines model for SmPolicyDeleteData.
type SmPolicyDeleteData struct {
	// AccuUsageReports Contains the usage report
	AccuUsageReports []AccuUsageReport   `json:"accuUsageReports,omitempty"`
	PduSessRelCause  *PduSessionRelCause `json:"pduSessRelCause,omitempty"`

	// RanNasRelCauses Contains the RAN and/or NAS release cause.
	RanNasRelCauses      []RanNasRelCause           `json:"ranNasRelCauses,omitempty"`
	ServingNetwork       *externalRef0.PlmnIdNid    `json:"servingNetwork,omitempty"`
	UeTimeZone           *externalRef0.TimeZone     `json:"ueTimeZone,omitempty"`
	UserLocationInfo     *externalRef0.UserLocation `json:"userLocationInfo,omitempty"`
	UserLocationInfoTime *externalRef0.DateTime     `json:"userLocationInfoTime,omitempty"`
	AdditionalProperties map[string]interface{}     `json:"-"`
}

// SmPolicyNotification defines model for SmPolicyNotification.
type SmPolicyNotification struct {
	ResourceUri          *externalRef0.Uri      `json:"resourceUri,omitempty"`
	SmPolicyDecision     *SmPolicyDecision      `json:"smPolicyDecision,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SmPolicyUpdateContextData defines model for SmPolicyUpdateContextData.
type SmPolicyUpdateContextData struct {
	// N3gppPsDataOffStatus If it is included and set to true, the 3GPP PS Data Off is activated by the UE.
	N3gppPsDataOffStatus *bool `json:"3gppPsDataOffStatus,omitempty"`

	// AccNetChIds Indicates the access network charging identifier for the PCC rule(s) or whole PDU session.
	AccNetChIds []AccNetChId            `json:"accNetChIds,omitempty"`
	AccessType  externalRef0.AccessType `json:"accessType,omitempty"`

	// AccuUsageReports Contains the usage report
	AccuUsageReports       []AccuUsageReport        `json:"accuUsageReports,omitempty"`
	AddAccessInfo          *AdditionalAccessInfo    `json:"addAccessInfo,omitempty"`
	AddIpv6AddrPrefixes    *externalRef0.Ipv6Prefix `json:"addIpv6AddrPrefixes,omitempty"`
	AddRelIpv6AddrPrefixes *externalRef0.Ipv6Prefix `json:"addRelIpv6AddrPrefixes,omitempty"`

	// AppDetectionInfos Report the start/stop of the application traffic and detected SDF descriptions if applicable.
	AppDetectionInfos []AppDetectionInfo `json:"appDetectionInfos,omitempty"`
	AtsssCapab        *AtsssCapability   `json:"atsssCapab,omitempty"`

	// AuthProfIndex Indicates the DN-AAA authorization profile index
	AuthProfIndex      *string                 `json:"authProfIndex,omitempty"`
	CreditManageStatus *CreditManagementStatus `json:"creditManageStatus,omitempty"`
	InterGrpIds        []externalRef0.GroupId  `json:"interGrpIds,omitempty"`

	// IpDomain Indicates the IPv4 address domain
	IpDomain          *string                  `json:"ipDomain,omitempty"`
	Ipv4Address       externalRef0.Ipv4Addr    `json:"ipv4Address,omitempty"`
	Ipv6AddressPrefix *externalRef0.Ipv6Prefix `json:"ipv6AddressPrefix,omitempty"`
	MaPduInd          *MaPduIndication         `json:"maPduInd,omitempty"`
	MulAddrInfos      []IpMulticastAddressInfo `json:"mulAddrInfos,omitempty"`

	// NumOfPackFilter Contains the number of supported packet filter for signalled QoS rules.
	NumOfPackFilter *int `json:"numOfPackFilter,omitempty"`

	// PccRuleId Contains the identifier of the PCC rule which is used for traffic detection of event.
	PccRuleId *string `json:"pccRuleId,omitempty"`

	// PolicyDecFailureReports Contains the type(s) of failed policy decision and/or condition data.
	PolicyDecFailureReports []PolicyDecisionFailureCode `json:"policyDecFailureReports,omitempty"`

	// QncReports QoS Notification Control information.
	QncReports []QosNotificationControlInfo `json:"qncReports,omitempty"`

	// QosFlowUsage Possible values are - GENERAL: Indicate no specific QoS flow usage information is available.  - IMS_SIG: Indicate that the QoS flow is used for IMS signalling only.
	QosFlowUsage  *QosFlowUsage         `json:"qosFlowUsage,omitempty"`
	QosMonReports []QosMonitoringReport `json:"qosMonReports,omitempty"`
	RatType       *externalRef0.RatType `json:"ratType,omitempty"`

	// RefQosIndication If it is included and set to true, the reflective QoS is supported by the UE. If it is included and set to false, the reflective QoS is revoked by the UE.
	RefQosIndication     *bool                    `json:"refQosIndication,omitempty"`
	RelAccessInfo        *AdditionalAccessInfo    `json:"relAccessInfo,omitempty"`
	RelIpv4Address       externalRef0.Ipv4Addr    `json:"relIpv4Address,omitempty"`
	RelIpv6AddressPrefix *externalRef0.Ipv6Prefix `json:"relIpv6AddressPrefix,omitempty"`
	RelUeMac             externalRef0.MacAddr48   `json:"relUeMac,omitempty"`

	// RepPolicyCtrlReqTriggers The policy control reqeust trigges which are met.
	RepPolicyCtrlReqTriggers []PolicyControlRequestTrigger `json:"repPolicyCtrlReqTriggers,omitempty"`

	// RepPraInfos Reports the changes of presence reporting area.
	RepPraInfos *map[string]externalRef0.PresenceInfo `json:"repPraInfos,omitempty"`

	// RuleReports Used to report the PCC rule failure.
	RuleReports    []RuleReport            `json:"ruleReports,omitempty"`
	ServNfId       *ServingNfIdentity      `json:"servNfId,omitempty"`
	ServingNetwork *externalRef0.PlmnIdNid `json:"servingNetwork,omitempty"`

	// SessRuleReports Used to report the session rule failure.
	SessRuleReports      []SessionRuleReport                 `json:"sessRuleReports,omitempty"`
	SubsDefQos           *externalRef0.SubscribedDefaultQos  `json:"subsDefQos,omitempty"`
	SubsSessAmbr         *externalRef0.Ambr                  `json:"subsSessAmbr,omitempty"`
	TraceReq             *externalRef0.TraceData             `json:"traceReq"`
	TrafficDescriptors   []externalRef0.DddTrafficDescriptor `json:"trafficDescriptors,omitempty"`
	TsnBridgeInfo        *TsnBridgeInfo                      `json:"tsnBridgeInfo,omitempty"`
	TsnBridgeManCont     *BridgeManagementContainer          `json:"tsnBridgeManCont,omitempty"`
	TsnPortManContDstt   *PortManagementContainer            `json:"tsnPortManContDstt,omitempty"`
	TsnPortManContNwtts  []PortManagementContainer           `json:"tsnPortManContNwtts,omitempty"`
	TypesOfNotif         []externalRef0.DlDataDeliveryStatus `json:"typesOfNotif,omitempty"`
	UeInitResReq         *UeInitiatedResourceRequest         `json:"ueInitResReq,omitempty"`
	UeMac                externalRef0.MacAddr48              `json:"ueMac,omitempty"`
	UeTimeZone           *externalRef0.TimeZone              `json:"ueTimeZone,omitempty"`
	UserLocationInfo     *externalRef0.UserLocation          `json:"userLocationInfo,omitempty"`
	UserLocationInfoTime *externalRef0.DateTime              `json:"userLocationInfoTime,omitempty"`
	VplmnQos             *externalRef3.VplmnQos              `json:"vplmnQos,omitempty"`

	// VplmnQosNotApp If it is included and set to true, indicates that the QoS constraints in the VPLMN are not applicable.
	VplmnQosNotApp       *bool                  `json:"vplmnQosNotApp,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// SteerModeValue defines model for SteerModeValue.
type SteerModeValue string

// SteeringFunctionality Possible values are
//   - MPTCP: Indicates that PCF authorizes the MPTCP functionality to support traffic steering, switching and splitting.
//   - ATSSS_LL: Indicates that PCF authorizes the ATSSS-LL functionality to support traffic steering, switching and splitting.
type SteeringFunctionality string

// SteeringMode defines model for SteeringMode.
type SteeringMode struct {
	N3gLoad              *externalRef0.Uinteger    `json:"3gLoad,omitempty"`
	Active               externalRef0.AccessType   `json:"active,omitempty"`
	PrioAcc              externalRef0.AccessType   `json:"prioAcc,omitempty"`
	Standby              externalRef0.AccessTypeRm `json:"standby,omitempty"`
	SteerModeValue       SteerModeValue            `json:"steerModeValue"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// TerminationNotification defines model for TerminationNotification.
type TerminationNotification struct {
	Cause                SmPolicyAssociationReleaseCause `json:"cause"`
	ResourceUri          externalRef0.Uri                `json:"resourceUri"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// TrafficControlData defines model for TrafficControlData.
type TrafficControlData struct {
	AddRedirectInfo []RedirectInformation    `json:"addRedirectInfo,omitempty"`
	FlowStatus      *externalRef2.FlowStatus `json:"flowStatus,omitempty"`
	MulAccCtrl      *MulticastAccessControl  `json:"mulAccCtrl,omitempty"`

	// MuteNotif Indicates whether applicat'on's start or stop notification is to be muted.
	MuteNotif    *bool                `json:"muteNotif,omitempty"`
	RedirectInfo *RedirectInformation `json:"redirectInfo,omitempty"`

	// RouteToLocs A list of location which the traffic shall be routed to for the AF request
	RouteToLocs []externalRef0.RouteToLocation `json:"routeToLocs,omitempty"`

	// SteerFun Possible values are
	//   - MPTCP: Indicates that PCF authorizes the MPTCP functionality to support traffic steering, switching and splitting.
	//   - ATSSS_LL: Indicates that PCF authorizes the ATSSS-LL functionality to support traffic steering, switching and splitting.
	SteerFun    *SteeringFunctionality `json:"steerFun,omitempty"`
	SteerModeDl *SteeringMode          `json:"steerModeDl,omitempty"`
	SteerModeUl *SteeringMode          `json:"steerModeUl,omitempty"`

	// TcId Univocally identifies the traffic control policy data within a PDU session.
	TcId          string `json:"tcId"`
	TraffCorreInd *bool  `json:"traffCorreInd,omitempty"`

	// TrafficSteeringPolIdDl Reference to a pre-configured traffic steering policy for downlink traffic at the SMF.
	TrafficSteeringPolIdDl *string `json:"trafficSteeringPolIdDl"`

	// TrafficSteeringPolIdUl Reference to a pre-configured traffic steering policy for uplink traffic at the SMF.
	TrafficSteeringPolIdUl *string                `json:"trafficSteeringPolIdUl"`
	UpPathChgEvent         *UpPathChgEvent        `json:"upPathChgEvent"`
	AdditionalProperties   map[string]interface{} `json:"-"`
}

// TsnBridgeInfo defines model for TsnBridgeInfo.
type TsnBridgeInfo struct {
	BridgeId             *externalRef0.Uint64   `json:"bridgeId,omitempty"`
	DsttAddr             externalRef0.MacAddr48 `json:"dsttAddr,omitempty"`
	DsttPortNum          *TsnPortNumber         `json:"dsttPortNum,omitempty"`
	DsttResidTime        *externalRef0.Uinteger `json:"dsttResidTime,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// TsnPortNumber defines model for TsnPortNumber.
type TsnPortNumber = externalRef0.Uinteger

// UeCampingRep defines model for UeCampingRep.
type UeCampingRep struct {
	AccessType externalRef0.AccessType `json:"accessType,omitempty"`

	// NetLocAccSupp Possible values are - ANR_NOT_SUPPORTED: Indicates that the access network does not support the report of access network information. - TZR_NOT_SUPPORTED: Indicates that the access network does not support the report of UE time zone. - LOC_NOT_SUPPORTED: Indicates that the access network does not support the report of UE Location (or PLMN Id).
	NetLocAccSupp        *NetLocAccessSupport       `json:"netLocAccSupp,omitempty"`
	RatType              *externalRef0.RatType      `json:"ratType,omitempty"`
	ServNfId             *ServingNfIdentity         `json:"servNfId,omitempty"`
	ServingNetwork       *externalRef0.PlmnIdNid    `json:"servingNetwork,omitempty"`
	UeTimeZone           *externalRef0.TimeZone     `json:"ueTimeZone,omitempty"`
	UserLocationInfo     *externalRef0.UserLocation `json:"userLocationInfo,omitempty"`
	AdditionalProperties map[string]interface{}     `json:"-"`
}

// UeInitiatedResourceRequest defines model for UeInitiatedResourceRequest.
type UeInitiatedResourceRequest struct {
	PackFiltInfo []PacketFilterInfo `json:"packFiltInfo"`
	PccRuleId    *string            `json:"pccRuleId,omitempty"`
	Precedence   *int               `json:"precedence,omitempty"`
	ReqQos       *RequestedQos      `json:"reqQos,omitempty"`

	// RuleOp Possible values are - CREATE_PCC_RULE: Indicates to create a new PCC rule to reserve the resource requested by the UE.  - DELETE_PCC_RULE: Indicates to delete a PCC rule corresponding to reserve the resource requested by the UE. - MODIFY_PCC_RULE_AND_ADD_PACKET_FILTERS: Indicates to modify the PCC rule by adding new packet filter(s). - MODIFY_ PCC_RULE_AND_REPLACE_PACKET_FILTERS: Indicates to modify the PCC rule by replacing the existing packet filter(s). - MODIFY_ PCC_RULE_AND_DELETE_PACKET_FILTERS: Indicates to modify the PCC rule by deleting the existing packet filter(s). - MODIFY_PCC_RULE_WITHOUT_MODIFY_PACKET_FILTERS: Indicates to modify the PCC rule by modifying the QoS of the PCC rule.
	RuleOp               RuleOperation          `json:"ruleOp"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpPathChgEvent defines model for UpPathChgEvent.
type UpPathChgEvent struct {
	AfAckInd *bool `json:"afAckInd,omitempty"`

	// DnaiChgType Possible values are - EARLY: Early notification of UP path reconfiguration. - EARLY_LATE: Early and late notification of UP path reconfiguration. This value shall only be present in the subscription to the DNAI change event. - LATE: Late notification of UP path reconfiguration.
	DnaiChgType externalRef0.DnaiChangeType `json:"dnaiChgType"`

	// NotifCorreId It is used to set the value of Notification Correlation ID in the notification sent by the SMF.
	NotifCorreId         string                 `json:"notifCorreId"`
	NotificationUri      externalRef0.Uri       `json:"notificationUri"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UsageMonitoringData defines model for UsageMonitoringData.
type UsageMonitoringData struct {
	// ExUsagePccRuleIds Contains the PCC rule identifier(s) which corresponding service data flow(s) shall be excluded from PDU Session usage monitoring. It is only included in the UsageMonitoringData instance for session level usage monitoring.
	ExUsagePccRuleIds *[]string                   `json:"exUsagePccRuleIds"`
	InactivityTime    *externalRef0.DurationSecRm `json:"inactivityTime"`
	MonitoringTime    *externalRef0.DateTimeRm    `json:"monitoringTime"`
	NextTimeThreshold *externalRef0.DurationSecRm `json:"nextTimeThreshold"`

	// NextVolThreshold Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	NextVolThreshold *externalRef1.VolumeRm `json:"nextVolThreshold"`

	// NextVolThresholdDownlink Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	NextVolThresholdDownlink *externalRef1.VolumeRm `json:"nextVolThresholdDownlink"`

	// NextVolThresholdUplink Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	NextVolThresholdUplink *externalRef1.VolumeRm      `json:"nextVolThresholdUplink"`
	TimeThreshold          *externalRef0.DurationSecRm `json:"timeThreshold"`

	// UmId Univocally identifies the usage monitoring policy data within a PDU session.
	UmId string `json:"umId"`

	// VolumeThreshold Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	VolumeThreshold *externalRef1.VolumeRm `json:"volumeThreshold"`

	// VolumeThresholdDownlink Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	VolumeThresholdDownlink *externalRef1.VolumeRm `json:"volumeThresholdDownlink"`

	// VolumeThresholdUplink Unsigned integer identifying a volume in units of bytes with "nullable=true" property.
	VolumeThresholdUplink *externalRef1.VolumeRm `json:"volumeThresholdUplink"`
	AdditionalProperties  map[string]interface{} `json:"-"`
}

// CreateSMPolicyJSONRequestBody defines body for CreateSMPolicy for application/json ContentType.
type CreateSMPolicyJSONRequestBody = SmPolicyContextData

// DeleteSMPolicyJSONRequestBody defines body for DeleteSMPolicy for application/json ContentType.
type DeleteSMPolicyJSONRequestBody = SmPolicyDeleteData

// UpdateSMPolicyJSONRequestBody defines body for UpdateSMPolicy for application/json ContentType.
type UpdateSMPolicyJSONRequestBody = SmPolicyUpdateContextData

// Getter for additional properties for AccNetChId. Returns the specified
// element and whether it was found
func (a AccNetChId) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccNetChId
func (a *AccNetChId) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccNetChId to handle AdditionalProperties
func (a *AccNetChId) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accNetChaIdValue"]; found {
		err = json.Unmarshal(raw, &a.AccNetChaIdValue)
		if err != nil {
			return fmt.Errorf("error reading 'accNetChaIdValue': %w", err)
		}
		delete(object, "accNetChaIdValue")
	}

	if raw, found := object["refPccRuleIds"]; found {
		err = json.Unmarshal(raw, &a.RefPccRuleIds)
		if err != nil {
			return fmt.Errorf("error reading 'refPccRuleIds': %w", err)
		}
		delete(object, "refPccRuleIds")
	}

	if raw, found := object["sessionChScope"]; found {
		err = json.Unmarshal(raw, &a.SessionChScope)
		if err != nil {
			return fmt.Errorf("error reading 'sessionChScope': %w", err)
		}
		delete(object, "sessionChScope")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccNetChId to handle AdditionalProperties
func (a AccNetChId) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["accNetChaIdValue"], err = json.Marshal(a.AccNetChaIdValue)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'accNetChaIdValue': %w", err)
	}

	if len(a.RefPccRuleIds) != 0 {
		object["refPccRuleIds"], err = json.Marshal(a.RefPccRuleIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'refPccRuleIds': %w", err)
		}
	}

	if a.SessionChScope != nil {
		object["sessionChScope"], err = json.Marshal(a.SessionChScope)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sessionChScope': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AccNetChargingAddress. Returns the specified
// element and whether it was found
func (a AccNetChargingAddress) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccNetChargingAddress
func (a *AccNetChargingAddress) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccNetChargingAddress to handle AdditionalProperties
func (a *AccNetChargingAddress) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["anChargIpv4Addr"]; found {
		err = json.Unmarshal(raw, &a.AnChargIpv4Addr)
		if err != nil {
			return fmt.Errorf("error reading 'anChargIpv4Addr': %w", err)
		}
		delete(object, "anChargIpv4Addr")
	}

	if raw, found := object["anChargIpv6Addr"]; found {
		err = json.Unmarshal(raw, &a.AnChargIpv6Addr)
		if err != nil {
			return fmt.Errorf("error reading 'anChargIpv6Addr': %w", err)
		}
		delete(object, "anChargIpv6Addr")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccNetChargingAddress to handle AdditionalProperties
func (a AccNetChargingAddress) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AnChargIpv4Addr) != 0 {
		object["anChargIpv4Addr"], err = json.Marshal(a.AnChargIpv4Addr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'anChargIpv4Addr': %w", err)
		}
	}

	if a.AnChargIpv6Addr != nil {
		object["anChargIpv6Addr"], err = json.Marshal(a.AnChargIpv6Addr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'anChargIpv6Addr': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AccuUsageReport. Returns the specified
// element and whether it was found
func (a AccuUsageReport) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AccuUsageReport
func (a *AccuUsageReport) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AccuUsageReport to handle AdditionalProperties
func (a *AccuUsageReport) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["nextTimeUsage"]; found {
		err = json.Unmarshal(raw, &a.NextTimeUsage)
		if err != nil {
			return fmt.Errorf("error reading 'nextTimeUsage': %w", err)
		}
		delete(object, "nextTimeUsage")
	}

	if raw, found := object["nextVolUsage"]; found {
		err = json.Unmarshal(raw, &a.NextVolUsage)
		if err != nil {
			return fmt.Errorf("error reading 'nextVolUsage': %w", err)
		}
		delete(object, "nextVolUsage")
	}

	if raw, found := object["nextVolUsageDownlink"]; found {
		err = json.Unmarshal(raw, &a.NextVolUsageDownlink)
		if err != nil {
			return fmt.Errorf("error reading 'nextVolUsageDownlink': %w", err)
		}
		delete(object, "nextVolUsageDownlink")
	}

	if raw, found := object["nextVolUsageUplink"]; found {
		err = json.Unmarshal(raw, &a.NextVolUsageUplink)
		if err != nil {
			return fmt.Errorf("error reading 'nextVolUsageUplink': %w", err)
		}
		delete(object, "nextVolUsageUplink")
	}

	if raw, found := object["refUmIds"]; found {
		err = json.Unmarshal(raw, &a.RefUmIds)
		if err != nil {
			return fmt.Errorf("error reading 'refUmIds': %w", err)
		}
		delete(object, "refUmIds")
	}

	if raw, found := object["timeUsage"]; found {
		err = json.Unmarshal(raw, &a.TimeUsage)
		if err != nil {
			return fmt.Errorf("error reading 'timeUsage': %w", err)
		}
		delete(object, "timeUsage")
	}

	if raw, found := object["volUsage"]; found {
		err = json.Unmarshal(raw, &a.VolUsage)
		if err != nil {
			return fmt.Errorf("error reading 'volUsage': %w", err)
		}
		delete(object, "volUsage")
	}

	if raw, found := object["volUsageDownlink"]; found {
		err = json.Unmarshal(raw, &a.VolUsageDownlink)
		if err != nil {
			return fmt.Errorf("error reading 'volUsageDownlink': %w", err)
		}
		delete(object, "volUsageDownlink")
	}

	if raw, found := object["volUsageUplink"]; found {
		err = json.Unmarshal(raw, &a.VolUsageUplink)
		if err != nil {
			return fmt.Errorf("error reading 'volUsageUplink': %w", err)
		}
		delete(object, "volUsageUplink")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AccuUsageReport to handle AdditionalProperties
func (a AccuUsageReport) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.NextTimeUsage != nil {
		object["nextTimeUsage"], err = json.Marshal(a.NextTimeUsage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nextTimeUsage': %w", err)
		}
	}

	if a.NextVolUsage != nil {
		object["nextVolUsage"], err = json.Marshal(a.NextVolUsage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nextVolUsage': %w", err)
		}
	}

	if a.NextVolUsageDownlink != nil {
		object["nextVolUsageDownlink"], err = json.Marshal(a.NextVolUsageDownlink)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nextVolUsageDownlink': %w", err)
		}
	}

	if a.NextVolUsageUplink != nil {
		object["nextVolUsageUplink"], err = json.Marshal(a.NextVolUsageUplink)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nextVolUsageUplink': %w", err)
		}
	}

	object["refUmIds"], err = json.Marshal(a.RefUmIds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refUmIds': %w", err)
	}

	if a.TimeUsage != nil {
		object["timeUsage"], err = json.Marshal(a.TimeUsage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timeUsage': %w", err)
		}
	}

	if a.VolUsage != nil {
		object["volUsage"], err = json.Marshal(a.VolUsage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'volUsage': %w", err)
		}
	}

	if a.VolUsageDownlink != nil {
		object["volUsageDownlink"], err = json.Marshal(a.VolUsageDownlink)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'volUsageDownlink': %w", err)
		}
	}

	if a.VolUsageUplink != nil {
		object["volUsageUplink"], err = json.Marshal(a.VolUsageUplink)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'volUsageUplink': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AdditionalAccessInfo. Returns the specified
// element and whether it was found
func (a AdditionalAccessInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AdditionalAccessInfo
func (a *AdditionalAccessInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AdditionalAccessInfo to handle AdditionalProperties
func (a *AdditionalAccessInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accessType"]; found {
		err = json.Unmarshal(raw, &a.AccessType)
		if err != nil {
			return fmt.Errorf("error reading 'accessType': %w", err)
		}
		delete(object, "accessType")
	}

	if raw, found := object["ratType"]; found {
		err = json.Unmarshal(raw, &a.RatType)
		if err != nil {
			return fmt.Errorf("error reading 'ratType': %w", err)
		}
		delete(object, "ratType")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AdditionalAccessInfo to handle AdditionalProperties
func (a AdditionalAccessInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["accessType"], err = json.Marshal(a.AccessType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'accessType': %w", err)
	}

	if a.RatType != nil {
		object["ratType"], err = json.Marshal(a.RatType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ratType': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AppDetectionInfo. Returns the specified
// element and whether it was found
func (a AppDetectionInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AppDetectionInfo
func (a *AppDetectionInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AppDetectionInfo to handle AdditionalProperties
func (a *AppDetectionInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["appId"]; found {
		err = json.Unmarshal(raw, &a.AppId)
		if err != nil {
			return fmt.Errorf("error reading 'appId': %w", err)
		}
		delete(object, "appId")
	}

	if raw, found := object["instanceId"]; found {
		err = json.Unmarshal(raw, &a.InstanceId)
		if err != nil {
			return fmt.Errorf("error reading 'instanceId': %w", err)
		}
		delete(object, "instanceId")
	}

	if raw, found := object["sdfDescriptions"]; found {
		err = json.Unmarshal(raw, &a.SdfDescriptions)
		if err != nil {
			return fmt.Errorf("error reading 'sdfDescriptions': %w", err)
		}
		delete(object, "sdfDescriptions")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AppDetectionInfo to handle AdditionalProperties
func (a AppDetectionInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["appId"], err = json.Marshal(a.AppId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'appId': %w", err)
	}

	if a.InstanceId != nil {
		object["instanceId"], err = json.Marshal(a.InstanceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'instanceId': %w", err)
		}
	}

	if len(a.SdfDescriptions) != 0 {
		object["sdfDescriptions"], err = json.Marshal(a.SdfDescriptions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sdfDescriptions': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AuthorizedDefaultQos. Returns the specified
// element and whether it was found
func (a AuthorizedDefaultQos) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AuthorizedDefaultQos
func (a *AuthorizedDefaultQos) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AuthorizedDefaultQos to handle AdditionalProperties
func (a *AuthorizedDefaultQos) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["5qi"]; found {
		err = json.Unmarshal(raw, &a.N5qi)
		if err != nil {
			return fmt.Errorf("error reading '5qi': %w", err)
		}
		delete(object, "5qi")
	}

	if raw, found := object["arp"]; found {
		err = json.Unmarshal(raw, &a.Arp)
		if err != nil {
			return fmt.Errorf("error reading 'arp': %w", err)
		}
		delete(object, "arp")
	}

	if raw, found := object["averWindow"]; found {
		err = json.Unmarshal(raw, &a.AverWindow)
		if err != nil {
			return fmt.Errorf("error reading 'averWindow': %w", err)
		}
		delete(object, "averWindow")
	}

	if raw, found := object["extMaxDataBurstVol"]; found {
		err = json.Unmarshal(raw, &a.ExtMaxDataBurstVol)
		if err != nil {
			return fmt.Errorf("error reading 'extMaxDataBurstVol': %w", err)
		}
		delete(object, "extMaxDataBurstVol")
	}

	if raw, found := object["gbrDl"]; found {
		err = json.Unmarshal(raw, &a.GbrDl)
		if err != nil {
			return fmt.Errorf("error reading 'gbrDl': %w", err)
		}
		delete(object, "gbrDl")
	}

	if raw, found := object["gbrUl"]; found {
		err = json.Unmarshal(raw, &a.GbrUl)
		if err != nil {
			return fmt.Errorf("error reading 'gbrUl': %w", err)
		}
		delete(object, "gbrUl")
	}

	if raw, found := object["maxDataBurstVol"]; found {
		err = json.Unmarshal(raw, &a.MaxDataBurstVol)
		if err != nil {
			return fmt.Errorf("error reading 'maxDataBurstVol': %w", err)
		}
		delete(object, "maxDataBurstVol")
	}

	if raw, found := object["maxbrDl"]; found {
		err = json.Unmarshal(raw, &a.MaxbrDl)
		if err != nil {
			return fmt.Errorf("error reading 'maxbrDl': %w", err)
		}
		delete(object, "maxbrDl")
	}

	if raw, found := object["maxbrUl"]; found {
		err = json.Unmarshal(raw, &a.MaxbrUl)
		if err != nil {
			return fmt.Errorf("error reading 'maxbrUl': %w", err)
		}
		delete(object, "maxbrUl")
	}

	if raw, found := object["priorityLevel"]; found {
		err = json.Unmarshal(raw, &a.PriorityLevel)
		if err != nil {
			return fmt.Errorf("error reading 'priorityLevel': %w", err)
		}
		delete(object, "priorityLevel")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AuthorizedDefaultQos to handle AdditionalProperties
func (a AuthorizedDefaultQos) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.N5qi != nil {
		object["5qi"], err = json.Marshal(a.N5qi)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '5qi': %w", err)
		}
	}

	if a.Arp != nil {
		object["arp"], err = json.Marshal(a.Arp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'arp': %w", err)
		}
	}

	object["averWindow"], err = json.Marshal(a.AverWindow)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'averWindow': %w", err)
	}

	object["extMaxDataBurstVol"], err = json.Marshal(a.ExtMaxDataBurstVol)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'extMaxDataBurstVol': %w", err)
	}

	object["gbrDl"], err = json.Marshal(a.GbrDl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'gbrDl': %w", err)
	}

	object["gbrUl"], err = json.Marshal(a.GbrUl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'gbrUl': %w", err)
	}

	object["maxDataBurstVol"], err = json.Marshal(a.MaxDataBurstVol)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'maxDataBurstVol': %w", err)
	}

	object["maxbrDl"], err = json.Marshal(a.MaxbrDl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'maxbrDl': %w", err)
	}

	object["maxbrUl"], err = json.Marshal(a.MaxbrUl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'maxbrUl': %w", err)
	}

	object["priorityLevel"], err = json.Marshal(a.PriorityLevel)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'priorityLevel': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for BridgeManagementContainer. Returns the specified
// element and whether it was found
func (a BridgeManagementContainer) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for BridgeManagementContainer
func (a *BridgeManagementContainer) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for BridgeManagementContainer to handle AdditionalProperties
func (a *BridgeManagementContainer) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["bridgeManCont"]; found {
		err = json.Unmarshal(raw, &a.BridgeManCont)
		if err != nil {
			return fmt.Errorf("error reading 'bridgeManCont': %w", err)
		}
		delete(object, "bridgeManCont")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for BridgeManagementContainer to handle AdditionalProperties
func (a BridgeManagementContainer) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["bridgeManCont"], err = json.Marshal(a.BridgeManCont)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'bridgeManCont': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ChargingData. Returns the specified
// element and whether it was found
func (a ChargingData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ChargingData
func (a *ChargingData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ChargingData to handle AdditionalProperties
func (a *ChargingData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["afChargId"]; found {
		err = json.Unmarshal(raw, &a.AfChargId)
		if err != nil {
			return fmt.Errorf("error reading 'afChargId': %w", err)
		}
		delete(object, "afChargId")
	}

	if raw, found := object["afChargingIdentifier"]; found {
		err = json.Unmarshal(raw, &a.AfChargingIdentifier)
		if err != nil {
			return fmt.Errorf("error reading 'afChargingIdentifier': %w", err)
		}
		delete(object, "afChargingIdentifier")
	}

	if raw, found := object["appSvcProvId"]; found {
		err = json.Unmarshal(raw, &a.AppSvcProvId)
		if err != nil {
			return fmt.Errorf("error reading 'appSvcProvId': %w", err)
		}
		delete(object, "appSvcProvId")
	}

	if raw, found := object["chgId"]; found {
		err = json.Unmarshal(raw, &a.ChgId)
		if err != nil {
			return fmt.Errorf("error reading 'chgId': %w", err)
		}
		delete(object, "chgId")
	}

	if raw, found := object["meteringMethod"]; found {
		err = json.Unmarshal(raw, &a.MeteringMethod)
		if err != nil {
			return fmt.Errorf("error reading 'meteringMethod': %w", err)
		}
		delete(object, "meteringMethod")
	}

	if raw, found := object["offline"]; found {
		err = json.Unmarshal(raw, &a.Offline)
		if err != nil {
			return fmt.Errorf("error reading 'offline': %w", err)
		}
		delete(object, "offline")
	}

	if raw, found := object["online"]; found {
		err = json.Unmarshal(raw, &a.Online)
		if err != nil {
			return fmt.Errorf("error reading 'online': %w", err)
		}
		delete(object, "online")
	}

	if raw, found := object["ratingGroup"]; found {
		err = json.Unmarshal(raw, &a.RatingGroup)
		if err != nil {
			return fmt.Errorf("error reading 'ratingGroup': %w", err)
		}
		delete(object, "ratingGroup")
	}

	if raw, found := object["reportingLevel"]; found {
		err = json.Unmarshal(raw, &a.ReportingLevel)
		if err != nil {
			return fmt.Errorf("error reading 'reportingLevel': %w", err)
		}
		delete(object, "reportingLevel")
	}

	if raw, found := object["sdfHandl"]; found {
		err = json.Unmarshal(raw, &a.SdfHandl)
		if err != nil {
			return fmt.Errorf("error reading 'sdfHandl': %w", err)
		}
		delete(object, "sdfHandl")
	}

	if raw, found := object["serviceId"]; found {
		err = json.Unmarshal(raw, &a.ServiceId)
		if err != nil {
			return fmt.Errorf("error reading 'serviceId': %w", err)
		}
		delete(object, "serviceId")
	}

	if raw, found := object["sponsorId"]; found {
		err = json.Unmarshal(raw, &a.SponsorId)
		if err != nil {
			return fmt.Errorf("error reading 'sponsorId': %w", err)
		}
		delete(object, "sponsorId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ChargingData to handle AdditionalProperties
func (a ChargingData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AfChargId != nil {
		object["afChargId"], err = json.Marshal(a.AfChargId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'afChargId': %w", err)
		}
	}

	if a.AfChargingIdentifier != nil {
		object["afChargingIdentifier"], err = json.Marshal(a.AfChargingIdentifier)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'afChargingIdentifier': %w", err)
		}
	}

	if a.AppSvcProvId != nil {
		object["appSvcProvId"], err = json.Marshal(a.AppSvcProvId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'appSvcProvId': %w", err)
		}
	}

	object["chgId"], err = json.Marshal(a.ChgId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'chgId': %w", err)
	}

	if a.MeteringMethod != nil {
		object["meteringMethod"], err = json.Marshal(a.MeteringMethod)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'meteringMethod': %w", err)
		}
	}

	if a.Offline != nil {
		object["offline"], err = json.Marshal(a.Offline)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'offline': %w", err)
		}
	}

	if a.Online != nil {
		object["online"], err = json.Marshal(a.Online)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'online': %w", err)
		}
	}

	if a.RatingGroup != nil {
		object["ratingGroup"], err = json.Marshal(a.RatingGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ratingGroup': %w", err)
		}
	}

	if a.ReportingLevel != nil {
		object["reportingLevel"], err = json.Marshal(a.ReportingLevel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reportingLevel': %w", err)
		}
	}

	if a.SdfHandl != nil {
		object["sdfHandl"], err = json.Marshal(a.SdfHandl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sdfHandl': %w", err)
		}
	}

	if a.ServiceId != nil {
		object["serviceId"], err = json.Marshal(a.ServiceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'serviceId': %w", err)
		}
	}

	if a.SponsorId != nil {
		object["sponsorId"], err = json.Marshal(a.SponsorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sponsorId': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ChargingInformation. Returns the specified
// element and whether it was found
func (a ChargingInformation) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ChargingInformation
func (a *ChargingInformation) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ChargingInformation to handle AdditionalProperties
func (a *ChargingInformation) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["primaryChfAddress"]; found {
		err = json.Unmarshal(raw, &a.PrimaryChfAddress)
		if err != nil {
			return fmt.Errorf("error reading 'primaryChfAddress': %w", err)
		}
		delete(object, "primaryChfAddress")
	}

	if raw, found := object["primaryChfInstanceId"]; found {
		err = json.Unmarshal(raw, &a.PrimaryChfInstanceId)
		if err != nil {
			return fmt.Errorf("error reading 'primaryChfInstanceId': %w", err)
		}
		delete(object, "primaryChfInstanceId")
	}

	if raw, found := object["primaryChfSetId"]; found {
		err = json.Unmarshal(raw, &a.PrimaryChfSetId)
		if err != nil {
			return fmt.Errorf("error reading 'primaryChfSetId': %w", err)
		}
		delete(object, "primaryChfSetId")
	}

	if raw, found := object["secondaryChfAddress"]; found {
		err = json.Unmarshal(raw, &a.SecondaryChfAddress)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryChfAddress': %w", err)
		}
		delete(object, "secondaryChfAddress")
	}

	if raw, found := object["secondaryChfInstanceId"]; found {
		err = json.Unmarshal(raw, &a.SecondaryChfInstanceId)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryChfInstanceId': %w", err)
		}
		delete(object, "secondaryChfInstanceId")
	}

	if raw, found := object["secondaryChfSetId"]; found {
		err = json.Unmarshal(raw, &a.SecondaryChfSetId)
		if err != nil {
			return fmt.Errorf("error reading 'secondaryChfSetId': %w", err)
		}
		delete(object, "secondaryChfSetId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ChargingInformation to handle AdditionalProperties
func (a ChargingInformation) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["primaryChfAddress"], err = json.Marshal(a.PrimaryChfAddress)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'primaryChfAddress': %w", err)
	}

	if a.PrimaryChfInstanceId != nil {
		object["primaryChfInstanceId"], err = json.Marshal(a.PrimaryChfInstanceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryChfInstanceId': %w", err)
		}
	}

	if a.PrimaryChfSetId != nil {
		object["primaryChfSetId"], err = json.Marshal(a.PrimaryChfSetId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'primaryChfSetId': %w", err)
		}
	}

	object["secondaryChfAddress"], err = json.Marshal(a.SecondaryChfAddress)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'secondaryChfAddress': %w", err)
	}

	if a.SecondaryChfInstanceId != nil {
		object["secondaryChfInstanceId"], err = json.Marshal(a.SecondaryChfInstanceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryChfInstanceId': %w", err)
		}
	}

	if a.SecondaryChfSetId != nil {
		object["secondaryChfSetId"], err = json.Marshal(a.SecondaryChfSetId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secondaryChfSetId': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ConditionData. Returns the specified
// element and whether it was found
func (a ConditionData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ConditionData
func (a *ConditionData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ConditionData to handle AdditionalProperties
func (a *ConditionData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accessType"]; found {
		err = json.Unmarshal(raw, &a.AccessType)
		if err != nil {
			return fmt.Errorf("error reading 'accessType': %w", err)
		}
		delete(object, "accessType")
	}

	if raw, found := object["activationTime"]; found {
		err = json.Unmarshal(raw, &a.ActivationTime)
		if err != nil {
			return fmt.Errorf("error reading 'activationTime': %w", err)
		}
		delete(object, "activationTime")
	}

	if raw, found := object["condId"]; found {
		err = json.Unmarshal(raw, &a.CondId)
		if err != nil {
			return fmt.Errorf("error reading 'condId': %w", err)
		}
		delete(object, "condId")
	}

	if raw, found := object["deactivationTime"]; found {
		err = json.Unmarshal(raw, &a.DeactivationTime)
		if err != nil {
			return fmt.Errorf("error reading 'deactivationTime': %w", err)
		}
		delete(object, "deactivationTime")
	}

	if raw, found := object["ratType"]; found {
		err = json.Unmarshal(raw, &a.RatType)
		if err != nil {
			return fmt.Errorf("error reading 'ratType': %w", err)
		}
		delete(object, "ratType")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ConditionData to handle AdditionalProperties
func (a ConditionData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AccessType) != 0 {
		object["accessType"], err = json.Marshal(a.AccessType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accessType': %w", err)
		}
	}

	object["activationTime"], err = json.Marshal(a.ActivationTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'activationTime': %w", err)
	}

	object["condId"], err = json.Marshal(a.CondId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'condId': %w", err)
	}

	object["deactivationTime"], err = json.Marshal(a.DeactivationTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'deactivationTime': %w", err)
	}

	if a.RatType != nil {
		object["ratType"], err = json.Marshal(a.RatType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ratType': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DownlinkDataNotificationControl. Returns the specified
// element and whether it was found
func (a DownlinkDataNotificationControl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DownlinkDataNotificationControl
func (a *DownlinkDataNotificationControl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DownlinkDataNotificationControl to handle AdditionalProperties
func (a *DownlinkDataNotificationControl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["notifCtrlInds"]; found {
		err = json.Unmarshal(raw, &a.NotifCtrlInds)
		if err != nil {
			return fmt.Errorf("error reading 'notifCtrlInds': %w", err)
		}
		delete(object, "notifCtrlInds")
	}

	if raw, found := object["typesOfNotif"]; found {
		err = json.Unmarshal(raw, &a.TypesOfNotif)
		if err != nil {
			return fmt.Errorf("error reading 'typesOfNotif': %w", err)
		}
		delete(object, "typesOfNotif")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DownlinkDataNotificationControl to handle AdditionalProperties
func (a DownlinkDataNotificationControl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.NotifCtrlInds) != 0 {
		object["notifCtrlInds"], err = json.Marshal(a.NotifCtrlInds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notifCtrlInds': %w", err)
		}
	}

	if len(a.TypesOfNotif) != 0 {
		object["typesOfNotif"], err = json.Marshal(a.TypesOfNotif)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'typesOfNotif': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DownlinkDataNotificationControlRm. Returns the specified
// element and whether it was found
func (a DownlinkDataNotificationControlRm) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DownlinkDataNotificationControlRm
func (a *DownlinkDataNotificationControlRm) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DownlinkDataNotificationControlRm to handle AdditionalProperties
func (a *DownlinkDataNotificationControlRm) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["notifCtrlInds"]; found {
		err = json.Unmarshal(raw, &a.NotifCtrlInds)
		if err != nil {
			return fmt.Errorf("error reading 'notifCtrlInds': %w", err)
		}
		delete(object, "notifCtrlInds")
	}

	if raw, found := object["typesOfNotif"]; found {
		err = json.Unmarshal(raw, &a.TypesOfNotif)
		if err != nil {
			return fmt.Errorf("error reading 'typesOfNotif': %w", err)
		}
		delete(object, "typesOfNotif")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DownlinkDataNotificationControlRm to handle AdditionalProperties
func (a DownlinkDataNotificationControlRm) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["notifCtrlInds"], err = json.Marshal(a.NotifCtrlInds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'notifCtrlInds': %w", err)
	}

	object["typesOfNotif"], err = json.Marshal(a.TypesOfNotif)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'typesOfNotif': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ErrorReport. Returns the specified
// element and whether it was found
func (a ErrorReport) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ErrorReport
func (a *ErrorReport) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ErrorReport to handle AdditionalProperties
func (a *ErrorReport) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["altQosParamId"]; found {
		err = json.Unmarshal(raw, &a.AltQosParamId)
		if err != nil {
			return fmt.Errorf("error reading 'altQosParamId': %w", err)
		}
		delete(object, "altQosParamId")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["polDecFailureReports"]; found {
		err = json.Unmarshal(raw, &a.PolDecFailureReports)
		if err != nil {
			return fmt.Errorf("error reading 'polDecFailureReports': %w", err)
		}
		delete(object, "polDecFailureReports")
	}

	if raw, found := object["ruleReports"]; found {
		err = json.Unmarshal(raw, &a.RuleReports)
		if err != nil {
			return fmt.Errorf("error reading 'ruleReports': %w", err)
		}
		delete(object, "ruleReports")
	}

	if raw, found := object["sessRuleReports"]; found {
		err = json.Unmarshal(raw, &a.SessRuleReports)
		if err != nil {
			return fmt.Errorf("error reading 'sessRuleReports': %w", err)
		}
		delete(object, "sessRuleReports")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ErrorReport to handle AdditionalProperties
func (a ErrorReport) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AltQosParamId != nil {
		object["altQosParamId"], err = json.Marshal(a.AltQosParamId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'altQosParamId': %w", err)
		}
	}

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	if len(a.PolDecFailureReports) != 0 {
		object["polDecFailureReports"], err = json.Marshal(a.PolDecFailureReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'polDecFailureReports': %w", err)
		}
	}

	if len(a.RuleReports) != 0 {
		object["ruleReports"], err = json.Marshal(a.RuleReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ruleReports': %w", err)
		}
	}

	if len(a.SessRuleReports) != 0 {
		object["sessRuleReports"], err = json.Marshal(a.SessRuleReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sessRuleReports': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for FlowInformation. Returns the specified
// element and whether it was found
func (a FlowInformation) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for FlowInformation
func (a *FlowInformation) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for FlowInformation to handle AdditionalProperties
func (a *FlowInformation) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ethFlowDescription"]; found {
		err = json.Unmarshal(raw, &a.EthFlowDescription)
		if err != nil {
			return fmt.Errorf("error reading 'ethFlowDescription': %w", err)
		}
		delete(object, "ethFlowDescription")
	}

	if raw, found := object["flowDescription"]; found {
		err = json.Unmarshal(raw, &a.FlowDescription)
		if err != nil {
			return fmt.Errorf("error reading 'flowDescription': %w", err)
		}
		delete(object, "flowDescription")
	}

	if raw, found := object["flowDirection"]; found {
		err = json.Unmarshal(raw, &a.FlowDirection)
		if err != nil {
			return fmt.Errorf("error reading 'flowDirection': %w", err)
		}
		delete(object, "flowDirection")
	}

	if raw, found := object["flowLabel"]; found {
		err = json.Unmarshal(raw, &a.FlowLabel)
		if err != nil {
			return fmt.Errorf("error reading 'flowLabel': %w", err)
		}
		delete(object, "flowLabel")
	}

	if raw, found := object["packFiltId"]; found {
		err = json.Unmarshal(raw, &a.PackFiltId)
		if err != nil {
			return fmt.Errorf("error reading 'packFiltId': %w", err)
		}
		delete(object, "packFiltId")
	}

	if raw, found := object["packetFilterUsage"]; found {
		err = json.Unmarshal(raw, &a.PacketFilterUsage)
		if err != nil {
			return fmt.Errorf("error reading 'packetFilterUsage': %w", err)
		}
		delete(object, "packetFilterUsage")
	}

	if raw, found := object["spi"]; found {
		err = json.Unmarshal(raw, &a.Spi)
		if err != nil {
			return fmt.Errorf("error reading 'spi': %w", err)
		}
		delete(object, "spi")
	}

	if raw, found := object["tosTrafficClass"]; found {
		err = json.Unmarshal(raw, &a.TosTrafficClass)
		if err != nil {
			return fmt.Errorf("error reading 'tosTrafficClass': %w", err)
		}
		delete(object, "tosTrafficClass")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for FlowInformation to handle AdditionalProperties
func (a FlowInformation) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.EthFlowDescription != nil {
		object["ethFlowDescription"], err = json.Marshal(a.EthFlowDescription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ethFlowDescription': %w", err)
		}
	}

	if a.FlowDescription != nil {
		object["flowDescription"], err = json.Marshal(a.FlowDescription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'flowDescription': %w", err)
		}
	}

	if a.FlowDirection != nil {
		object["flowDirection"], err = json.Marshal(a.FlowDirection)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'flowDirection': %w", err)
		}
	}

	object["flowLabel"], err = json.Marshal(a.FlowLabel)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'flowLabel': %w", err)
	}

	if a.PackFiltId != nil {
		object["packFiltId"], err = json.Marshal(a.PackFiltId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'packFiltId': %w", err)
		}
	}

	if a.PacketFilterUsage != nil {
		object["packetFilterUsage"], err = json.Marshal(a.PacketFilterUsage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'packetFilterUsage': %w", err)
		}
	}

	object["spi"], err = json.Marshal(a.Spi)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'spi': %w", err)
	}

	object["tosTrafficClass"], err = json.Marshal(a.TosTrafficClass)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'tosTrafficClass': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IpMulticastAddressInfo. Returns the specified
// element and whether it was found
func (a IpMulticastAddressInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IpMulticastAddressInfo
func (a *IpMulticastAddressInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IpMulticastAddressInfo to handle AdditionalProperties
func (a *IpMulticastAddressInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ipv4MulAddr"]; found {
		err = json.Unmarshal(raw, &a.Ipv4MulAddr)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4MulAddr': %w", err)
		}
		delete(object, "ipv4MulAddr")
	}

	if raw, found := object["ipv6MulAddr"]; found {
		err = json.Unmarshal(raw, &a.Ipv6MulAddr)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6MulAddr': %w", err)
		}
		delete(object, "ipv6MulAddr")
	}

	if raw, found := object["srcIpv4Addr"]; found {
		err = json.Unmarshal(raw, &a.SrcIpv4Addr)
		if err != nil {
			return fmt.Errorf("error reading 'srcIpv4Addr': %w", err)
		}
		delete(object, "srcIpv4Addr")
	}

	if raw, found := object["srcIpv6Addr"]; found {
		err = json.Unmarshal(raw, &a.SrcIpv6Addr)
		if err != nil {
			return fmt.Errorf("error reading 'srcIpv6Addr': %w", err)
		}
		delete(object, "srcIpv6Addr")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IpMulticastAddressInfo to handle AdditionalProperties
func (a IpMulticastAddressInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.Ipv4MulAddr) != 0 {
		object["ipv4MulAddr"], err = json.Marshal(a.Ipv4MulAddr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4MulAddr': %w", err)
		}
	}

	if a.Ipv6MulAddr != nil {
		object["ipv6MulAddr"], err = json.Marshal(a.Ipv6MulAddr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6MulAddr': %w", err)
		}
	}

	if len(a.SrcIpv4Addr) != 0 {
		object["srcIpv4Addr"], err = json.Marshal(a.SrcIpv4Addr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'srcIpv4Addr': %w", err)
		}
	}

	if a.SrcIpv6Addr != nil {
		object["srcIpv6Addr"], err = json.Marshal(a.SrcIpv6Addr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'srcIpv6Addr': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PacketFilterInfo. Returns the specified
// element and whether it was found
func (a PacketFilterInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PacketFilterInfo
func (a *PacketFilterInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PacketFilterInfo to handle AdditionalProperties
func (a *PacketFilterInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["flowDirection"]; found {
		err = json.Unmarshal(raw, &a.FlowDirection)
		if err != nil {
			return fmt.Errorf("error reading 'flowDirection': %w", err)
		}
		delete(object, "flowDirection")
	}

	if raw, found := object["flowLabel"]; found {
		err = json.Unmarshal(raw, &a.FlowLabel)
		if err != nil {
			return fmt.Errorf("error reading 'flowLabel': %w", err)
		}
		delete(object, "flowLabel")
	}

	if raw, found := object["packFiltCont"]; found {
		err = json.Unmarshal(raw, &a.PackFiltCont)
		if err != nil {
			return fmt.Errorf("error reading 'packFiltCont': %w", err)
		}
		delete(object, "packFiltCont")
	}

	if raw, found := object["packFiltId"]; found {
		err = json.Unmarshal(raw, &a.PackFiltId)
		if err != nil {
			return fmt.Errorf("error reading 'packFiltId': %w", err)
		}
		delete(object, "packFiltId")
	}

	if raw, found := object["spi"]; found {
		err = json.Unmarshal(raw, &a.Spi)
		if err != nil {
			return fmt.Errorf("error reading 'spi': %w", err)
		}
		delete(object, "spi")
	}

	if raw, found := object["tosTrafficClass"]; found {
		err = json.Unmarshal(raw, &a.TosTrafficClass)
		if err != nil {
			return fmt.Errorf("error reading 'tosTrafficClass': %w", err)
		}
		delete(object, "tosTrafficClass")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PacketFilterInfo to handle AdditionalProperties
func (a PacketFilterInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.FlowDirection != nil {
		object["flowDirection"], err = json.Marshal(a.FlowDirection)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'flowDirection': %w", err)
		}
	}

	if a.FlowLabel != nil {
		object["flowLabel"], err = json.Marshal(a.FlowLabel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'flowLabel': %w", err)
		}
	}

	if a.PackFiltCont != nil {
		object["packFiltCont"], err = json.Marshal(a.PackFiltCont)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'packFiltCont': %w", err)
		}
	}

	if a.PackFiltId != nil {
		object["packFiltId"], err = json.Marshal(a.PackFiltId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'packFiltId': %w", err)
		}
	}

	if a.Spi != nil {
		object["spi"], err = json.Marshal(a.Spi)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spi': %w", err)
		}
	}

	if a.TosTrafficClass != nil {
		object["tosTrafficClass"], err = json.Marshal(a.TosTrafficClass)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tosTrafficClass': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PartialSuccessReport. Returns the specified
// element and whether it was found
func (a PartialSuccessReport) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PartialSuccessReport
func (a *PartialSuccessReport) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PartialSuccessReport to handle AdditionalProperties
func (a *PartialSuccessReport) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["failureCause"]; found {
		err = json.Unmarshal(raw, &a.FailureCause)
		if err != nil {
			return fmt.Errorf("error reading 'failureCause': %w", err)
		}
		delete(object, "failureCause")
	}

	if raw, found := object["policyDecFailureReports"]; found {
		err = json.Unmarshal(raw, &a.PolicyDecFailureReports)
		if err != nil {
			return fmt.Errorf("error reading 'policyDecFailureReports': %w", err)
		}
		delete(object, "policyDecFailureReports")
	}

	if raw, found := object["ruleReports"]; found {
		err = json.Unmarshal(raw, &a.RuleReports)
		if err != nil {
			return fmt.Errorf("error reading 'ruleReports': %w", err)
		}
		delete(object, "ruleReports")
	}

	if raw, found := object["sessRuleReports"]; found {
		err = json.Unmarshal(raw, &a.SessRuleReports)
		if err != nil {
			return fmt.Errorf("error reading 'sessRuleReports': %w", err)
		}
		delete(object, "sessRuleReports")
	}

	if raw, found := object["ueCampingRep"]; found {
		err = json.Unmarshal(raw, &a.UeCampingRep)
		if err != nil {
			return fmt.Errorf("error reading 'ueCampingRep': %w", err)
		}
		delete(object, "ueCampingRep")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PartialSuccessReport to handle AdditionalProperties
func (a PartialSuccessReport) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["failureCause"], err = json.Marshal(a.FailureCause)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'failureCause': %w", err)
	}

	if len(a.PolicyDecFailureReports) != 0 {
		object["policyDecFailureReports"], err = json.Marshal(a.PolicyDecFailureReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'policyDecFailureReports': %w", err)
		}
	}

	if len(a.RuleReports) != 0 {
		object["ruleReports"], err = json.Marshal(a.RuleReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ruleReports': %w", err)
		}
	}

	if len(a.SessRuleReports) != 0 {
		object["sessRuleReports"], err = json.Marshal(a.SessRuleReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sessRuleReports': %w", err)
		}
	}

	if a.UeCampingRep != nil {
		object["ueCampingRep"], err = json.Marshal(a.UeCampingRep)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ueCampingRep': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PccRule. Returns the specified
// element and whether it was found
func (a PccRule) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PccRule
func (a *PccRule) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PccRule to handle AdditionalProperties
func (a *PccRule) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["addrPreserInd"]; found {
		err = json.Unmarshal(raw, &a.AddrPreserInd)
		if err != nil {
			return fmt.Errorf("error reading 'addrPreserInd': %w", err)
		}
		delete(object, "addrPreserInd")
	}

	if raw, found := object["afSigProtocol"]; found {
		err = json.Unmarshal(raw, &a.AfSigProtocol)
		if err != nil {
			return fmt.Errorf("error reading 'afSigProtocol': %w", err)
		}
		delete(object, "afSigProtocol")
	}

	if raw, found := object["appDescriptor"]; found {
		err = json.Unmarshal(raw, &a.AppDescriptor)
		if err != nil {
			return fmt.Errorf("error reading 'appDescriptor': %w", err)
		}
		delete(object, "appDescriptor")
	}

	if raw, found := object["appId"]; found {
		err = json.Unmarshal(raw, &a.AppId)
		if err != nil {
			return fmt.Errorf("error reading 'appId': %w", err)
		}
		delete(object, "appId")
	}

	if raw, found := object["appReloc"]; found {
		err = json.Unmarshal(raw, &a.AppReloc)
		if err != nil {
			return fmt.Errorf("error reading 'appReloc': %w", err)
		}
		delete(object, "appReloc")
	}

	if raw, found := object["contVer"]; found {
		err = json.Unmarshal(raw, &a.ContVer)
		if err != nil {
			return fmt.Errorf("error reading 'contVer': %w", err)
		}
		delete(object, "contVer")
	}

	if raw, found := object["ddNotifCtrl"]; found {
		err = json.Unmarshal(raw, &a.DdNotifCtrl)
		if err != nil {
			return fmt.Errorf("error reading 'ddNotifCtrl': %w", err)
		}
		delete(object, "ddNotifCtrl")
	}

	if raw, found := object["ddNotifCtrl2"]; found {
		err = json.Unmarshal(raw, &a.DdNotifCtrl2)
		if err != nil {
			return fmt.Errorf("error reading 'ddNotifCtrl2': %w", err)
		}
		delete(object, "ddNotifCtrl2")
	}

	if raw, found := object["disUeNotif"]; found {
		err = json.Unmarshal(raw, &a.DisUeNotif)
		if err != nil {
			return fmt.Errorf("error reading 'disUeNotif': %w", err)
		}
		delete(object, "disUeNotif")
	}

	if raw, found := object["flowInfos"]; found {
		err = json.Unmarshal(raw, &a.FlowInfos)
		if err != nil {
			return fmt.Errorf("error reading 'flowInfos': %w", err)
		}
		delete(object, "flowInfos")
	}

	if raw, found := object["pccRuleId"]; found {
		err = json.Unmarshal(raw, &a.PccRuleId)
		if err != nil {
			return fmt.Errorf("error reading 'pccRuleId': %w", err)
		}
		delete(object, "pccRuleId")
	}

	if raw, found := object["precedence"]; found {
		err = json.Unmarshal(raw, &a.Precedence)
		if err != nil {
			return fmt.Errorf("error reading 'precedence': %w", err)
		}
		delete(object, "precedence")
	}

	if raw, found := object["refAltQosParams"]; found {
		err = json.Unmarshal(raw, &a.RefAltQosParams)
		if err != nil {
			return fmt.Errorf("error reading 'refAltQosParams': %w", err)
		}
		delete(object, "refAltQosParams")
	}

	if raw, found := object["refChgData"]; found {
		err = json.Unmarshal(raw, &a.RefChgData)
		if err != nil {
			return fmt.Errorf("error reading 'refChgData': %w", err)
		}
		delete(object, "refChgData")
	}

	if raw, found := object["refChgN3gData"]; found {
		err = json.Unmarshal(raw, &a.RefChgN3gData)
		if err != nil {
			return fmt.Errorf("error reading 'refChgN3gData': %w", err)
		}
		delete(object, "refChgN3gData")
	}

	if raw, found := object["refCondData"]; found {
		err = json.Unmarshal(raw, &a.RefCondData)
		if err != nil {
			return fmt.Errorf("error reading 'refCondData': %w", err)
		}
		delete(object, "refCondData")
	}

	if raw, found := object["refQosData"]; found {
		err = json.Unmarshal(raw, &a.RefQosData)
		if err != nil {
			return fmt.Errorf("error reading 'refQosData': %w", err)
		}
		delete(object, "refQosData")
	}

	if raw, found := object["refQosMon"]; found {
		err = json.Unmarshal(raw, &a.RefQosMon)
		if err != nil {
			return fmt.Errorf("error reading 'refQosMon': %w", err)
		}
		delete(object, "refQosMon")
	}

	if raw, found := object["refTcData"]; found {
		err = json.Unmarshal(raw, &a.RefTcData)
		if err != nil {
			return fmt.Errorf("error reading 'refTcData': %w", err)
		}
		delete(object, "refTcData")
	}

	if raw, found := object["refUmData"]; found {
		err = json.Unmarshal(raw, &a.RefUmData)
		if err != nil {
			return fmt.Errorf("error reading 'refUmData': %w", err)
		}
		delete(object, "refUmData")
	}

	if raw, found := object["refUmN3gData"]; found {
		err = json.Unmarshal(raw, &a.RefUmN3gData)
		if err != nil {
			return fmt.Errorf("error reading 'refUmN3gData': %w", err)
		}
		delete(object, "refUmN3gData")
	}

	if raw, found := object["tscaiInputDl"]; found {
		err = json.Unmarshal(raw, &a.TscaiInputDl)
		if err != nil {
			return fmt.Errorf("error reading 'tscaiInputDl': %w", err)
		}
		delete(object, "tscaiInputDl")
	}

	if raw, found := object["tscaiInputUl"]; found {
		err = json.Unmarshal(raw, &a.TscaiInputUl)
		if err != nil {
			return fmt.Errorf("error reading 'tscaiInputUl': %w", err)
		}
		delete(object, "tscaiInputUl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PccRule to handle AdditionalProperties
func (a PccRule) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["addrPreserInd"], err = json.Marshal(a.AddrPreserInd)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'addrPreserInd': %w", err)
	}

	if a.AfSigProtocol != nil {
		object["afSigProtocol"], err = json.Marshal(a.AfSigProtocol)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'afSigProtocol': %w", err)
		}
	}

	if a.AppDescriptor != nil {
		object["appDescriptor"], err = json.Marshal(a.AppDescriptor)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'appDescriptor': %w", err)
		}
	}

	if a.AppId != nil {
		object["appId"], err = json.Marshal(a.AppId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'appId': %w", err)
		}
	}

	if a.AppReloc != nil {
		object["appReloc"], err = json.Marshal(a.AppReloc)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'appReloc': %w", err)
		}
	}

	if a.ContVer != nil {
		object["contVer"], err = json.Marshal(a.ContVer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'contVer': %w", err)
		}
	}

	if a.DdNotifCtrl != nil {
		object["ddNotifCtrl"], err = json.Marshal(a.DdNotifCtrl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ddNotifCtrl': %w", err)
		}
	}

	object["ddNotifCtrl2"], err = json.Marshal(a.DdNotifCtrl2)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'ddNotifCtrl2': %w", err)
	}

	object["disUeNotif"], err = json.Marshal(a.DisUeNotif)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disUeNotif': %w", err)
	}

	if len(a.FlowInfos) != 0 {
		object["flowInfos"], err = json.Marshal(a.FlowInfos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'flowInfos': %w", err)
		}
	}

	object["pccRuleId"], err = json.Marshal(a.PccRuleId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pccRuleId': %w", err)
	}

	if a.Precedence != nil {
		object["precedence"], err = json.Marshal(a.Precedence)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'precedence': %w", err)
		}
	}

	if len(a.RefAltQosParams) != 0 {
		object["refAltQosParams"], err = json.Marshal(a.RefAltQosParams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'refAltQosParams': %w", err)
		}
	}

	object["refChgData"], err = json.Marshal(a.RefChgData)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refChgData': %w", err)
	}

	object["refChgN3gData"], err = json.Marshal(a.RefChgN3gData)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refChgN3gData': %w", err)
	}

	object["refCondData"], err = json.Marshal(a.RefCondData)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refCondData': %w", err)
	}

	if len(a.RefQosData) != 0 {
		object["refQosData"], err = json.Marshal(a.RefQosData)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'refQosData': %w", err)
		}
	}

	object["refQosMon"], err = json.Marshal(a.RefQosMon)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refQosMon': %w", err)
	}

	if len(a.RefTcData) != 0 {
		object["refTcData"], err = json.Marshal(a.RefTcData)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'refTcData': %w", err)
		}
	}

	object["refUmData"], err = json.Marshal(a.RefUmData)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refUmData': %w", err)
	}

	object["refUmN3gData"], err = json.Marshal(a.RefUmN3gData)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refUmN3gData': %w", err)
	}

	object["tscaiInputDl"], err = json.Marshal(a.TscaiInputDl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'tscaiInputDl': %w", err)
	}

	object["tscaiInputUl"], err = json.Marshal(a.TscaiInputUl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'tscaiInputUl': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PortManagementContainer. Returns the specified
// element and whether it was found
func (a PortManagementContainer) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PortManagementContainer
func (a *PortManagementContainer) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PortManagementContainer to handle AdditionalProperties
func (a *PortManagementContainer) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["portManCont"]; found {
		err = json.Unmarshal(raw, &a.PortManCont)
		if err != nil {
			return fmt.Errorf("error reading 'portManCont': %w", err)
		}
		delete(object, "portManCont")
	}

	if raw, found := object["portNum"]; found {
		err = json.Unmarshal(raw, &a.PortNum)
		if err != nil {
			return fmt.Errorf("error reading 'portNum': %w", err)
		}
		delete(object, "portNum")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PortManagementContainer to handle AdditionalProperties
func (a PortManagementContainer) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["portManCont"], err = json.Marshal(a.PortManCont)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'portManCont': %w", err)
	}

	object["portNum"], err = json.Marshal(a.PortNum)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'portNum': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for QosCharacteristics. Returns the specified
// element and whether it was found
func (a QosCharacteristics) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for QosCharacteristics
func (a *QosCharacteristics) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for QosCharacteristics to handle AdditionalProperties
func (a *QosCharacteristics) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["5qi"]; found {
		err = json.Unmarshal(raw, &a.N5qi)
		if err != nil {
			return fmt.Errorf("error reading '5qi': %w", err)
		}
		delete(object, "5qi")
	}

	if raw, found := object["averagingWindow"]; found {
		err = json.Unmarshal(raw, &a.AveragingWindow)
		if err != nil {
			return fmt.Errorf("error reading 'averagingWindow': %w", err)
		}
		delete(object, "averagingWindow")
	}

	if raw, found := object["extMaxDataBurstVol"]; found {
		err = json.Unmarshal(raw, &a.ExtMaxDataBurstVol)
		if err != nil {
			return fmt.Errorf("error reading 'extMaxDataBurstVol': %w", err)
		}
		delete(object, "extMaxDataBurstVol")
	}

	if raw, found := object["maxDataBurstVol"]; found {
		err = json.Unmarshal(raw, &a.MaxDataBurstVol)
		if err != nil {
			return fmt.Errorf("error reading 'maxDataBurstVol': %w", err)
		}
		delete(object, "maxDataBurstVol")
	}

	if raw, found := object["packetDelayBudget"]; found {
		err = json.Unmarshal(raw, &a.PacketDelayBudget)
		if err != nil {
			return fmt.Errorf("error reading 'packetDelayBudget': %w", err)
		}
		delete(object, "packetDelayBudget")
	}

	if raw, found := object["packetErrorRate"]; found {
		err = json.Unmarshal(raw, &a.PacketErrorRate)
		if err != nil {
			return fmt.Errorf("error reading 'packetErrorRate': %w", err)
		}
		delete(object, "packetErrorRate")
	}

	if raw, found := object["priorityLevel"]; found {
		err = json.Unmarshal(raw, &a.PriorityLevel)
		if err != nil {
			return fmt.Errorf("error reading 'priorityLevel': %w", err)
		}
		delete(object, "priorityLevel")
	}

	if raw, found := object["resourceType"]; found {
		err = json.Unmarshal(raw, &a.ResourceType)
		if err != nil {
			return fmt.Errorf("error reading 'resourceType': %w", err)
		}
		delete(object, "resourceType")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for QosCharacteristics to handle AdditionalProperties
func (a QosCharacteristics) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["5qi"], err = json.Marshal(a.N5qi)
	if err != nil {
		return nil, fmt.Errorf("error marshaling '5qi': %w", err)
	}

	if a.AveragingWindow != 0 {
		object["averagingWindow"], err = json.Marshal(a.AveragingWindow)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'averagingWindow': %w", err)
		}
	}

	if a.ExtMaxDataBurstVol != 0 {
		object["extMaxDataBurstVol"], err = json.Marshal(a.ExtMaxDataBurstVol)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'extMaxDataBurstVol': %w", err)
		}
	}

	if a.MaxDataBurstVol != 0 {
		object["maxDataBurstVol"], err = json.Marshal(a.MaxDataBurstVol)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'maxDataBurstVol': %w", err)
		}
	}

	object["packetDelayBudget"], err = json.Marshal(a.PacketDelayBudget)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'packetDelayBudget': %w", err)
	}

	object["packetErrorRate"], err = json.Marshal(a.PacketErrorRate)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'packetErrorRate': %w", err)
	}

	object["priorityLevel"], err = json.Marshal(a.PriorityLevel)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'priorityLevel': %w", err)
	}

	object["resourceType"], err = json.Marshal(a.ResourceType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'resourceType': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for QosData. Returns the specified
// element and whether it was found
func (a QosData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for QosData
func (a *QosData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for QosData to handle AdditionalProperties
func (a *QosData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["5qi"]; found {
		err = json.Unmarshal(raw, &a.N5qi)
		if err != nil {
			return fmt.Errorf("error reading '5qi': %w", err)
		}
		delete(object, "5qi")
	}

	if raw, found := object["arp"]; found {
		err = json.Unmarshal(raw, &a.Arp)
		if err != nil {
			return fmt.Errorf("error reading 'arp': %w", err)
		}
		delete(object, "arp")
	}

	if raw, found := object["averWindow"]; found {
		err = json.Unmarshal(raw, &a.AverWindow)
		if err != nil {
			return fmt.Errorf("error reading 'averWindow': %w", err)
		}
		delete(object, "averWindow")
	}

	if raw, found := object["defQosFlowIndication"]; found {
		err = json.Unmarshal(raw, &a.DefQosFlowIndication)
		if err != nil {
			return fmt.Errorf("error reading 'defQosFlowIndication': %w", err)
		}
		delete(object, "defQosFlowIndication")
	}

	if raw, found := object["extMaxDataBurstVol"]; found {
		err = json.Unmarshal(raw, &a.ExtMaxDataBurstVol)
		if err != nil {
			return fmt.Errorf("error reading 'extMaxDataBurstVol': %w", err)
		}
		delete(object, "extMaxDataBurstVol")
	}

	if raw, found := object["gbrDl"]; found {
		err = json.Unmarshal(raw, &a.GbrDl)
		if err != nil {
			return fmt.Errorf("error reading 'gbrDl': %w", err)
		}
		delete(object, "gbrDl")
	}

	if raw, found := object["gbrUl"]; found {
		err = json.Unmarshal(raw, &a.GbrUl)
		if err != nil {
			return fmt.Errorf("error reading 'gbrUl': %w", err)
		}
		delete(object, "gbrUl")
	}

	if raw, found := object["maxDataBurstVol"]; found {
		err = json.Unmarshal(raw, &a.MaxDataBurstVol)
		if err != nil {
			return fmt.Errorf("error reading 'maxDataBurstVol': %w", err)
		}
		delete(object, "maxDataBurstVol")
	}

	if raw, found := object["maxPacketLossRateDl"]; found {
		err = json.Unmarshal(raw, &a.MaxPacketLossRateDl)
		if err != nil {
			return fmt.Errorf("error reading 'maxPacketLossRateDl': %w", err)
		}
		delete(object, "maxPacketLossRateDl")
	}

	if raw, found := object["maxPacketLossRateUl"]; found {
		err = json.Unmarshal(raw, &a.MaxPacketLossRateUl)
		if err != nil {
			return fmt.Errorf("error reading 'maxPacketLossRateUl': %w", err)
		}
		delete(object, "maxPacketLossRateUl")
	}

	if raw, found := object["maxbrDl"]; found {
		err = json.Unmarshal(raw, &a.MaxbrDl)
		if err != nil {
			return fmt.Errorf("error reading 'maxbrDl': %w", err)
		}
		delete(object, "maxbrDl")
	}

	if raw, found := object["maxbrUl"]; found {
		err = json.Unmarshal(raw, &a.MaxbrUl)
		if err != nil {
			return fmt.Errorf("error reading 'maxbrUl': %w", err)
		}
		delete(object, "maxbrUl")
	}

	if raw, found := object["packetDelayBudget"]; found {
		err = json.Unmarshal(raw, &a.PacketDelayBudget)
		if err != nil {
			return fmt.Errorf("error reading 'packetDelayBudget': %w", err)
		}
		delete(object, "packetDelayBudget")
	}

	if raw, found := object["packetErrorRate"]; found {
		err = json.Unmarshal(raw, &a.PacketErrorRate)
		if err != nil {
			return fmt.Errorf("error reading 'packetErrorRate': %w", err)
		}
		delete(object, "packetErrorRate")
	}

	if raw, found := object["priorityLevel"]; found {
		err = json.Unmarshal(raw, &a.PriorityLevel)
		if err != nil {
			return fmt.Errorf("error reading 'priorityLevel': %w", err)
		}
		delete(object, "priorityLevel")
	}

	if raw, found := object["qnc"]; found {
		err = json.Unmarshal(raw, &a.Qnc)
		if err != nil {
			return fmt.Errorf("error reading 'qnc': %w", err)
		}
		delete(object, "qnc")
	}

	if raw, found := object["qosId"]; found {
		err = json.Unmarshal(raw, &a.QosId)
		if err != nil {
			return fmt.Errorf("error reading 'qosId': %w", err)
		}
		delete(object, "qosId")
	}

	if raw, found := object["reflectiveQos"]; found {
		err = json.Unmarshal(raw, &a.ReflectiveQos)
		if err != nil {
			return fmt.Errorf("error reading 'reflectiveQos': %w", err)
		}
		delete(object, "reflectiveQos")
	}

	if raw, found := object["sharingKeyDl"]; found {
		err = json.Unmarshal(raw, &a.SharingKeyDl)
		if err != nil {
			return fmt.Errorf("error reading 'sharingKeyDl': %w", err)
		}
		delete(object, "sharingKeyDl")
	}

	if raw, found := object["sharingKeyUl"]; found {
		err = json.Unmarshal(raw, &a.SharingKeyUl)
		if err != nil {
			return fmt.Errorf("error reading 'sharingKeyUl': %w", err)
		}
		delete(object, "sharingKeyUl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for QosData to handle AdditionalProperties
func (a QosData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.N5qi != nil {
		object["5qi"], err = json.Marshal(a.N5qi)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '5qi': %w", err)
		}
	}

	if a.Arp != nil {
		object["arp"], err = json.Marshal(a.Arp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'arp': %w", err)
		}
	}

	object["averWindow"], err = json.Marshal(a.AverWindow)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'averWindow': %w", err)
	}

	if a.DefQosFlowIndication != nil {
		object["defQosFlowIndication"], err = json.Marshal(a.DefQosFlowIndication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'defQosFlowIndication': %w", err)
		}
	}

	object["extMaxDataBurstVol"], err = json.Marshal(a.ExtMaxDataBurstVol)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'extMaxDataBurstVol': %w", err)
	}

	object["gbrDl"], err = json.Marshal(a.GbrDl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'gbrDl': %w", err)
	}

	object["gbrUl"], err = json.Marshal(a.GbrUl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'gbrUl': %w", err)
	}

	object["maxDataBurstVol"], err = json.Marshal(a.MaxDataBurstVol)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'maxDataBurstVol': %w", err)
	}

	object["maxPacketLossRateDl"], err = json.Marshal(a.MaxPacketLossRateDl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'maxPacketLossRateDl': %w", err)
	}

	object["maxPacketLossRateUl"], err = json.Marshal(a.MaxPacketLossRateUl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'maxPacketLossRateUl': %w", err)
	}

	object["maxbrDl"], err = json.Marshal(a.MaxbrDl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'maxbrDl': %w", err)
	}

	object["maxbrUl"], err = json.Marshal(a.MaxbrUl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'maxbrUl': %w", err)
	}

	if a.PacketDelayBudget != 0 {
		object["packetDelayBudget"], err = json.Marshal(a.PacketDelayBudget)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'packetDelayBudget': %w", err)
		}
	}

	if len(a.PacketErrorRate) != 0 {
		object["packetErrorRate"], err = json.Marshal(a.PacketErrorRate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'packetErrorRate': %w", err)
		}
	}

	object["priorityLevel"], err = json.Marshal(a.PriorityLevel)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'priorityLevel': %w", err)
	}

	if a.Qnc != nil {
		object["qnc"], err = json.Marshal(a.Qnc)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'qnc': %w", err)
		}
	}

	object["qosId"], err = json.Marshal(a.QosId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'qosId': %w", err)
	}

	if a.ReflectiveQos != nil {
		object["reflectiveQos"], err = json.Marshal(a.ReflectiveQos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reflectiveQos': %w", err)
		}
	}

	if a.SharingKeyDl != nil {
		object["sharingKeyDl"], err = json.Marshal(a.SharingKeyDl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sharingKeyDl': %w", err)
		}
	}

	if a.SharingKeyUl != nil {
		object["sharingKeyUl"], err = json.Marshal(a.SharingKeyUl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sharingKeyUl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for QosMonitoringData. Returns the specified
// element and whether it was found
func (a QosMonitoringData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for QosMonitoringData
func (a *QosMonitoringData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for QosMonitoringData to handle AdditionalProperties
func (a *QosMonitoringData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["notifyCorreId"]; found {
		err = json.Unmarshal(raw, &a.NotifyCorreId)
		if err != nil {
			return fmt.Errorf("error reading 'notifyCorreId': %w", err)
		}
		delete(object, "notifyCorreId")
	}

	if raw, found := object["notifyUri"]; found {
		err = json.Unmarshal(raw, &a.NotifyUri)
		if err != nil {
			return fmt.Errorf("error reading 'notifyUri': %w", err)
		}
		delete(object, "notifyUri")
	}

	if raw, found := object["qmId"]; found {
		err = json.Unmarshal(raw, &a.QmId)
		if err != nil {
			return fmt.Errorf("error reading 'qmId': %w", err)
		}
		delete(object, "qmId")
	}

	if raw, found := object["repFreqs"]; found {
		err = json.Unmarshal(raw, &a.RepFreqs)
		if err != nil {
			return fmt.Errorf("error reading 'repFreqs': %w", err)
		}
		delete(object, "repFreqs")
	}

	if raw, found := object["repPeriod"]; found {
		err = json.Unmarshal(raw, &a.RepPeriod)
		if err != nil {
			return fmt.Errorf("error reading 'repPeriod': %w", err)
		}
		delete(object, "repPeriod")
	}

	if raw, found := object["repThreshDl"]; found {
		err = json.Unmarshal(raw, &a.RepThreshDl)
		if err != nil {
			return fmt.Errorf("error reading 'repThreshDl': %w", err)
		}
		delete(object, "repThreshDl")
	}

	if raw, found := object["repThreshRp"]; found {
		err = json.Unmarshal(raw, &a.RepThreshRp)
		if err != nil {
			return fmt.Errorf("error reading 'repThreshRp': %w", err)
		}
		delete(object, "repThreshRp")
	}

	if raw, found := object["repThreshUl"]; found {
		err = json.Unmarshal(raw, &a.RepThreshUl)
		if err != nil {
			return fmt.Errorf("error reading 'repThreshUl': %w", err)
		}
		delete(object, "repThreshUl")
	}

	if raw, found := object["reqQosMonParams"]; found {
		err = json.Unmarshal(raw, &a.ReqQosMonParams)
		if err != nil {
			return fmt.Errorf("error reading 'reqQosMonParams': %w", err)
		}
		delete(object, "reqQosMonParams")
	}

	if raw, found := object["waitTime"]; found {
		err = json.Unmarshal(raw, &a.WaitTime)
		if err != nil {
			return fmt.Errorf("error reading 'waitTime': %w", err)
		}
		delete(object, "waitTime")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for QosMonitoringData to handle AdditionalProperties
func (a QosMonitoringData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.NotifyCorreId != nil {
		object["notifyCorreId"], err = json.Marshal(a.NotifyCorreId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notifyCorreId': %w", err)
		}
	}

	if a.NotifyUri != nil {
		object["notifyUri"], err = json.Marshal(a.NotifyUri)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notifyUri': %w", err)
		}
	}

	object["qmId"], err = json.Marshal(a.QmId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'qmId': %w", err)
	}

	object["repFreqs"], err = json.Marshal(a.RepFreqs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'repFreqs': %w", err)
	}

	object["repPeriod"], err = json.Marshal(a.RepPeriod)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'repPeriod': %w", err)
	}

	object["repThreshDl"], err = json.Marshal(a.RepThreshDl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'repThreshDl': %w", err)
	}

	object["repThreshRp"], err = json.Marshal(a.RepThreshRp)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'repThreshRp': %w", err)
	}

	object["repThreshUl"], err = json.Marshal(a.RepThreshUl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'repThreshUl': %w", err)
	}

	object["reqQosMonParams"], err = json.Marshal(a.ReqQosMonParams)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'reqQosMonParams': %w", err)
	}

	object["waitTime"], err = json.Marshal(a.WaitTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'waitTime': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for QosMonitoringReport. Returns the specified
// element and whether it was found
func (a QosMonitoringReport) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for QosMonitoringReport
func (a *QosMonitoringReport) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for QosMonitoringReport to handle AdditionalProperties
func (a *QosMonitoringReport) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dlDelays"]; found {
		err = json.Unmarshal(raw, &a.DlDelays)
		if err != nil {
			return fmt.Errorf("error reading 'dlDelays': %w", err)
		}
		delete(object, "dlDelays")
	}

	if raw, found := object["refPccRuleIds"]; found {
		err = json.Unmarshal(raw, &a.RefPccRuleIds)
		if err != nil {
			return fmt.Errorf("error reading 'refPccRuleIds': %w", err)
		}
		delete(object, "refPccRuleIds")
	}

	if raw, found := object["rtDelays"]; found {
		err = json.Unmarshal(raw, &a.RtDelays)
		if err != nil {
			return fmt.Errorf("error reading 'rtDelays': %w", err)
		}
		delete(object, "rtDelays")
	}

	if raw, found := object["ulDelays"]; found {
		err = json.Unmarshal(raw, &a.UlDelays)
		if err != nil {
			return fmt.Errorf("error reading 'ulDelays': %w", err)
		}
		delete(object, "ulDelays")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for QosMonitoringReport to handle AdditionalProperties
func (a QosMonitoringReport) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.DlDelays) != 0 {
		object["dlDelays"], err = json.Marshal(a.DlDelays)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dlDelays': %w", err)
		}
	}

	object["refPccRuleIds"], err = json.Marshal(a.RefPccRuleIds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refPccRuleIds': %w", err)
	}

	if len(a.RtDelays) != 0 {
		object["rtDelays"], err = json.Marshal(a.RtDelays)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'rtDelays': %w", err)
		}
	}

	if len(a.UlDelays) != 0 {
		object["ulDelays"], err = json.Marshal(a.UlDelays)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ulDelays': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for QosNotificationControlInfo. Returns the specified
// element and whether it was found
func (a QosNotificationControlInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for QosNotificationControlInfo
func (a *QosNotificationControlInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for QosNotificationControlInfo to handle AdditionalProperties
func (a *QosNotificationControlInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["altQosParamId"]; found {
		err = json.Unmarshal(raw, &a.AltQosParamId)
		if err != nil {
			return fmt.Errorf("error reading 'altQosParamId': %w", err)
		}
		delete(object, "altQosParamId")
	}

	if raw, found := object["contVer"]; found {
		err = json.Unmarshal(raw, &a.ContVer)
		if err != nil {
			return fmt.Errorf("error reading 'contVer': %w", err)
		}
		delete(object, "contVer")
	}

	if raw, found := object["notifType"]; found {
		err = json.Unmarshal(raw, &a.NotifType)
		if err != nil {
			return fmt.Errorf("error reading 'notifType': %w", err)
		}
		delete(object, "notifType")
	}

	if raw, found := object["refPccRuleIds"]; found {
		err = json.Unmarshal(raw, &a.RefPccRuleIds)
		if err != nil {
			return fmt.Errorf("error reading 'refPccRuleIds': %w", err)
		}
		delete(object, "refPccRuleIds")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for QosNotificationControlInfo to handle AdditionalProperties
func (a QosNotificationControlInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AltQosParamId != nil {
		object["altQosParamId"], err = json.Marshal(a.AltQosParamId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'altQosParamId': %w", err)
		}
	}

	if a.ContVer != nil {
		object["contVer"], err = json.Marshal(a.ContVer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'contVer': %w", err)
		}
	}

	object["notifType"], err = json.Marshal(a.NotifType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'notifType': %w", err)
	}

	object["refPccRuleIds"], err = json.Marshal(a.RefPccRuleIds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refPccRuleIds': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RanNasRelCause. Returns the specified
// element and whether it was found
func (a RanNasRelCause) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RanNasRelCause
func (a *RanNasRelCause) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RanNasRelCause to handle AdditionalProperties
func (a *RanNasRelCause) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["5gMmCause"]; found {
		err = json.Unmarshal(raw, &a.N5gMmCause)
		if err != nil {
			return fmt.Errorf("error reading '5gMmCause': %w", err)
		}
		delete(object, "5gMmCause")
	}

	if raw, found := object["5gSmCause"]; found {
		err = json.Unmarshal(raw, &a.N5gSmCause)
		if err != nil {
			return fmt.Errorf("error reading '5gSmCause': %w", err)
		}
		delete(object, "5gSmCause")
	}

	if raw, found := object["epsCause"]; found {
		err = json.Unmarshal(raw, &a.EpsCause)
		if err != nil {
			return fmt.Errorf("error reading 'epsCause': %w", err)
		}
		delete(object, "epsCause")
	}

	if raw, found := object["ngApCause"]; found {
		err = json.Unmarshal(raw, &a.NgApCause)
		if err != nil {
			return fmt.Errorf("error reading 'ngApCause': %w", err)
		}
		delete(object, "ngApCause")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RanNasRelCause to handle AdditionalProperties
func (a RanNasRelCause) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.N5gMmCause != nil {
		object["5gMmCause"], err = json.Marshal(a.N5gMmCause)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '5gMmCause': %w", err)
		}
	}

	if a.N5gSmCause != nil {
		object["5gSmCause"], err = json.Marshal(a.N5gSmCause)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '5gSmCause': %w", err)
		}
	}

	if a.EpsCause != nil {
		object["epsCause"], err = json.Marshal(a.EpsCause)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'epsCause': %w", err)
		}
	}

	if a.NgApCause != nil {
		object["ngApCause"], err = json.Marshal(a.NgApCause)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ngApCause': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RedirectInformation. Returns the specified
// element and whether it was found
func (a RedirectInformation) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RedirectInformation
func (a *RedirectInformation) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RedirectInformation to handle AdditionalProperties
func (a *RedirectInformation) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["redirectAddressType"]; found {
		err = json.Unmarshal(raw, &a.RedirectAddressType)
		if err != nil {
			return fmt.Errorf("error reading 'redirectAddressType': %w", err)
		}
		delete(object, "redirectAddressType")
	}

	if raw, found := object["redirectEnabled"]; found {
		err = json.Unmarshal(raw, &a.RedirectEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'redirectEnabled': %w", err)
		}
		delete(object, "redirectEnabled")
	}

	if raw, found := object["redirectServerAddress"]; found {
		err = json.Unmarshal(raw, &a.RedirectServerAddress)
		if err != nil {
			return fmt.Errorf("error reading 'redirectServerAddress': %w", err)
		}
		delete(object, "redirectServerAddress")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RedirectInformation to handle AdditionalProperties
func (a RedirectInformation) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.RedirectAddressType != nil {
		object["redirectAddressType"], err = json.Marshal(a.RedirectAddressType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'redirectAddressType': %w", err)
		}
	}

	if a.RedirectEnabled != nil {
		object["redirectEnabled"], err = json.Marshal(a.RedirectEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'redirectEnabled': %w", err)
		}
	}

	if a.RedirectServerAddress != nil {
		object["redirectServerAddress"], err = json.Marshal(a.RedirectServerAddress)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'redirectServerAddress': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestedQos. Returns the specified
// element and whether it was found
func (a RequestedQos) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestedQos
func (a *RequestedQos) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestedQos to handle AdditionalProperties
func (a *RequestedQos) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["5qi"]; found {
		err = json.Unmarshal(raw, &a.N5qi)
		if err != nil {
			return fmt.Errorf("error reading '5qi': %w", err)
		}
		delete(object, "5qi")
	}

	if raw, found := object["gbrDl"]; found {
		err = json.Unmarshal(raw, &a.GbrDl)
		if err != nil {
			return fmt.Errorf("error reading 'gbrDl': %w", err)
		}
		delete(object, "gbrDl")
	}

	if raw, found := object["gbrUl"]; found {
		err = json.Unmarshal(raw, &a.GbrUl)
		if err != nil {
			return fmt.Errorf("error reading 'gbrUl': %w", err)
		}
		delete(object, "gbrUl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestedQos to handle AdditionalProperties
func (a RequestedQos) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["5qi"], err = json.Marshal(a.N5qi)
	if err != nil {
		return nil, fmt.Errorf("error marshaling '5qi': %w", err)
	}

	if len(a.GbrDl) != 0 {
		object["gbrDl"], err = json.Marshal(a.GbrDl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gbrDl': %w", err)
		}
	}

	if len(a.GbrUl) != 0 {
		object["gbrUl"], err = json.Marshal(a.GbrUl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gbrUl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestedRuleData. Returns the specified
// element and whether it was found
func (a RequestedRuleData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestedRuleData
func (a *RequestedRuleData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestedRuleData to handle AdditionalProperties
func (a *RequestedRuleData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["refPccRuleIds"]; found {
		err = json.Unmarshal(raw, &a.RefPccRuleIds)
		if err != nil {
			return fmt.Errorf("error reading 'refPccRuleIds': %w", err)
		}
		delete(object, "refPccRuleIds")
	}

	if raw, found := object["reqData"]; found {
		err = json.Unmarshal(raw, &a.ReqData)
		if err != nil {
			return fmt.Errorf("error reading 'reqData': %w", err)
		}
		delete(object, "reqData")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestedRuleData to handle AdditionalProperties
func (a RequestedRuleData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["refPccRuleIds"], err = json.Marshal(a.RefPccRuleIds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refPccRuleIds': %w", err)
	}

	object["reqData"], err = json.Marshal(a.ReqData)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'reqData': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RequestedUsageData. Returns the specified
// element and whether it was found
func (a RequestedUsageData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RequestedUsageData
func (a *RequestedUsageData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RequestedUsageData to handle AdditionalProperties
func (a *RequestedUsageData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allUmIds"]; found {
		err = json.Unmarshal(raw, &a.AllUmIds)
		if err != nil {
			return fmt.Errorf("error reading 'allUmIds': %w", err)
		}
		delete(object, "allUmIds")
	}

	if raw, found := object["refUmIds"]; found {
		err = json.Unmarshal(raw, &a.RefUmIds)
		if err != nil {
			return fmt.Errorf("error reading 'refUmIds': %w", err)
		}
		delete(object, "refUmIds")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RequestedUsageData to handle AdditionalProperties
func (a RequestedUsageData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllUmIds != nil {
		object["allUmIds"], err = json.Marshal(a.AllUmIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allUmIds': %w", err)
		}
	}

	if len(a.RefUmIds) != 0 {
		object["refUmIds"], err = json.Marshal(a.RefUmIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'refUmIds': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RuleReport. Returns the specified
// element and whether it was found
func (a RuleReport) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RuleReport
func (a *RuleReport) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RuleReport to handle AdditionalProperties
func (a *RuleReport) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["contVers"]; found {
		err = json.Unmarshal(raw, &a.ContVers)
		if err != nil {
			return fmt.Errorf("error reading 'contVers': %w", err)
		}
		delete(object, "contVers")
	}

	if raw, found := object["failureCode"]; found {
		err = json.Unmarshal(raw, &a.FailureCode)
		if err != nil {
			return fmt.Errorf("error reading 'failureCode': %w", err)
		}
		delete(object, "failureCode")
	}

	if raw, found := object["finUnitAct"]; found {
		err = json.Unmarshal(raw, &a.FinUnitAct)
		if err != nil {
			return fmt.Errorf("error reading 'finUnitAct': %w", err)
		}
		delete(object, "finUnitAct")
	}

	if raw, found := object["pccRuleIds"]; found {
		err = json.Unmarshal(raw, &a.PccRuleIds)
		if err != nil {
			return fmt.Errorf("error reading 'pccRuleIds': %w", err)
		}
		delete(object, "pccRuleIds")
	}

	if raw, found := object["ranNasRelCauses"]; found {
		err = json.Unmarshal(raw, &a.RanNasRelCauses)
		if err != nil {
			return fmt.Errorf("error reading 'ranNasRelCauses': %w", err)
		}
		delete(object, "ranNasRelCauses")
	}

	if raw, found := object["ruleStatus"]; found {
		err = json.Unmarshal(raw, &a.RuleStatus)
		if err != nil {
			return fmt.Errorf("error reading 'ruleStatus': %w", err)
		}
		delete(object, "ruleStatus")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RuleReport to handle AdditionalProperties
func (a RuleReport) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.ContVers) != 0 {
		object["contVers"], err = json.Marshal(a.ContVers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'contVers': %w", err)
		}
	}

	if a.FailureCode != nil {
		object["failureCode"], err = json.Marshal(a.FailureCode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'failureCode': %w", err)
		}
	}

	if a.FinUnitAct != nil {
		object["finUnitAct"], err = json.Marshal(a.FinUnitAct)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'finUnitAct': %w", err)
		}
	}

	object["pccRuleIds"], err = json.Marshal(a.PccRuleIds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pccRuleIds': %w", err)
	}

	if len(a.RanNasRelCauses) != 0 {
		object["ranNasRelCauses"], err = json.Marshal(a.RanNasRelCauses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ranNasRelCauses': %w", err)
		}
	}

	object["ruleStatus"], err = json.Marshal(a.RuleStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'ruleStatus': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ServingNfIdentity. Returns the specified
// element and whether it was found
func (a ServingNfIdentity) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ServingNfIdentity
func (a *ServingNfIdentity) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ServingNfIdentity to handle AdditionalProperties
func (a *ServingNfIdentity) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["anGwAddr"]; found {
		err = json.Unmarshal(raw, &a.AnGwAddr)
		if err != nil {
			return fmt.Errorf("error reading 'anGwAddr': %w", err)
		}
		delete(object, "anGwAddr")
	}

	if raw, found := object["guami"]; found {
		err = json.Unmarshal(raw, &a.Guami)
		if err != nil {
			return fmt.Errorf("error reading 'guami': %w", err)
		}
		delete(object, "guami")
	}

	if raw, found := object["servNfInstId"]; found {
		err = json.Unmarshal(raw, &a.ServNfInstId)
		if err != nil {
			return fmt.Errorf("error reading 'servNfInstId': %w", err)
		}
		delete(object, "servNfInstId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ServingNfIdentity to handle AdditionalProperties
func (a ServingNfIdentity) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AnGwAddr != nil {
		object["anGwAddr"], err = json.Marshal(a.AnGwAddr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'anGwAddr': %w", err)
		}
	}

	if a.Guami != nil {
		object["guami"], err = json.Marshal(a.Guami)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'guami': %w", err)
		}
	}

	if a.ServNfInstId != nil {
		object["servNfInstId"], err = json.Marshal(a.ServNfInstId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servNfInstId': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SessionRule. Returns the specified
// element and whether it was found
func (a SessionRule) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SessionRule
func (a *SessionRule) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SessionRule to handle AdditionalProperties
func (a *SessionRule) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["authDefQos"]; found {
		err = json.Unmarshal(raw, &a.AuthDefQos)
		if err != nil {
			return fmt.Errorf("error reading 'authDefQos': %w", err)
		}
		delete(object, "authDefQos")
	}

	if raw, found := object["authSessAmbr"]; found {
		err = json.Unmarshal(raw, &a.AuthSessAmbr)
		if err != nil {
			return fmt.Errorf("error reading 'authSessAmbr': %w", err)
		}
		delete(object, "authSessAmbr")
	}

	if raw, found := object["refCondData"]; found {
		err = json.Unmarshal(raw, &a.RefCondData)
		if err != nil {
			return fmt.Errorf("error reading 'refCondData': %w", err)
		}
		delete(object, "refCondData")
	}

	if raw, found := object["refUmData"]; found {
		err = json.Unmarshal(raw, &a.RefUmData)
		if err != nil {
			return fmt.Errorf("error reading 'refUmData': %w", err)
		}
		delete(object, "refUmData")
	}

	if raw, found := object["refUmN3gData"]; found {
		err = json.Unmarshal(raw, &a.RefUmN3gData)
		if err != nil {
			return fmt.Errorf("error reading 'refUmN3gData': %w", err)
		}
		delete(object, "refUmN3gData")
	}

	if raw, found := object["sessRuleId"]; found {
		err = json.Unmarshal(raw, &a.SessRuleId)
		if err != nil {
			return fmt.Errorf("error reading 'sessRuleId': %w", err)
		}
		delete(object, "sessRuleId")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SessionRule to handle AdditionalProperties
func (a SessionRule) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AuthDefQos != nil {
		object["authDefQos"], err = json.Marshal(a.AuthDefQos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'authDefQos': %w", err)
		}
	}

	if a.AuthSessAmbr != nil {
		object["authSessAmbr"], err = json.Marshal(a.AuthSessAmbr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'authSessAmbr': %w", err)
		}
	}

	object["refCondData"], err = json.Marshal(a.RefCondData)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refCondData': %w", err)
	}

	object["refUmData"], err = json.Marshal(a.RefUmData)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refUmData': %w", err)
	}

	object["refUmN3gData"], err = json.Marshal(a.RefUmN3gData)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'refUmN3gData': %w", err)
	}

	object["sessRuleId"], err = json.Marshal(a.SessRuleId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'sessRuleId': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SessionRuleReport. Returns the specified
// element and whether it was found
func (a SessionRuleReport) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SessionRuleReport
func (a *SessionRuleReport) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SessionRuleReport to handle AdditionalProperties
func (a *SessionRuleReport) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["policyDecFailureReports"]; found {
		err = json.Unmarshal(raw, &a.PolicyDecFailureReports)
		if err != nil {
			return fmt.Errorf("error reading 'policyDecFailureReports': %w", err)
		}
		delete(object, "policyDecFailureReports")
	}

	if raw, found := object["ruleIds"]; found {
		err = json.Unmarshal(raw, &a.RuleIds)
		if err != nil {
			return fmt.Errorf("error reading 'ruleIds': %w", err)
		}
		delete(object, "ruleIds")
	}

	if raw, found := object["ruleStatus"]; found {
		err = json.Unmarshal(raw, &a.RuleStatus)
		if err != nil {
			return fmt.Errorf("error reading 'ruleStatus': %w", err)
		}
		delete(object, "ruleStatus")
	}

	if raw, found := object["sessRuleFailureCode"]; found {
		err = json.Unmarshal(raw, &a.SessRuleFailureCode)
		if err != nil {
			return fmt.Errorf("error reading 'sessRuleFailureCode': %w", err)
		}
		delete(object, "sessRuleFailureCode")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SessionRuleReport to handle AdditionalProperties
func (a SessionRuleReport) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.PolicyDecFailureReports) != 0 {
		object["policyDecFailureReports"], err = json.Marshal(a.PolicyDecFailureReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'policyDecFailureReports': %w", err)
		}
	}

	object["ruleIds"], err = json.Marshal(a.RuleIds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'ruleIds': %w", err)
	}

	object["ruleStatus"], err = json.Marshal(a.RuleStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'ruleStatus': %w", err)
	}

	if a.SessRuleFailureCode != nil {
		object["sessRuleFailureCode"], err = json.Marshal(a.SessRuleFailureCode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sessRuleFailureCode': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyContextData. Returns the specified
// element and whether it was found
func (a SmPolicyContextData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyContextData
func (a *SmPolicyContextData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyContextData to handle AdditionalProperties
func (a *SmPolicyContextData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["3gppPsDataOffStatus"]; found {
		err = json.Unmarshal(raw, &a.N3gppPsDataOffStatus)
		if err != nil {
			return fmt.Errorf("error reading '3gppPsDataOffStatus': %w", err)
		}
		delete(object, "3gppPsDataOffStatus")
	}

	if raw, found := object["accNetChId"]; found {
		err = json.Unmarshal(raw, &a.AccNetChId)
		if err != nil {
			return fmt.Errorf("error reading 'accNetChId': %w", err)
		}
		delete(object, "accNetChId")
	}

	if raw, found := object["accessType"]; found {
		err = json.Unmarshal(raw, &a.AccessType)
		if err != nil {
			return fmt.Errorf("error reading 'accessType': %w", err)
		}
		delete(object, "accessType")
	}

	if raw, found := object["addAccessInfo"]; found {
		err = json.Unmarshal(raw, &a.AddAccessInfo)
		if err != nil {
			return fmt.Errorf("error reading 'addAccessInfo': %w", err)
		}
		delete(object, "addAccessInfo")
	}

	if raw, found := object["atsssCapab"]; found {
		err = json.Unmarshal(raw, &a.AtsssCapab)
		if err != nil {
			return fmt.Errorf("error reading 'atsssCapab': %w", err)
		}
		delete(object, "atsssCapab")
	}

	if raw, found := object["authProfIndex"]; found {
		err = json.Unmarshal(raw, &a.AuthProfIndex)
		if err != nil {
			return fmt.Errorf("error reading 'authProfIndex': %w", err)
		}
		delete(object, "authProfIndex")
	}

	if raw, found := object["chargEntityAddr"]; found {
		err = json.Unmarshal(raw, &a.ChargEntityAddr)
		if err != nil {
			return fmt.Errorf("error reading 'chargEntityAddr': %w", err)
		}
		delete(object, "chargEntityAddr")
	}

	if raw, found := object["chargingcharacteristics"]; found {
		err = json.Unmarshal(raw, &a.Chargingcharacteristics)
		if err != nil {
			return fmt.Errorf("error reading 'chargingcharacteristics': %w", err)
		}
		delete(object, "chargingcharacteristics")
	}

	if raw, found := object["dnn"]; found {
		err = json.Unmarshal(raw, &a.Dnn)
		if err != nil {
			return fmt.Errorf("error reading 'dnn': %w", err)
		}
		delete(object, "dnn")
	}

	if raw, found := object["dnnSelMode"]; found {
		err = json.Unmarshal(raw, &a.DnnSelMode)
		if err != nil {
			return fmt.Errorf("error reading 'dnnSelMode': %w", err)
		}
		delete(object, "dnnSelMode")
	}

	if raw, found := object["gpsi"]; found {
		err = json.Unmarshal(raw, &a.Gpsi)
		if err != nil {
			return fmt.Errorf("error reading 'gpsi': %w", err)
		}
		delete(object, "gpsi")
	}

	if raw, found := object["interGrpIds"]; found {
		err = json.Unmarshal(raw, &a.InterGrpIds)
		if err != nil {
			return fmt.Errorf("error reading 'interGrpIds': %w", err)
		}
		delete(object, "interGrpIds")
	}

	if raw, found := object["invalidSupi"]; found {
		err = json.Unmarshal(raw, &a.InvalidSupi)
		if err != nil {
			return fmt.Errorf("error reading 'invalidSupi': %w", err)
		}
		delete(object, "invalidSupi")
	}

	if raw, found := object["ipDomain"]; found {
		err = json.Unmarshal(raw, &a.IpDomain)
		if err != nil {
			return fmt.Errorf("error reading 'ipDomain': %w", err)
		}
		delete(object, "ipDomain")
	}

	if raw, found := object["ipv4Address"]; found {
		err = json.Unmarshal(raw, &a.Ipv4Address)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4Address': %w", err)
		}
		delete(object, "ipv4Address")
	}

	if raw, found := object["ipv4FrameRouteList"]; found {
		err = json.Unmarshal(raw, &a.Ipv4FrameRouteList)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4FrameRouteList': %w", err)
		}
		delete(object, "ipv4FrameRouteList")
	}

	if raw, found := object["ipv6AddressPrefix"]; found {
		err = json.Unmarshal(raw, &a.Ipv6AddressPrefix)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6AddressPrefix': %w", err)
		}
		delete(object, "ipv6AddressPrefix")
	}

	if raw, found := object["ipv6FrameRouteList"]; found {
		err = json.Unmarshal(raw, &a.Ipv6FrameRouteList)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6FrameRouteList': %w", err)
		}
		delete(object, "ipv6FrameRouteList")
	}

	if raw, found := object["maPduInd"]; found {
		err = json.Unmarshal(raw, &a.MaPduInd)
		if err != nil {
			return fmt.Errorf("error reading 'maPduInd': %w", err)
		}
		delete(object, "maPduInd")
	}

	if raw, found := object["notificationUri"]; found {
		err = json.Unmarshal(raw, &a.NotificationUri)
		if err != nil {
			return fmt.Errorf("error reading 'notificationUri': %w", err)
		}
		delete(object, "notificationUri")
	}

	if raw, found := object["numOfPackFilter"]; found {
		err = json.Unmarshal(raw, &a.NumOfPackFilter)
		if err != nil {
			return fmt.Errorf("error reading 'numOfPackFilter': %w", err)
		}
		delete(object, "numOfPackFilter")
	}

	if raw, found := object["offline"]; found {
		err = json.Unmarshal(raw, &a.Offline)
		if err != nil {
			return fmt.Errorf("error reading 'offline': %w", err)
		}
		delete(object, "offline")
	}

	if raw, found := object["online"]; found {
		err = json.Unmarshal(raw, &a.Online)
		if err != nil {
			return fmt.Errorf("error reading 'online': %w", err)
		}
		delete(object, "online")
	}

	if raw, found := object["pduSessionId"]; found {
		err = json.Unmarshal(raw, &a.PduSessionId)
		if err != nil {
			return fmt.Errorf("error reading 'pduSessionId': %w", err)
		}
		delete(object, "pduSessionId")
	}

	if raw, found := object["pduSessionType"]; found {
		err = json.Unmarshal(raw, &a.PduSessionType)
		if err != nil {
			return fmt.Errorf("error reading 'pduSessionType': %w", err)
		}
		delete(object, "pduSessionType")
	}

	if raw, found := object["pei"]; found {
		err = json.Unmarshal(raw, &a.Pei)
		if err != nil {
			return fmt.Errorf("error reading 'pei': %w", err)
		}
		delete(object, "pei")
	}

	if raw, found := object["qosFlowUsage"]; found {
		err = json.Unmarshal(raw, &a.QosFlowUsage)
		if err != nil {
			return fmt.Errorf("error reading 'qosFlowUsage': %w", err)
		}
		delete(object, "qosFlowUsage")
	}

	if raw, found := object["ratType"]; found {
		err = json.Unmarshal(raw, &a.RatType)
		if err != nil {
			return fmt.Errorf("error reading 'ratType': %w", err)
		}
		delete(object, "ratType")
	}

	if raw, found := object["recoveryTime"]; found {
		err = json.Unmarshal(raw, &a.RecoveryTime)
		if err != nil {
			return fmt.Errorf("error reading 'recoveryTime': %w", err)
		}
		delete(object, "recoveryTime")
	}

	if raw, found := object["refQosIndication"]; found {
		err = json.Unmarshal(raw, &a.RefQosIndication)
		if err != nil {
			return fmt.Errorf("error reading 'refQosIndication': %w", err)
		}
		delete(object, "refQosIndication")
	}

	if raw, found := object["servNfId"]; found {
		err = json.Unmarshal(raw, &a.ServNfId)
		if err != nil {
			return fmt.Errorf("error reading 'servNfId': %w", err)
		}
		delete(object, "servNfId")
	}

	if raw, found := object["servingNetwork"]; found {
		err = json.Unmarshal(raw, &a.ServingNetwork)
		if err != nil {
			return fmt.Errorf("error reading 'servingNetwork': %w", err)
		}
		delete(object, "servingNetwork")
	}

	if raw, found := object["sliceInfo"]; found {
		err = json.Unmarshal(raw, &a.SliceInfo)
		if err != nil {
			return fmt.Errorf("error reading 'sliceInfo': %w", err)
		}
		delete(object, "sliceInfo")
	}

	if raw, found := object["smfId"]; found {
		err = json.Unmarshal(raw, &a.SmfId)
		if err != nil {
			return fmt.Errorf("error reading 'smfId': %w", err)
		}
		delete(object, "smfId")
	}

	if raw, found := object["subsDefQos"]; found {
		err = json.Unmarshal(raw, &a.SubsDefQos)
		if err != nil {
			return fmt.Errorf("error reading 'subsDefQos': %w", err)
		}
		delete(object, "subsDefQos")
	}

	if raw, found := object["subsSessAmbr"]; found {
		err = json.Unmarshal(raw, &a.SubsSessAmbr)
		if err != nil {
			return fmt.Errorf("error reading 'subsSessAmbr': %w", err)
		}
		delete(object, "subsSessAmbr")
	}

	if raw, found := object["supi"]; found {
		err = json.Unmarshal(raw, &a.Supi)
		if err != nil {
			return fmt.Errorf("error reading 'supi': %w", err)
		}
		delete(object, "supi")
	}

	if raw, found := object["suppFeat"]; found {
		err = json.Unmarshal(raw, &a.SuppFeat)
		if err != nil {
			return fmt.Errorf("error reading 'suppFeat': %w", err)
		}
		delete(object, "suppFeat")
	}

	if raw, found := object["traceReq"]; found {
		err = json.Unmarshal(raw, &a.TraceReq)
		if err != nil {
			return fmt.Errorf("error reading 'traceReq': %w", err)
		}
		delete(object, "traceReq")
	}

	if raw, found := object["ueTimeZone"]; found {
		err = json.Unmarshal(raw, &a.UeTimeZone)
		if err != nil {
			return fmt.Errorf("error reading 'ueTimeZone': %w", err)
		}
		delete(object, "ueTimeZone")
	}

	if raw, found := object["userLocationInfo"]; found {
		err = json.Unmarshal(raw, &a.UserLocationInfo)
		if err != nil {
			return fmt.Errorf("error reading 'userLocationInfo': %w", err)
		}
		delete(object, "userLocationInfo")
	}

	if raw, found := object["vplmnQos"]; found {
		err = json.Unmarshal(raw, &a.VplmnQos)
		if err != nil {
			return fmt.Errorf("error reading 'vplmnQos': %w", err)
		}
		delete(object, "vplmnQos")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyContextData to handle AdditionalProperties
func (a SmPolicyContextData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.N3gppPsDataOffStatus != nil {
		object["3gppPsDataOffStatus"], err = json.Marshal(a.N3gppPsDataOffStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '3gppPsDataOffStatus': %w", err)
		}
	}

	if a.AccNetChId != nil {
		object["accNetChId"], err = json.Marshal(a.AccNetChId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accNetChId': %w", err)
		}
	}

	if len(a.AccessType) != 0 {
		object["accessType"], err = json.Marshal(a.AccessType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accessType': %w", err)
		}
	}

	if a.AddAccessInfo != nil {
		object["addAccessInfo"], err = json.Marshal(a.AddAccessInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'addAccessInfo': %w", err)
		}
	}

	if a.AtsssCapab != nil {
		object["atsssCapab"], err = json.Marshal(a.AtsssCapab)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'atsssCapab': %w", err)
		}
	}

	if a.AuthProfIndex != nil {
		object["authProfIndex"], err = json.Marshal(a.AuthProfIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'authProfIndex': %w", err)
		}
	}

	if a.ChargEntityAddr != nil {
		object["chargEntityAddr"], err = json.Marshal(a.ChargEntityAddr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'chargEntityAddr': %w", err)
		}
	}

	if a.Chargingcharacteristics != nil {
		object["chargingcharacteristics"], err = json.Marshal(a.Chargingcharacteristics)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'chargingcharacteristics': %w", err)
		}
	}

	object["dnn"], err = json.Marshal(a.Dnn)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'dnn': %w", err)
	}

	if a.DnnSelMode != nil {
		object["dnnSelMode"], err = json.Marshal(a.DnnSelMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dnnSelMode': %w", err)
		}
	}

	if len(a.Gpsi) != 0 {
		object["gpsi"], err = json.Marshal(a.Gpsi)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gpsi': %w", err)
		}
	}

	if len(a.InterGrpIds) != 0 {
		object["interGrpIds"], err = json.Marshal(a.InterGrpIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'interGrpIds': %w", err)
		}
	}

	if a.InvalidSupi != nil {
		object["invalidSupi"], err = json.Marshal(a.InvalidSupi)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'invalidSupi': %w", err)
		}
	}

	if a.IpDomain != nil {
		object["ipDomain"], err = json.Marshal(a.IpDomain)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipDomain': %w", err)
		}
	}

	if len(a.Ipv4Address) != 0 {
		object["ipv4Address"], err = json.Marshal(a.Ipv4Address)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4Address': %w", err)
		}
	}

	if len(a.Ipv4FrameRouteList) != 0 {
		object["ipv4FrameRouteList"], err = json.Marshal(a.Ipv4FrameRouteList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4FrameRouteList': %w", err)
		}
	}

	if a.Ipv6AddressPrefix != nil {
		object["ipv6AddressPrefix"], err = json.Marshal(a.Ipv6AddressPrefix)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6AddressPrefix': %w", err)
		}
	}

	if len(a.Ipv6FrameRouteList) != 0 {
		object["ipv6FrameRouteList"], err = json.Marshal(a.Ipv6FrameRouteList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6FrameRouteList': %w", err)
		}
	}

	if a.MaPduInd != nil {
		object["maPduInd"], err = json.Marshal(a.MaPduInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'maPduInd': %w", err)
		}
	}

	object["notificationUri"], err = json.Marshal(a.NotificationUri)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'notificationUri': %w", err)
	}

	if a.NumOfPackFilter != nil {
		object["numOfPackFilter"], err = json.Marshal(a.NumOfPackFilter)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'numOfPackFilter': %w", err)
		}
	}

	if a.Offline != nil {
		object["offline"], err = json.Marshal(a.Offline)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'offline': %w", err)
		}
	}

	if a.Online != nil {
		object["online"], err = json.Marshal(a.Online)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'online': %w", err)
		}
	}

	object["pduSessionId"], err = json.Marshal(a.PduSessionId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pduSessionId': %w", err)
	}

	object["pduSessionType"], err = json.Marshal(a.PduSessionType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pduSessionType': %w", err)
	}

	if len(a.Pei) != 0 {
		object["pei"], err = json.Marshal(a.Pei)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pei': %w", err)
		}
	}

	if a.QosFlowUsage != nil {
		object["qosFlowUsage"], err = json.Marshal(a.QosFlowUsage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'qosFlowUsage': %w", err)
		}
	}

	if a.RatType != nil {
		object["ratType"], err = json.Marshal(a.RatType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ratType': %w", err)
		}
	}

	if a.RecoveryTime != nil {
		object["recoveryTime"], err = json.Marshal(a.RecoveryTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'recoveryTime': %w", err)
		}
	}

	if a.RefQosIndication != nil {
		object["refQosIndication"], err = json.Marshal(a.RefQosIndication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'refQosIndication': %w", err)
		}
	}

	if a.ServNfId != nil {
		object["servNfId"], err = json.Marshal(a.ServNfId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servNfId': %w", err)
		}
	}

	if a.ServingNetwork != nil {
		object["servingNetwork"], err = json.Marshal(a.ServingNetwork)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingNetwork': %w", err)
		}
	}

	object["sliceInfo"], err = json.Marshal(a.SliceInfo)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'sliceInfo': %w", err)
	}

	if a.SmfId != nil {
		object["smfId"], err = json.Marshal(a.SmfId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'smfId': %w", err)
		}
	}

	if a.SubsDefQos != nil {
		object["subsDefQos"], err = json.Marshal(a.SubsDefQos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subsDefQos': %w", err)
		}
	}

	if a.SubsSessAmbr != nil {
		object["subsSessAmbr"], err = json.Marshal(a.SubsSessAmbr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subsSessAmbr': %w", err)
		}
	}

	object["supi"], err = json.Marshal(a.Supi)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'supi': %w", err)
	}

	if a.SuppFeat != nil {
		object["suppFeat"], err = json.Marshal(a.SuppFeat)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'suppFeat': %w", err)
		}
	}

	object["traceReq"], err = json.Marshal(a.TraceReq)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'traceReq': %w", err)
	}

	if a.UeTimeZone != nil {
		object["ueTimeZone"], err = json.Marshal(a.UeTimeZone)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ueTimeZone': %w", err)
		}
	}

	if a.UserLocationInfo != nil {
		object["userLocationInfo"], err = json.Marshal(a.UserLocationInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'userLocationInfo': %w", err)
		}
	}

	if a.VplmnQos != nil {
		object["vplmnQos"], err = json.Marshal(a.VplmnQos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vplmnQos': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyControl. Returns the specified
// element and whether it was found
func (a SmPolicyControl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyControl
func (a *SmPolicyControl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyControl to handle AdditionalProperties
func (a *SmPolicyControl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["context"]; found {
		err = json.Unmarshal(raw, &a.Context)
		if err != nil {
			return fmt.Errorf("error reading 'context': %w", err)
		}
		delete(object, "context")
	}

	if raw, found := object["policy"]; found {
		err = json.Unmarshal(raw, &a.Policy)
		if err != nil {
			return fmt.Errorf("error reading 'policy': %w", err)
		}
		delete(object, "policy")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyControl to handle AdditionalProperties
func (a SmPolicyControl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["context"], err = json.Marshal(a.Context)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'context': %w", err)
	}

	object["policy"], err = json.Marshal(a.Policy)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'policy': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyDecision. Returns the specified
// element and whether it was found
func (a SmPolicyDecision) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDecision
func (a *SmPolicyDecision) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDecision to handle AdditionalProperties
func (a *SmPolicyDecision) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["chargingInfo"]; found {
		err = json.Unmarshal(raw, &a.ChargingInfo)
		if err != nil {
			return fmt.Errorf("error reading 'chargingInfo': %w", err)
		}
		delete(object, "chargingInfo")
	}

	if raw, found := object["chgDecs"]; found {
		err = json.Unmarshal(raw, &a.ChgDecs)
		if err != nil {
			return fmt.Errorf("error reading 'chgDecs': %w", err)
		}
		delete(object, "chgDecs")
	}

	if raw, found := object["conds"]; found {
		err = json.Unmarshal(raw, &a.Conds)
		if err != nil {
			return fmt.Errorf("error reading 'conds': %w", err)
		}
		delete(object, "conds")
	}

	if raw, found := object["ipv4Index"]; found {
		err = json.Unmarshal(raw, &a.Ipv4Index)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4Index': %w", err)
		}
		delete(object, "ipv4Index")
	}

	if raw, found := object["ipv6Index"]; found {
		err = json.Unmarshal(raw, &a.Ipv6Index)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6Index': %w", err)
		}
		delete(object, "ipv6Index")
	}

	if raw, found := object["lastReqRuleData"]; found {
		err = json.Unmarshal(raw, &a.LastReqRuleData)
		if err != nil {
			return fmt.Errorf("error reading 'lastReqRuleData': %w", err)
		}
		delete(object, "lastReqRuleData")
	}

	if raw, found := object["lastReqUsageData"]; found {
		err = json.Unmarshal(raw, &a.LastReqUsageData)
		if err != nil {
			return fmt.Errorf("error reading 'lastReqUsageData': %w", err)
		}
		delete(object, "lastReqUsageData")
	}

	if raw, found := object["offline"]; found {
		err = json.Unmarshal(raw, &a.Offline)
		if err != nil {
			return fmt.Errorf("error reading 'offline': %w", err)
		}
		delete(object, "offline")
	}

	if raw, found := object["online"]; found {
		err = json.Unmarshal(raw, &a.Online)
		if err != nil {
			return fmt.Errorf("error reading 'online': %w", err)
		}
		delete(object, "online")
	}

	if raw, found := object["pccRules"]; found {
		err = json.Unmarshal(raw, &a.PccRules)
		if err != nil {
			return fmt.Errorf("error reading 'pccRules': %w", err)
		}
		delete(object, "pccRules")
	}

	if raw, found := object["pcscfRestIndication"]; found {
		err = json.Unmarshal(raw, &a.PcscfRestIndication)
		if err != nil {
			return fmt.Errorf("error reading 'pcscfRestIndication': %w", err)
		}
		delete(object, "pcscfRestIndication")
	}

	if raw, found := object["policyCtrlReqTriggers"]; found {
		err = json.Unmarshal(raw, &a.PolicyCtrlReqTriggers)
		if err != nil {
			return fmt.Errorf("error reading 'policyCtrlReqTriggers': %w", err)
		}
		delete(object, "policyCtrlReqTriggers")
	}

	if raw, found := object["praInfos"]; found {
		err = json.Unmarshal(raw, &a.PraInfos)
		if err != nil {
			return fmt.Errorf("error reading 'praInfos': %w", err)
		}
		delete(object, "praInfos")
	}

	if raw, found := object["qosChars"]; found {
		err = json.Unmarshal(raw, &a.QosChars)
		if err != nil {
			return fmt.Errorf("error reading 'qosChars': %w", err)
		}
		delete(object, "qosChars")
	}

	if raw, found := object["qosDecs"]; found {
		err = json.Unmarshal(raw, &a.QosDecs)
		if err != nil {
			return fmt.Errorf("error reading 'qosDecs': %w", err)
		}
		delete(object, "qosDecs")
	}

	if raw, found := object["qosFlowUsage"]; found {
		err = json.Unmarshal(raw, &a.QosFlowUsage)
		if err != nil {
			return fmt.Errorf("error reading 'qosFlowUsage': %w", err)
		}
		delete(object, "qosFlowUsage")
	}

	if raw, found := object["qosMonDecs"]; found {
		err = json.Unmarshal(raw, &a.QosMonDecs)
		if err != nil {
			return fmt.Errorf("error reading 'qosMonDecs': %w", err)
		}
		delete(object, "qosMonDecs")
	}

	if raw, found := object["redSessIndication"]; found {
		err = json.Unmarshal(raw, &a.RedSessIndication)
		if err != nil {
			return fmt.Errorf("error reading 'redSessIndication': %w", err)
		}
		delete(object, "redSessIndication")
	}

	if raw, found := object["reflectiveQoSTimer"]; found {
		err = json.Unmarshal(raw, &a.ReflectiveQoSTimer)
		if err != nil {
			return fmt.Errorf("error reading 'reflectiveQoSTimer': %w", err)
		}
		delete(object, "reflectiveQoSTimer")
	}

	if raw, found := object["relCause"]; found {
		err = json.Unmarshal(raw, &a.RelCause)
		if err != nil {
			return fmt.Errorf("error reading 'relCause': %w", err)
		}
		delete(object, "relCause")
	}

	if raw, found := object["revalidationTime"]; found {
		err = json.Unmarshal(raw, &a.RevalidationTime)
		if err != nil {
			return fmt.Errorf("error reading 'revalidationTime': %w", err)
		}
		delete(object, "revalidationTime")
	}

	if raw, found := object["sessRules"]; found {
		err = json.Unmarshal(raw, &a.SessRules)
		if err != nil {
			return fmt.Errorf("error reading 'sessRules': %w", err)
		}
		delete(object, "sessRules")
	}

	if raw, found := object["suppFeat"]; found {
		err = json.Unmarshal(raw, &a.SuppFeat)
		if err != nil {
			return fmt.Errorf("error reading 'suppFeat': %w", err)
		}
		delete(object, "suppFeat")
	}

	if raw, found := object["traffContDecs"]; found {
		err = json.Unmarshal(raw, &a.TraffContDecs)
		if err != nil {
			return fmt.Errorf("error reading 'traffContDecs': %w", err)
		}
		delete(object, "traffContDecs")
	}

	if raw, found := object["tsnBridgeManCont"]; found {
		err = json.Unmarshal(raw, &a.TsnBridgeManCont)
		if err != nil {
			return fmt.Errorf("error reading 'tsnBridgeManCont': %w", err)
		}
		delete(object, "tsnBridgeManCont")
	}

	if raw, found := object["tsnPortManContDstt"]; found {
		err = json.Unmarshal(raw, &a.TsnPortManContDstt)
		if err != nil {
			return fmt.Errorf("error reading 'tsnPortManContDstt': %w", err)
		}
		delete(object, "tsnPortManContDstt")
	}

	if raw, found := object["tsnPortManContNwtts"]; found {
		err = json.Unmarshal(raw, &a.TsnPortManContNwtts)
		if err != nil {
			return fmt.Errorf("error reading 'tsnPortManContNwtts': %w", err)
		}
		delete(object, "tsnPortManContNwtts")
	}

	if raw, found := object["umDecs"]; found {
		err = json.Unmarshal(raw, &a.UmDecs)
		if err != nil {
			return fmt.Errorf("error reading 'umDecs': %w", err)
		}
		delete(object, "umDecs")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDecision to handle AdditionalProperties
func (a SmPolicyDecision) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ChargingInfo != nil {
		object["chargingInfo"], err = json.Marshal(a.ChargingInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'chargingInfo': %w", err)
		}
	}

	object["chgDecs"], err = json.Marshal(a.ChgDecs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'chgDecs': %w", err)
	}

	object["conds"], err = json.Marshal(a.Conds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'conds': %w", err)
	}

	if a.Ipv4Index != nil {
		object["ipv4Index"], err = json.Marshal(a.Ipv4Index)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4Index': %w", err)
		}
	}

	if a.Ipv6Index != nil {
		object["ipv6Index"], err = json.Marshal(a.Ipv6Index)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6Index': %w", err)
		}
	}

	if len(a.LastReqRuleData) != 0 {
		object["lastReqRuleData"], err = json.Marshal(a.LastReqRuleData)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lastReqRuleData': %w", err)
		}
	}

	if a.LastReqUsageData != nil {
		object["lastReqUsageData"], err = json.Marshal(a.LastReqUsageData)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lastReqUsageData': %w", err)
		}
	}

	if a.Offline != nil {
		object["offline"], err = json.Marshal(a.Offline)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'offline': %w", err)
		}
	}

	if a.Online != nil {
		object["online"], err = json.Marshal(a.Online)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'online': %w", err)
		}
	}

	object["pccRules"], err = json.Marshal(a.PccRules)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'pccRules': %w", err)
	}

	if a.PcscfRestIndication != nil {
		object["pcscfRestIndication"], err = json.Marshal(a.PcscfRestIndication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pcscfRestIndication': %w", err)
		}
	}

	object["policyCtrlReqTriggers"], err = json.Marshal(a.PolicyCtrlReqTriggers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'policyCtrlReqTriggers': %w", err)
	}

	object["praInfos"], err = json.Marshal(a.PraInfos)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'praInfos': %w", err)
	}

	if a.QosChars != nil {
		object["qosChars"], err = json.Marshal(a.QosChars)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'qosChars': %w", err)
		}
	}

	if a.QosDecs != nil {
		object["qosDecs"], err = json.Marshal(a.QosDecs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'qosDecs': %w", err)
		}
	}

	if a.QosFlowUsage != nil {
		object["qosFlowUsage"], err = json.Marshal(a.QosFlowUsage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'qosFlowUsage': %w", err)
		}
	}

	object["qosMonDecs"], err = json.Marshal(a.QosMonDecs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'qosMonDecs': %w", err)
	}

	if a.RedSessIndication != nil {
		object["redSessIndication"], err = json.Marshal(a.RedSessIndication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'redSessIndication': %w", err)
		}
	}

	if a.ReflectiveQoSTimer != nil {
		object["reflectiveQoSTimer"], err = json.Marshal(a.ReflectiveQoSTimer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reflectiveQoSTimer': %w", err)
		}
	}

	if a.RelCause != nil {
		object["relCause"], err = json.Marshal(a.RelCause)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relCause': %w", err)
		}
	}

	if a.RevalidationTime != nil {
		object["revalidationTime"], err = json.Marshal(a.RevalidationTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'revalidationTime': %w", err)
		}
	}

	if a.SessRules != nil {
		object["sessRules"], err = json.Marshal(a.SessRules)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sessRules': %w", err)
		}
	}

	if a.SuppFeat != nil {
		object["suppFeat"], err = json.Marshal(a.SuppFeat)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'suppFeat': %w", err)
		}
	}

	if a.TraffContDecs != nil {
		object["traffContDecs"], err = json.Marshal(a.TraffContDecs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'traffContDecs': %w", err)
		}
	}

	if a.TsnBridgeManCont != nil {
		object["tsnBridgeManCont"], err = json.Marshal(a.TsnBridgeManCont)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsnBridgeManCont': %w", err)
		}
	}

	if a.TsnPortManContDstt != nil {
		object["tsnPortManContDstt"], err = json.Marshal(a.TsnPortManContDstt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsnPortManContDstt': %w", err)
		}
	}

	if len(a.TsnPortManContNwtts) != 0 {
		object["tsnPortManContNwtts"], err = json.Marshal(a.TsnPortManContNwtts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsnPortManContNwtts': %w", err)
		}
	}

	object["umDecs"], err = json.Marshal(a.UmDecs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'umDecs': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyDeleteData. Returns the specified
// element and whether it was found
func (a SmPolicyDeleteData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyDeleteData
func (a *SmPolicyDeleteData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyDeleteData to handle AdditionalProperties
func (a *SmPolicyDeleteData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accuUsageReports"]; found {
		err = json.Unmarshal(raw, &a.AccuUsageReports)
		if err != nil {
			return fmt.Errorf("error reading 'accuUsageReports': %w", err)
		}
		delete(object, "accuUsageReports")
	}

	if raw, found := object["pduSessRelCause"]; found {
		err = json.Unmarshal(raw, &a.PduSessRelCause)
		if err != nil {
			return fmt.Errorf("error reading 'pduSessRelCause': %w", err)
		}
		delete(object, "pduSessRelCause")
	}

	if raw, found := object["ranNasRelCauses"]; found {
		err = json.Unmarshal(raw, &a.RanNasRelCauses)
		if err != nil {
			return fmt.Errorf("error reading 'ranNasRelCauses': %w", err)
		}
		delete(object, "ranNasRelCauses")
	}

	if raw, found := object["servingNetwork"]; found {
		err = json.Unmarshal(raw, &a.ServingNetwork)
		if err != nil {
			return fmt.Errorf("error reading 'servingNetwork': %w", err)
		}
		delete(object, "servingNetwork")
	}

	if raw, found := object["ueTimeZone"]; found {
		err = json.Unmarshal(raw, &a.UeTimeZone)
		if err != nil {
			return fmt.Errorf("error reading 'ueTimeZone': %w", err)
		}
		delete(object, "ueTimeZone")
	}

	if raw, found := object["userLocationInfo"]; found {
		err = json.Unmarshal(raw, &a.UserLocationInfo)
		if err != nil {
			return fmt.Errorf("error reading 'userLocationInfo': %w", err)
		}
		delete(object, "userLocationInfo")
	}

	if raw, found := object["userLocationInfoTime"]; found {
		err = json.Unmarshal(raw, &a.UserLocationInfoTime)
		if err != nil {
			return fmt.Errorf("error reading 'userLocationInfoTime': %w", err)
		}
		delete(object, "userLocationInfoTime")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyDeleteData to handle AdditionalProperties
func (a SmPolicyDeleteData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AccuUsageReports) != 0 {
		object["accuUsageReports"], err = json.Marshal(a.AccuUsageReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accuUsageReports': %w", err)
		}
	}

	if a.PduSessRelCause != nil {
		object["pduSessRelCause"], err = json.Marshal(a.PduSessRelCause)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pduSessRelCause': %w", err)
		}
	}

	if len(a.RanNasRelCauses) != 0 {
		object["ranNasRelCauses"], err = json.Marshal(a.RanNasRelCauses)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ranNasRelCauses': %w", err)
		}
	}

	if a.ServingNetwork != nil {
		object["servingNetwork"], err = json.Marshal(a.ServingNetwork)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingNetwork': %w", err)
		}
	}

	if a.UeTimeZone != nil {
		object["ueTimeZone"], err = json.Marshal(a.UeTimeZone)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ueTimeZone': %w", err)
		}
	}

	if a.UserLocationInfo != nil {
		object["userLocationInfo"], err = json.Marshal(a.UserLocationInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'userLocationInfo': %w", err)
		}
	}

	if a.UserLocationInfoTime != nil {
		object["userLocationInfoTime"], err = json.Marshal(a.UserLocationInfoTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'userLocationInfoTime': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyNotification. Returns the specified
// element and whether it was found
func (a SmPolicyNotification) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyNotification
func (a *SmPolicyNotification) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyNotification to handle AdditionalProperties
func (a *SmPolicyNotification) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["resourceUri"]; found {
		err = json.Unmarshal(raw, &a.ResourceUri)
		if err != nil {
			return fmt.Errorf("error reading 'resourceUri': %w", err)
		}
		delete(object, "resourceUri")
	}

	if raw, found := object["smPolicyDecision"]; found {
		err = json.Unmarshal(raw, &a.SmPolicyDecision)
		if err != nil {
			return fmt.Errorf("error reading 'smPolicyDecision': %w", err)
		}
		delete(object, "smPolicyDecision")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyNotification to handle AdditionalProperties
func (a SmPolicyNotification) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ResourceUri != nil {
		object["resourceUri"], err = json.Marshal(a.ResourceUri)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'resourceUri': %w", err)
		}
	}

	if a.SmPolicyDecision != nil {
		object["smPolicyDecision"], err = json.Marshal(a.SmPolicyDecision)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'smPolicyDecision': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SmPolicyUpdateContextData. Returns the specified
// element and whether it was found
func (a SmPolicyUpdateContextData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SmPolicyUpdateContextData
func (a *SmPolicyUpdateContextData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SmPolicyUpdateContextData to handle AdditionalProperties
func (a *SmPolicyUpdateContextData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["3gppPsDataOffStatus"]; found {
		err = json.Unmarshal(raw, &a.N3gppPsDataOffStatus)
		if err != nil {
			return fmt.Errorf("error reading '3gppPsDataOffStatus': %w", err)
		}
		delete(object, "3gppPsDataOffStatus")
	}

	if raw, found := object["accNetChIds"]; found {
		err = json.Unmarshal(raw, &a.AccNetChIds)
		if err != nil {
			return fmt.Errorf("error reading 'accNetChIds': %w", err)
		}
		delete(object, "accNetChIds")
	}

	if raw, found := object["accessType"]; found {
		err = json.Unmarshal(raw, &a.AccessType)
		if err != nil {
			return fmt.Errorf("error reading 'accessType': %w", err)
		}
		delete(object, "accessType")
	}

	if raw, found := object["accuUsageReports"]; found {
		err = json.Unmarshal(raw, &a.AccuUsageReports)
		if err != nil {
			return fmt.Errorf("error reading 'accuUsageReports': %w", err)
		}
		delete(object, "accuUsageReports")
	}

	if raw, found := object["addAccessInfo"]; found {
		err = json.Unmarshal(raw, &a.AddAccessInfo)
		if err != nil {
			return fmt.Errorf("error reading 'addAccessInfo': %w", err)
		}
		delete(object, "addAccessInfo")
	}

	if raw, found := object["addIpv6AddrPrefixes"]; found {
		err = json.Unmarshal(raw, &a.AddIpv6AddrPrefixes)
		if err != nil {
			return fmt.Errorf("error reading 'addIpv6AddrPrefixes': %w", err)
		}
		delete(object, "addIpv6AddrPrefixes")
	}

	if raw, found := object["addRelIpv6AddrPrefixes"]; found {
		err = json.Unmarshal(raw, &a.AddRelIpv6AddrPrefixes)
		if err != nil {
			return fmt.Errorf("error reading 'addRelIpv6AddrPrefixes': %w", err)
		}
		delete(object, "addRelIpv6AddrPrefixes")
	}

	if raw, found := object["appDetectionInfos"]; found {
		err = json.Unmarshal(raw, &a.AppDetectionInfos)
		if err != nil {
			return fmt.Errorf("error reading 'appDetectionInfos': %w", err)
		}
		delete(object, "appDetectionInfos")
	}

	if raw, found := object["atsssCapab"]; found {
		err = json.Unmarshal(raw, &a.AtsssCapab)
		if err != nil {
			return fmt.Errorf("error reading 'atsssCapab': %w", err)
		}
		delete(object, "atsssCapab")
	}

	if raw, found := object["authProfIndex"]; found {
		err = json.Unmarshal(raw, &a.AuthProfIndex)
		if err != nil {
			return fmt.Errorf("error reading 'authProfIndex': %w", err)
		}
		delete(object, "authProfIndex")
	}

	if raw, found := object["creditManageStatus"]; found {
		err = json.Unmarshal(raw, &a.CreditManageStatus)
		if err != nil {
			return fmt.Errorf("error reading 'creditManageStatus': %w", err)
		}
		delete(object, "creditManageStatus")
	}

	if raw, found := object["interGrpIds"]; found {
		err = json.Unmarshal(raw, &a.InterGrpIds)
		if err != nil {
			return fmt.Errorf("error reading 'interGrpIds': %w", err)
		}
		delete(object, "interGrpIds")
	}

	if raw, found := object["ipDomain"]; found {
		err = json.Unmarshal(raw, &a.IpDomain)
		if err != nil {
			return fmt.Errorf("error reading 'ipDomain': %w", err)
		}
		delete(object, "ipDomain")
	}

	if raw, found := object["ipv4Address"]; found {
		err = json.Unmarshal(raw, &a.Ipv4Address)
		if err != nil {
			return fmt.Errorf("error reading 'ipv4Address': %w", err)
		}
		delete(object, "ipv4Address")
	}

	if raw, found := object["ipv6AddressPrefix"]; found {
		err = json.Unmarshal(raw, &a.Ipv6AddressPrefix)
		if err != nil {
			return fmt.Errorf("error reading 'ipv6AddressPrefix': %w", err)
		}
		delete(object, "ipv6AddressPrefix")
	}

	if raw, found := object["maPduInd"]; found {
		err = json.Unmarshal(raw, &a.MaPduInd)
		if err != nil {
			return fmt.Errorf("error reading 'maPduInd': %w", err)
		}
		delete(object, "maPduInd")
	}

	if raw, found := object["mulAddrInfos"]; found {
		err = json.Unmarshal(raw, &a.MulAddrInfos)
		if err != nil {
			return fmt.Errorf("error reading 'mulAddrInfos': %w", err)
		}
		delete(object, "mulAddrInfos")
	}

	if raw, found := object["numOfPackFilter"]; found {
		err = json.Unmarshal(raw, &a.NumOfPackFilter)
		if err != nil {
			return fmt.Errorf("error reading 'numOfPackFilter': %w", err)
		}
		delete(object, "numOfPackFilter")
	}

	if raw, found := object["pccRuleId"]; found {
		err = json.Unmarshal(raw, &a.PccRuleId)
		if err != nil {
			return fmt.Errorf("error reading 'pccRuleId': %w", err)
		}
		delete(object, "pccRuleId")
	}

	if raw, found := object["policyDecFailureReports"]; found {
		err = json.Unmarshal(raw, &a.PolicyDecFailureReports)
		if err != nil {
			return fmt.Errorf("error reading 'policyDecFailureReports': %w", err)
		}
		delete(object, "policyDecFailureReports")
	}

	if raw, found := object["qncReports"]; found {
		err = json.Unmarshal(raw, &a.QncReports)
		if err != nil {
			return fmt.Errorf("error reading 'qncReports': %w", err)
		}
		delete(object, "qncReports")
	}

	if raw, found := object["qosFlowUsage"]; found {
		err = json.Unmarshal(raw, &a.QosFlowUsage)
		if err != nil {
			return fmt.Errorf("error reading 'qosFlowUsage': %w", err)
		}
		delete(object, "qosFlowUsage")
	}

	if raw, found := object["qosMonReports"]; found {
		err = json.Unmarshal(raw, &a.QosMonReports)
		if err != nil {
			return fmt.Errorf("error reading 'qosMonReports': %w", err)
		}
		delete(object, "qosMonReports")
	}

	if raw, found := object["ratType"]; found {
		err = json.Unmarshal(raw, &a.RatType)
		if err != nil {
			return fmt.Errorf("error reading 'ratType': %w", err)
		}
		delete(object, "ratType")
	}

	if raw, found := object["refQosIndication"]; found {
		err = json.Unmarshal(raw, &a.RefQosIndication)
		if err != nil {
			return fmt.Errorf("error reading 'refQosIndication': %w", err)
		}
		delete(object, "refQosIndication")
	}

	if raw, found := object["relAccessInfo"]; found {
		err = json.Unmarshal(raw, &a.RelAccessInfo)
		if err != nil {
			return fmt.Errorf("error reading 'relAccessInfo': %w", err)
		}
		delete(object, "relAccessInfo")
	}

	if raw, found := object["relIpv4Address"]; found {
		err = json.Unmarshal(raw, &a.RelIpv4Address)
		if err != nil {
			return fmt.Errorf("error reading 'relIpv4Address': %w", err)
		}
		delete(object, "relIpv4Address")
	}

	if raw, found := object["relIpv6AddressPrefix"]; found {
		err = json.Unmarshal(raw, &a.RelIpv6AddressPrefix)
		if err != nil {
			return fmt.Errorf("error reading 'relIpv6AddressPrefix': %w", err)
		}
		delete(object, "relIpv6AddressPrefix")
	}

	if raw, found := object["relUeMac"]; found {
		err = json.Unmarshal(raw, &a.RelUeMac)
		if err != nil {
			return fmt.Errorf("error reading 'relUeMac': %w", err)
		}
		delete(object, "relUeMac")
	}

	if raw, found := object["repPolicyCtrlReqTriggers"]; found {
		err = json.Unmarshal(raw, &a.RepPolicyCtrlReqTriggers)
		if err != nil {
			return fmt.Errorf("error reading 'repPolicyCtrlReqTriggers': %w", err)
		}
		delete(object, "repPolicyCtrlReqTriggers")
	}

	if raw, found := object["repPraInfos"]; found {
		err = json.Unmarshal(raw, &a.RepPraInfos)
		if err != nil {
			return fmt.Errorf("error reading 'repPraInfos': %w", err)
		}
		delete(object, "repPraInfos")
	}

	if raw, found := object["ruleReports"]; found {
		err = json.Unmarshal(raw, &a.RuleReports)
		if err != nil {
			return fmt.Errorf("error reading 'ruleReports': %w", err)
		}
		delete(object, "ruleReports")
	}

	if raw, found := object["servNfId"]; found {
		err = json.Unmarshal(raw, &a.ServNfId)
		if err != nil {
			return fmt.Errorf("error reading 'servNfId': %w", err)
		}
		delete(object, "servNfId")
	}

	if raw, found := object["servingNetwork"]; found {
		err = json.Unmarshal(raw, &a.ServingNetwork)
		if err != nil {
			return fmt.Errorf("error reading 'servingNetwork': %w", err)
		}
		delete(object, "servingNetwork")
	}

	if raw, found := object["sessRuleReports"]; found {
		err = json.Unmarshal(raw, &a.SessRuleReports)
		if err != nil {
			return fmt.Errorf("error reading 'sessRuleReports': %w", err)
		}
		delete(object, "sessRuleReports")
	}

	if raw, found := object["subsDefQos"]; found {
		err = json.Unmarshal(raw, &a.SubsDefQos)
		if err != nil {
			return fmt.Errorf("error reading 'subsDefQos': %w", err)
		}
		delete(object, "subsDefQos")
	}

	if raw, found := object["subsSessAmbr"]; found {
		err = json.Unmarshal(raw, &a.SubsSessAmbr)
		if err != nil {
			return fmt.Errorf("error reading 'subsSessAmbr': %w", err)
		}
		delete(object, "subsSessAmbr")
	}

	if raw, found := object["traceReq"]; found {
		err = json.Unmarshal(raw, &a.TraceReq)
		if err != nil {
			return fmt.Errorf("error reading 'traceReq': %w", err)
		}
		delete(object, "traceReq")
	}

	if raw, found := object["trafficDescriptors"]; found {
		err = json.Unmarshal(raw, &a.TrafficDescriptors)
		if err != nil {
			return fmt.Errorf("error reading 'trafficDescriptors': %w", err)
		}
		delete(object, "trafficDescriptors")
	}

	if raw, found := object["tsnBridgeInfo"]; found {
		err = json.Unmarshal(raw, &a.TsnBridgeInfo)
		if err != nil {
			return fmt.Errorf("error reading 'tsnBridgeInfo': %w", err)
		}
		delete(object, "tsnBridgeInfo")
	}

	if raw, found := object["tsnBridgeManCont"]; found {
		err = json.Unmarshal(raw, &a.TsnBridgeManCont)
		if err != nil {
			return fmt.Errorf("error reading 'tsnBridgeManCont': %w", err)
		}
		delete(object, "tsnBridgeManCont")
	}

	if raw, found := object["tsnPortManContDstt"]; found {
		err = json.Unmarshal(raw, &a.TsnPortManContDstt)
		if err != nil {
			return fmt.Errorf("error reading 'tsnPortManContDstt': %w", err)
		}
		delete(object, "tsnPortManContDstt")
	}

	if raw, found := object["tsnPortManContNwtts"]; found {
		err = json.Unmarshal(raw, &a.TsnPortManContNwtts)
		if err != nil {
			return fmt.Errorf("error reading 'tsnPortManContNwtts': %w", err)
		}
		delete(object, "tsnPortManContNwtts")
	}

	if raw, found := object["typesOfNotif"]; found {
		err = json.Unmarshal(raw, &a.TypesOfNotif)
		if err != nil {
			return fmt.Errorf("error reading 'typesOfNotif': %w", err)
		}
		delete(object, "typesOfNotif")
	}

	if raw, found := object["ueInitResReq"]; found {
		err = json.Unmarshal(raw, &a.UeInitResReq)
		if err != nil {
			return fmt.Errorf("error reading 'ueInitResReq': %w", err)
		}
		delete(object, "ueInitResReq")
	}

	if raw, found := object["ueMac"]; found {
		err = json.Unmarshal(raw, &a.UeMac)
		if err != nil {
			return fmt.Errorf("error reading 'ueMac': %w", err)
		}
		delete(object, "ueMac")
	}

	if raw, found := object["ueTimeZone"]; found {
		err = json.Unmarshal(raw, &a.UeTimeZone)
		if err != nil {
			return fmt.Errorf("error reading 'ueTimeZone': %w", err)
		}
		delete(object, "ueTimeZone")
	}

	if raw, found := object["userLocationInfo"]; found {
		err = json.Unmarshal(raw, &a.UserLocationInfo)
		if err != nil {
			return fmt.Errorf("error reading 'userLocationInfo': %w", err)
		}
		delete(object, "userLocationInfo")
	}

	if raw, found := object["userLocationInfoTime"]; found {
		err = json.Unmarshal(raw, &a.UserLocationInfoTime)
		if err != nil {
			return fmt.Errorf("error reading 'userLocationInfoTime': %w", err)
		}
		delete(object, "userLocationInfoTime")
	}

	if raw, found := object["vplmnQos"]; found {
		err = json.Unmarshal(raw, &a.VplmnQos)
		if err != nil {
			return fmt.Errorf("error reading 'vplmnQos': %w", err)
		}
		delete(object, "vplmnQos")
	}

	if raw, found := object["vplmnQosNotApp"]; found {
		err = json.Unmarshal(raw, &a.VplmnQosNotApp)
		if err != nil {
			return fmt.Errorf("error reading 'vplmnQosNotApp': %w", err)
		}
		delete(object, "vplmnQosNotApp")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SmPolicyUpdateContextData to handle AdditionalProperties
func (a SmPolicyUpdateContextData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.N3gppPsDataOffStatus != nil {
		object["3gppPsDataOffStatus"], err = json.Marshal(a.N3gppPsDataOffStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '3gppPsDataOffStatus': %w", err)
		}
	}

	if len(a.AccNetChIds) != 0 {
		object["accNetChIds"], err = json.Marshal(a.AccNetChIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accNetChIds': %w", err)
		}
	}

	if len(a.AccessType) != 0 {
		object["accessType"], err = json.Marshal(a.AccessType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accessType': %w", err)
		}
	}

	if len(a.AccuUsageReports) != 0 {
		object["accuUsageReports"], err = json.Marshal(a.AccuUsageReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accuUsageReports': %w", err)
		}
	}

	if a.AddAccessInfo != nil {
		object["addAccessInfo"], err = json.Marshal(a.AddAccessInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'addAccessInfo': %w", err)
		}
	}

	if a.AddIpv6AddrPrefixes != nil {
		object["addIpv6AddrPrefixes"], err = json.Marshal(a.AddIpv6AddrPrefixes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'addIpv6AddrPrefixes': %w", err)
		}
	}

	if a.AddRelIpv6AddrPrefixes != nil {
		object["addRelIpv6AddrPrefixes"], err = json.Marshal(a.AddRelIpv6AddrPrefixes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'addRelIpv6AddrPrefixes': %w", err)
		}
	}

	if len(a.AppDetectionInfos) != 0 {
		object["appDetectionInfos"], err = json.Marshal(a.AppDetectionInfos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'appDetectionInfos': %w", err)
		}
	}

	if a.AtsssCapab != nil {
		object["atsssCapab"], err = json.Marshal(a.AtsssCapab)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'atsssCapab': %w", err)
		}
	}

	if a.AuthProfIndex != nil {
		object["authProfIndex"], err = json.Marshal(a.AuthProfIndex)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'authProfIndex': %w", err)
		}
	}

	if a.CreditManageStatus != nil {
		object["creditManageStatus"], err = json.Marshal(a.CreditManageStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'creditManageStatus': %w", err)
		}
	}

	if len(a.InterGrpIds) != 0 {
		object["interGrpIds"], err = json.Marshal(a.InterGrpIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'interGrpIds': %w", err)
		}
	}

	if a.IpDomain != nil {
		object["ipDomain"], err = json.Marshal(a.IpDomain)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipDomain': %w", err)
		}
	}

	if len(a.Ipv4Address) != 0 {
		object["ipv4Address"], err = json.Marshal(a.Ipv4Address)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv4Address': %w", err)
		}
	}

	if a.Ipv6AddressPrefix != nil {
		object["ipv6AddressPrefix"], err = json.Marshal(a.Ipv6AddressPrefix)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ipv6AddressPrefix': %w", err)
		}
	}

	if a.MaPduInd != nil {
		object["maPduInd"], err = json.Marshal(a.MaPduInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'maPduInd': %w", err)
		}
	}

	if len(a.MulAddrInfos) != 0 {
		object["mulAddrInfos"], err = json.Marshal(a.MulAddrInfos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mulAddrInfos': %w", err)
		}
	}

	if a.NumOfPackFilter != nil {
		object["numOfPackFilter"], err = json.Marshal(a.NumOfPackFilter)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'numOfPackFilter': %w", err)
		}
	}

	if a.PccRuleId != nil {
		object["pccRuleId"], err = json.Marshal(a.PccRuleId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pccRuleId': %w", err)
		}
	}

	if len(a.PolicyDecFailureReports) != 0 {
		object["policyDecFailureReports"], err = json.Marshal(a.PolicyDecFailureReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'policyDecFailureReports': %w", err)
		}
	}

	if len(a.QncReports) != 0 {
		object["qncReports"], err = json.Marshal(a.QncReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'qncReports': %w", err)
		}
	}

	if a.QosFlowUsage != nil {
		object["qosFlowUsage"], err = json.Marshal(a.QosFlowUsage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'qosFlowUsage': %w", err)
		}
	}

	if len(a.QosMonReports) != 0 {
		object["qosMonReports"], err = json.Marshal(a.QosMonReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'qosMonReports': %w", err)
		}
	}

	if a.RatType != nil {
		object["ratType"], err = json.Marshal(a.RatType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ratType': %w", err)
		}
	}

	if a.RefQosIndication != nil {
		object["refQosIndication"], err = json.Marshal(a.RefQosIndication)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'refQosIndication': %w", err)
		}
	}

	if a.RelAccessInfo != nil {
		object["relAccessInfo"], err = json.Marshal(a.RelAccessInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relAccessInfo': %w", err)
		}
	}

	if len(a.RelIpv4Address) != 0 {
		object["relIpv4Address"], err = json.Marshal(a.RelIpv4Address)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relIpv4Address': %w", err)
		}
	}

	if a.RelIpv6AddressPrefix != nil {
		object["relIpv6AddressPrefix"], err = json.Marshal(a.RelIpv6AddressPrefix)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relIpv6AddressPrefix': %w", err)
		}
	}

	if len(a.RelUeMac) != 0 {
		object["relUeMac"], err = json.Marshal(a.RelUeMac)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relUeMac': %w", err)
		}
	}

	if len(a.RepPolicyCtrlReqTriggers) != 0 {
		object["repPolicyCtrlReqTriggers"], err = json.Marshal(a.RepPolicyCtrlReqTriggers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'repPolicyCtrlReqTriggers': %w", err)
		}
	}

	if a.RepPraInfos != nil {
		object["repPraInfos"], err = json.Marshal(a.RepPraInfos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'repPraInfos': %w", err)
		}
	}

	if len(a.RuleReports) != 0 {
		object["ruleReports"], err = json.Marshal(a.RuleReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ruleReports': %w", err)
		}
	}

	if a.ServNfId != nil {
		object["servNfId"], err = json.Marshal(a.ServNfId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servNfId': %w", err)
		}
	}

	if a.ServingNetwork != nil {
		object["servingNetwork"], err = json.Marshal(a.ServingNetwork)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingNetwork': %w", err)
		}
	}

	if len(a.SessRuleReports) != 0 {
		object["sessRuleReports"], err = json.Marshal(a.SessRuleReports)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sessRuleReports': %w", err)
		}
	}

	if a.SubsDefQos != nil {
		object["subsDefQos"], err = json.Marshal(a.SubsDefQos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subsDefQos': %w", err)
		}
	}

	if a.SubsSessAmbr != nil {
		object["subsSessAmbr"], err = json.Marshal(a.SubsSessAmbr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subsSessAmbr': %w", err)
		}
	}

	object["traceReq"], err = json.Marshal(a.TraceReq)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'traceReq': %w", err)
	}

	if len(a.TrafficDescriptors) != 0 {
		object["trafficDescriptors"], err = json.Marshal(a.TrafficDescriptors)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'trafficDescriptors': %w", err)
		}
	}

	if a.TsnBridgeInfo != nil {
		object["tsnBridgeInfo"], err = json.Marshal(a.TsnBridgeInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsnBridgeInfo': %w", err)
		}
	}

	if a.TsnBridgeManCont != nil {
		object["tsnBridgeManCont"], err = json.Marshal(a.TsnBridgeManCont)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsnBridgeManCont': %w", err)
		}
	}

	if a.TsnPortManContDstt != nil {
		object["tsnPortManContDstt"], err = json.Marshal(a.TsnPortManContDstt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsnPortManContDstt': %w", err)
		}
	}

	if len(a.TsnPortManContNwtts) != 0 {
		object["tsnPortManContNwtts"], err = json.Marshal(a.TsnPortManContNwtts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsnPortManContNwtts': %w", err)
		}
	}

	if len(a.TypesOfNotif) != 0 {
		object["typesOfNotif"], err = json.Marshal(a.TypesOfNotif)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'typesOfNotif': %w", err)
		}
	}

	if a.UeInitResReq != nil {
		object["ueInitResReq"], err = json.Marshal(a.UeInitResReq)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ueInitResReq': %w", err)
		}
	}

	if len(a.UeMac) != 0 {
		object["ueMac"], err = json.Marshal(a.UeMac)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ueMac': %w", err)
		}
	}

	if a.UeTimeZone != nil {
		object["ueTimeZone"], err = json.Marshal(a.UeTimeZone)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ueTimeZone': %w", err)
		}
	}

	if a.UserLocationInfo != nil {
		object["userLocationInfo"], err = json.Marshal(a.UserLocationInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'userLocationInfo': %w", err)
		}
	}

	if a.UserLocationInfoTime != nil {
		object["userLocationInfoTime"], err = json.Marshal(a.UserLocationInfoTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'userLocationInfoTime': %w", err)
		}
	}

	if a.VplmnQos != nil {
		object["vplmnQos"], err = json.Marshal(a.VplmnQos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vplmnQos': %w", err)
		}
	}

	if a.VplmnQosNotApp != nil {
		object["vplmnQosNotApp"], err = json.Marshal(a.VplmnQosNotApp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vplmnQosNotApp': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for SteeringMode. Returns the specified
// element and whether it was found
func (a SteeringMode) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SteeringMode
func (a *SteeringMode) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SteeringMode to handle AdditionalProperties
func (a *SteeringMode) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["3gLoad"]; found {
		err = json.Unmarshal(raw, &a.N3gLoad)
		if err != nil {
			return fmt.Errorf("error reading '3gLoad': %w", err)
		}
		delete(object, "3gLoad")
	}

	if raw, found := object["active"]; found {
		err = json.Unmarshal(raw, &a.Active)
		if err != nil {
			return fmt.Errorf("error reading 'active': %w", err)
		}
		delete(object, "active")
	}

	if raw, found := object["prioAcc"]; found {
		err = json.Unmarshal(raw, &a.PrioAcc)
		if err != nil {
			return fmt.Errorf("error reading 'prioAcc': %w", err)
		}
		delete(object, "prioAcc")
	}

	if raw, found := object["standby"]; found {
		err = json.Unmarshal(raw, &a.Standby)
		if err != nil {
			return fmt.Errorf("error reading 'standby': %w", err)
		}
		delete(object, "standby")
	}

	if raw, found := object["steerModeValue"]; found {
		err = json.Unmarshal(raw, &a.SteerModeValue)
		if err != nil {
			return fmt.Errorf("error reading 'steerModeValue': %w", err)
		}
		delete(object, "steerModeValue")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SteeringMode to handle AdditionalProperties
func (a SteeringMode) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.N3gLoad != nil {
		object["3gLoad"], err = json.Marshal(a.N3gLoad)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '3gLoad': %w", err)
		}
	}

	if len(a.Active) != 0 {
		object["active"], err = json.Marshal(a.Active)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'active': %w", err)
		}
	}

	if len(a.PrioAcc) != 0 {
		object["prioAcc"], err = json.Marshal(a.PrioAcc)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'prioAcc': %w", err)
		}
	}

	if len(a.Standby) != 0 {
		object["standby"], err = json.Marshal(a.Standby)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'standby': %w", err)
		}
	}

	object["steerModeValue"], err = json.Marshal(a.SteerModeValue)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'steerModeValue': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TerminationNotification. Returns the specified
// element and whether it was found
func (a TerminationNotification) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TerminationNotification
func (a *TerminationNotification) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TerminationNotification to handle AdditionalProperties
func (a *TerminationNotification) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cause"]; found {
		err = json.Unmarshal(raw, &a.Cause)
		if err != nil {
			return fmt.Errorf("error reading 'cause': %w", err)
		}
		delete(object, "cause")
	}

	if raw, found := object["resourceUri"]; found {
		err = json.Unmarshal(raw, &a.ResourceUri)
		if err != nil {
			return fmt.Errorf("error reading 'resourceUri': %w", err)
		}
		delete(object, "resourceUri")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TerminationNotification to handle AdditionalProperties
func (a TerminationNotification) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["cause"], err = json.Marshal(a.Cause)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'cause': %w", err)
	}

	object["resourceUri"], err = json.Marshal(a.ResourceUri)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'resourceUri': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TrafficControlData. Returns the specified
// element and whether it was found
func (a TrafficControlData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TrafficControlData
func (a *TrafficControlData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TrafficControlData to handle AdditionalProperties
func (a *TrafficControlData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["addRedirectInfo"]; found {
		err = json.Unmarshal(raw, &a.AddRedirectInfo)
		if err != nil {
			return fmt.Errorf("error reading 'addRedirectInfo': %w", err)
		}
		delete(object, "addRedirectInfo")
	}

	if raw, found := object["flowStatus"]; found {
		err = json.Unmarshal(raw, &a.FlowStatus)
		if err != nil {
			return fmt.Errorf("error reading 'flowStatus': %w", err)
		}
		delete(object, "flowStatus")
	}

	if raw, found := object["mulAccCtrl"]; found {
		err = json.Unmarshal(raw, &a.MulAccCtrl)
		if err != nil {
			return fmt.Errorf("error reading 'mulAccCtrl': %w", err)
		}
		delete(object, "mulAccCtrl")
	}

	if raw, found := object["muteNotif"]; found {
		err = json.Unmarshal(raw, &a.MuteNotif)
		if err != nil {
			return fmt.Errorf("error reading 'muteNotif': %w", err)
		}
		delete(object, "muteNotif")
	}

	if raw, found := object["redirectInfo"]; found {
		err = json.Unmarshal(raw, &a.RedirectInfo)
		if err != nil {
			return fmt.Errorf("error reading 'redirectInfo': %w", err)
		}
		delete(object, "redirectInfo")
	}

	if raw, found := object["routeToLocs"]; found {
		err = json.Unmarshal(raw, &a.RouteToLocs)
		if err != nil {
			return fmt.Errorf("error reading 'routeToLocs': %w", err)
		}
		delete(object, "routeToLocs")
	}

	if raw, found := object["steerFun"]; found {
		err = json.Unmarshal(raw, &a.SteerFun)
		if err != nil {
			return fmt.Errorf("error reading 'steerFun': %w", err)
		}
		delete(object, "steerFun")
	}

	if raw, found := object["steerModeDl"]; found {
		err = json.Unmarshal(raw, &a.SteerModeDl)
		if err != nil {
			return fmt.Errorf("error reading 'steerModeDl': %w", err)
		}
		delete(object, "steerModeDl")
	}

	if raw, found := object["steerModeUl"]; found {
		err = json.Unmarshal(raw, &a.SteerModeUl)
		if err != nil {
			return fmt.Errorf("error reading 'steerModeUl': %w", err)
		}
		delete(object, "steerModeUl")
	}

	if raw, found := object["tcId"]; found {
		err = json.Unmarshal(raw, &a.TcId)
		if err != nil {
			return fmt.Errorf("error reading 'tcId': %w", err)
		}
		delete(object, "tcId")
	}

	if raw, found := object["traffCorreInd"]; found {
		err = json.Unmarshal(raw, &a.TraffCorreInd)
		if err != nil {
			return fmt.Errorf("error reading 'traffCorreInd': %w", err)
		}
		delete(object, "traffCorreInd")
	}

	if raw, found := object["trafficSteeringPolIdDl"]; found {
		err = json.Unmarshal(raw, &a.TrafficSteeringPolIdDl)
		if err != nil {
			return fmt.Errorf("error reading 'trafficSteeringPolIdDl': %w", err)
		}
		delete(object, "trafficSteeringPolIdDl")
	}

	if raw, found := object["trafficSteeringPolIdUl"]; found {
		err = json.Unmarshal(raw, &a.TrafficSteeringPolIdUl)
		if err != nil {
			return fmt.Errorf("error reading 'trafficSteeringPolIdUl': %w", err)
		}
		delete(object, "trafficSteeringPolIdUl")
	}

	if raw, found := object["upPathChgEvent"]; found {
		err = json.Unmarshal(raw, &a.UpPathChgEvent)
		if err != nil {
			return fmt.Errorf("error reading 'upPathChgEvent': %w", err)
		}
		delete(object, "upPathChgEvent")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TrafficControlData to handle AdditionalProperties
func (a TrafficControlData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AddRedirectInfo) != 0 {
		object["addRedirectInfo"], err = json.Marshal(a.AddRedirectInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'addRedirectInfo': %w", err)
		}
	}

	if a.FlowStatus != nil {
		object["flowStatus"], err = json.Marshal(a.FlowStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'flowStatus': %w", err)
		}
	}

	if a.MulAccCtrl != nil {
		object["mulAccCtrl"], err = json.Marshal(a.MulAccCtrl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mulAccCtrl': %w", err)
		}
	}

	if a.MuteNotif != nil {
		object["muteNotif"], err = json.Marshal(a.MuteNotif)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'muteNotif': %w", err)
		}
	}

	if a.RedirectInfo != nil {
		object["redirectInfo"], err = json.Marshal(a.RedirectInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'redirectInfo': %w", err)
		}
	}

	if len(a.RouteToLocs) != 0 {
		object["routeToLocs"], err = json.Marshal(a.RouteToLocs)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'routeToLocs': %w", err)
		}
	}

	if a.SteerFun != nil {
		object["steerFun"], err = json.Marshal(a.SteerFun)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'steerFun': %w", err)
		}
	}

	if a.SteerModeDl != nil {
		object["steerModeDl"], err = json.Marshal(a.SteerModeDl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'steerModeDl': %w", err)
		}
	}

	if a.SteerModeUl != nil {
		object["steerModeUl"], err = json.Marshal(a.SteerModeUl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'steerModeUl': %w", err)
		}
	}

	object["tcId"], err = json.Marshal(a.TcId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'tcId': %w", err)
	}

	if a.TraffCorreInd != nil {
		object["traffCorreInd"], err = json.Marshal(a.TraffCorreInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'traffCorreInd': %w", err)
		}
	}

	object["trafficSteeringPolIdDl"], err = json.Marshal(a.TrafficSteeringPolIdDl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trafficSteeringPolIdDl': %w", err)
	}

	object["trafficSteeringPolIdUl"], err = json.Marshal(a.TrafficSteeringPolIdUl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'trafficSteeringPolIdUl': %w", err)
	}

	object["upPathChgEvent"], err = json.Marshal(a.UpPathChgEvent)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'upPathChgEvent': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TsnBridgeInfo. Returns the specified
// element and whether it was found
func (a TsnBridgeInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TsnBridgeInfo
func (a *TsnBridgeInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TsnBridgeInfo to handle AdditionalProperties
func (a *TsnBridgeInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["bridgeId"]; found {
		err = json.Unmarshal(raw, &a.BridgeId)
		if err != nil {
			return fmt.Errorf("error reading 'bridgeId': %w", err)
		}
		delete(object, "bridgeId")
	}

	if raw, found := object["dsttAddr"]; found {
		err = json.Unmarshal(raw, &a.DsttAddr)
		if err != nil {
			return fmt.Errorf("error reading 'dsttAddr': %w", err)
		}
		delete(object, "dsttAddr")
	}

	if raw, found := object["dsttPortNum"]; found {
		err = json.Unmarshal(raw, &a.DsttPortNum)
		if err != nil {
			return fmt.Errorf("error reading 'dsttPortNum': %w", err)
		}
		delete(object, "dsttPortNum")
	}

	if raw, found := object["dsttResidTime"]; found {
		err = json.Unmarshal(raw, &a.DsttResidTime)
		if err != nil {
			return fmt.Errorf("error reading 'dsttResidTime': %w", err)
		}
		delete(object, "dsttResidTime")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TsnBridgeInfo to handle AdditionalProperties
func (a TsnBridgeInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.BridgeId != nil {
		object["bridgeId"], err = json.Marshal(a.BridgeId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'bridgeId': %w", err)
		}
	}

	if len(a.DsttAddr) != 0 {
		object["dsttAddr"], err = json.Marshal(a.DsttAddr)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dsttAddr': %w", err)
		}
	}

	if a.DsttPortNum != nil {
		object["dsttPortNum"], err = json.Marshal(a.DsttPortNum)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dsttPortNum': %w", err)
		}
	}

	if a.DsttResidTime != nil {
		object["dsttResidTime"], err = json.Marshal(a.DsttResidTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dsttResidTime': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UeCampingRep. Returns the specified
// element and whether it was found
func (a UeCampingRep) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UeCampingRep
func (a *UeCampingRep) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UeCampingRep to handle AdditionalProperties
func (a *UeCampingRep) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accessType"]; found {
		err = json.Unmarshal(raw, &a.AccessType)
		if err != nil {
			return fmt.Errorf("error reading 'accessType': %w", err)
		}
		delete(object, "accessType")
	}

	if raw, found := object["netLocAccSupp"]; found {
		err = json.Unmarshal(raw, &a.NetLocAccSupp)
		if err != nil {
			return fmt.Errorf("error reading 'netLocAccSupp': %w", err)
		}
		delete(object, "netLocAccSupp")
	}

	if raw, found := object["ratType"]; found {
		err = json.Unmarshal(raw, &a.RatType)
		if err != nil {
			return fmt.Errorf("error reading 'ratType': %w", err)
		}
		delete(object, "ratType")
	}

	if raw, found := object["servNfId"]; found {
		err = json.Unmarshal(raw, &a.ServNfId)
		if err != nil {
			return fmt.Errorf("error reading 'servNfId': %w", err)
		}
		delete(object, "servNfId")
	}

	if raw, found := object["servingNetwork"]; found {
		err = json.Unmarshal(raw, &a.ServingNetwork)
		if err != nil {
			return fmt.Errorf("error reading 'servingNetwork': %w", err)
		}
		delete(object, "servingNetwork")
	}

	if raw, found := object["ueTimeZone"]; found {
		err = json.Unmarshal(raw, &a.UeTimeZone)
		if err != nil {
			return fmt.Errorf("error reading 'ueTimeZone': %w", err)
		}
		delete(object, "ueTimeZone")
	}

	if raw, found := object["userLocationInfo"]; found {
		err = json.Unmarshal(raw, &a.UserLocationInfo)
		if err != nil {
			return fmt.Errorf("error reading 'userLocationInfo': %w", err)
		}
		delete(object, "userLocationInfo")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UeCampingRep to handle AdditionalProperties
func (a UeCampingRep) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if len(a.AccessType) != 0 {
		object["accessType"], err = json.Marshal(a.AccessType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accessType': %w", err)
		}
	}

	if a.NetLocAccSupp != nil {
		object["netLocAccSupp"], err = json.Marshal(a.NetLocAccSupp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'netLocAccSupp': %w", err)
		}
	}

	if a.RatType != nil {
		object["ratType"], err = json.Marshal(a.RatType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ratType': %w", err)
		}
	}

	if a.ServNfId != nil {
		object["servNfId"], err = json.Marshal(a.ServNfId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servNfId': %w", err)
		}
	}

	if a.ServingNetwork != nil {
		object["servingNetwork"], err = json.Marshal(a.ServingNetwork)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'servingNetwork': %w", err)
		}
	}

	if a.UeTimeZone != nil {
		object["ueTimeZone"], err = json.Marshal(a.UeTimeZone)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ueTimeZone': %w", err)
		}
	}

	if a.UserLocationInfo != nil {
		object["userLocationInfo"], err = json.Marshal(a.UserLocationInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'userLocationInfo': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UeInitiatedResourceRequest. Returns the specified
// element and whether it was found
func (a UeInitiatedResourceRequest) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UeInitiatedResourceRequest
func (a *UeInitiatedResourceRequest) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UeInitiatedResourceRequest to handle AdditionalProperties
func (a *UeInitiatedResourceRequest) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["packFiltInfo"]; found {
		err = json.Unmarshal(raw, &a.PackFiltInfo)
		if err != nil {
			return fmt.Errorf("error reading 'packFiltInfo': %w", err)
		}
		delete(object, "packFiltInfo")
	}

	if raw, found := object["pccRuleId"]; found {
		err = json.Unmarshal(raw, &a.PccRuleId)
		if err != nil {
			return fmt.Errorf("error reading 'pccRuleId': %w", err)
		}
		delete(object, "pccRuleId")
	}

	if raw, found := object["precedence"]; found {
		err = json.Unmarshal(raw, &a.Precedence)
		if err != nil {
			return fmt.Errorf("error reading 'precedence': %w", err)
		}
		delete(object, "precedence")
	}

	if raw, found := object["reqQos"]; found {
		err = json.Unmarshal(raw, &a.ReqQos)
		if err != nil {
			return fmt.Errorf("error reading 'reqQos': %w", err)
		}
		delete(object, "reqQos")
	}

	if raw, found := object["ruleOp"]; found {
		err = json.Unmarshal(raw, &a.RuleOp)
		if err != nil {
			return fmt.Errorf("error reading 'ruleOp': %w", err)
		}
		delete(object, "ruleOp")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UeInitiatedResourceRequest to handle AdditionalProperties
func (a UeInitiatedResourceRequest) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["packFiltInfo"], err = json.Marshal(a.PackFiltInfo)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'packFiltInfo': %w", err)
	}

	if a.PccRuleId != nil {
		object["pccRuleId"], err = json.Marshal(a.PccRuleId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pccRuleId': %w", err)
		}
	}

	if a.Precedence != nil {
		object["precedence"], err = json.Marshal(a.Precedence)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'precedence': %w", err)
		}
	}

	if a.ReqQos != nil {
		object["reqQos"], err = json.Marshal(a.ReqQos)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'reqQos': %w", err)
		}
	}

	object["ruleOp"], err = json.Marshal(a.RuleOp)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'ruleOp': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpPathChgEvent. Returns the specified
// element and whether it was found
func (a UpPathChgEvent) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpPathChgEvent
func (a *UpPathChgEvent) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpPathChgEvent to handle AdditionalProperties
func (a *UpPathChgEvent) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["afAckInd"]; found {
		err = json.Unmarshal(raw, &a.AfAckInd)
		if err != nil {
			return fmt.Errorf("error reading 'afAckInd': %w", err)
		}
		delete(object, "afAckInd")
	}

	if raw, found := object["dnaiChgType"]; found {
		err = json.Unmarshal(raw, &a.DnaiChgType)
		if err != nil {
			return fmt.Errorf("error reading 'dnaiChgType': %w", err)
		}
		delete(object, "dnaiChgType")
	}

	if raw, found := object["notifCorreId"]; found {
		err = json.Unmarshal(raw, &a.NotifCorreId)
		if err != nil {
			return fmt.Errorf("error reading 'notifCorreId': %w", err)
		}
		delete(object, "notifCorreId")
	}

	if raw, found := object["notificationUri"]; found {
		err = json.Unmarshal(raw, &a.NotificationUri)
		if err != nil {
			return fmt.Errorf("error reading 'notificationUri': %w", err)
		}
		delete(object, "notificationUri")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpPathChgEvent to handle AdditionalProperties
func (a UpPathChgEvent) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AfAckInd != nil {
		object["afAckInd"], err = json.Marshal(a.AfAckInd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'afAckInd': %w", err)
		}
	}

	object["dnaiChgType"], err = json.Marshal(a.DnaiChgType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'dnaiChgType': %w", err)
	}

	object["notifCorreId"], err = json.Marshal(a.NotifCorreId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'notifCorreId': %w", err)
	}

	object["notificationUri"], err = json.Marshal(a.NotificationUri)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'notificationUri': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UsageMonitoringData. Returns the specified
// element and whether it was found
func (a UsageMonitoringData) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UsageMonitoringData
func (a *UsageMonitoringData) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UsageMonitoringData to handle AdditionalProperties
func (a *UsageMonitoringData) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["exUsagePccRuleIds"]; found {
		err = json.Unmarshal(raw, &a.ExUsagePccRuleIds)
		if err != nil {
			return fmt.Errorf("error reading 'exUsagePccRuleIds': %w", err)
		}
		delete(object, "exUsagePccRuleIds")
	}

	if raw, found := object["inactivityTime"]; found {
		err = json.Unmarshal(raw, &a.InactivityTime)
		if err != nil {
			return fmt.Errorf("error reading 'inactivityTime': %w", err)
		}
		delete(object, "inactivityTime")
	}

	if raw, found := object["monitoringTime"]; found {
		err = json.Unmarshal(raw, &a.MonitoringTime)
		if err != nil {
			return fmt.Errorf("error reading 'monitoringTime': %w", err)
		}
		delete(object, "monitoringTime")
	}

	if raw, found := object["nextTimeThreshold"]; found {
		err = json.Unmarshal(raw, &a.NextTimeThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'nextTimeThreshold': %w", err)
		}
		delete(object, "nextTimeThreshold")
	}

	if raw, found := object["nextVolThreshold"]; found {
		err = json.Unmarshal(raw, &a.NextVolThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'nextVolThreshold': %w", err)
		}
		delete(object, "nextVolThreshold")
	}

	if raw, found := object["nextVolThresholdDownlink"]; found {
		err = json.Unmarshal(raw, &a.NextVolThresholdDownlink)
		if err != nil {
			return fmt.Errorf("error reading 'nextVolThresholdDownlink': %w", err)
		}
		delete(object, "nextVolThresholdDownlink")
	}

	if raw, found := object["nextVolThresholdUplink"]; found {
		err = json.Unmarshal(raw, &a.NextVolThresholdUplink)
		if err != nil {
			return fmt.Errorf("error reading 'nextVolThresholdUplink': %w", err)
		}
		delete(object, "nextVolThresholdUplink")
	}

	if raw, found := object["timeThreshold"]; found {
		err = json.Unmarshal(raw, &a.TimeThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'timeThreshold': %w", err)
		}
		delete(object, "timeThreshold")
	}

	if raw, found := object["umId"]; found {
		err = json.Unmarshal(raw, &a.UmId)
		if err != nil {
			return fmt.Errorf("error reading 'umId': %w", err)
		}
		delete(object, "umId")
	}

	if raw, found := object["volumeThreshold"]; found {
		err = json.Unmarshal(raw, &a.VolumeThreshold)
		if err != nil {
			return fmt.Errorf("error reading 'volumeThreshold': %w", err)
		}
		delete(object, "volumeThreshold")
	}

	if raw, found := object["volumeThresholdDownlink"]; found {
		err = json.Unmarshal(raw, &a.VolumeThresholdDownlink)
		if err != nil {
			return fmt.Errorf("error reading 'volumeThresholdDownlink': %w", err)
		}
		delete(object, "volumeThresholdDownlink")
	}

	if raw, found := object["volumeThresholdUplink"]; found {
		err = json.Unmarshal(raw, &a.VolumeThresholdUplink)
		if err != nil {
			return fmt.Errorf("error reading 'volumeThresholdUplink': %w", err)
		}
		delete(object, "volumeThresholdUplink")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UsageMonitoringData to handle AdditionalProperties
func (a UsageMonitoringData) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["exUsagePccRuleIds"], err = json.Marshal(a.ExUsagePccRuleIds)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'exUsagePccRuleIds': %w", err)
	}

	object["inactivityTime"], err = json.Marshal(a.InactivityTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'inactivityTime': %w", err)
	}

	object["monitoringTime"], err = json.Marshal(a.MonitoringTime)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'monitoringTime': %w", err)
	}

	object["nextTimeThreshold"], err = json.Marshal(a.NextTimeThreshold)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nextTimeThreshold': %w", err)
	}

	object["nextVolThreshold"], err = json.Marshal(a.NextVolThreshold)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nextVolThreshold': %w", err)
	}

	object["nextVolThresholdDownlink"], err = json.Marshal(a.NextVolThresholdDownlink)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nextVolThresholdDownlink': %w", err)
	}

	object["nextVolThresholdUplink"], err = json.Marshal(a.NextVolThresholdUplink)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'nextVolThresholdUplink': %w", err)
	}

	object["timeThreshold"], err = json.Marshal(a.TimeThreshold)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'timeThreshold': %w", err)
	}

	object["umId"], err = json.Marshal(a.UmId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'umId': %w", err)
	}

	object["volumeThreshold"], err = json.Marshal(a.VolumeThreshold)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'volumeThreshold': %w", err)
	}

	object["volumeThresholdDownlink"], err = json.Marshal(a.VolumeThresholdDownlink)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'volumeThresholdDownlink': %w", err)
	}

	object["volumeThresholdUplink"], err = json.Marshal(a.VolumeThresholdUplink)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'volumeThresholdUplink': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsAfSigProtocol0 returns the union data inside the AfSigProtocol as a AfSigProtocol0
func (t AfSigProtocol) AsAfSigProtocol0() (AfSigProtocol0, error) {
	var body AfSigProtocol0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAfSigProtocol0 overwrites any union data inside the AfSigProtocol as the provided AfSigProtocol0
func (t *AfSigProtocol) FromAfSigProtocol0(v AfSigProtocol0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAfSigProtocol0 performs a merge with any union data inside the AfSigProtocol, using the provided AfSigProtocol0
func (t *AfSigProtocol) MergeAfSigProtocol0(v AfSigProtocol0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalRef0NullValue returns the union data inside the AfSigProtocol as a externalRef0.NullValue
func (t AfSigProtocol) AsExternalRef0NullValue() (externalRef0.NullValue, error) {
	var body externalRef0.NullValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalRef0NullValue overwrites any union data inside the AfSigProtocol as the provided externalRef0.NullValue
func (t *AfSigProtocol) FromExternalRef0NullValue(v externalRef0.NullValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalRef0NullValue performs a merge with any union data inside the AfSigProtocol, using the provided externalRef0.NullValue
func (t *AfSigProtocol) MergeExternalRef0NullValue(v externalRef0.NullValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAfSigProtocol2 returns the union data inside the AfSigProtocol as a AfSigProtocol2
func (t AfSigProtocol) AsAfSigProtocol2() (AfSigProtocol2, error) {
	var body AfSigProtocol2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAfSigProtocol2 overwrites any union data inside the AfSigProtocol as the provided AfSigProtocol2
func (t *AfSigProtocol) FromAfSigProtocol2(v AfSigProtocol2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAfSigProtocol2 performs a merge with any union data inside the AfSigProtocol, using the provided AfSigProtocol2
func (t *AfSigProtocol) MergeAfSigProtocol2(v AfSigProtocol2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AfSigProtocol) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AfSigProtocol) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMeteringMethod0 returns the union data inside the MeteringMethod as a MeteringMethod0
func (t MeteringMethod) AsMeteringMethod0() (MeteringMethod0, error) {
	var body MeteringMethod0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeteringMethod0 overwrites any union data inside the MeteringMethod as the provided MeteringMethod0
func (t *MeteringMethod) FromMeteringMethod0(v MeteringMethod0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeteringMethod0 performs a merge with any union data inside the MeteringMethod, using the provided MeteringMethod0
func (t *MeteringMethod) MergeMeteringMethod0(v MeteringMethod0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalRef0NullValue returns the union data inside the MeteringMethod as a externalRef0.NullValue
func (t MeteringMethod) AsExternalRef0NullValue() (externalRef0.NullValue, error) {
	var body externalRef0.NullValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalRef0NullValue overwrites any union data inside the MeteringMethod as the provided externalRef0.NullValue
func (t *MeteringMethod) FromExternalRef0NullValue(v externalRef0.NullValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalRef0NullValue performs a merge with any union data inside the MeteringMethod, using the provided externalRef0.NullValue
func (t *MeteringMethod) MergeExternalRef0NullValue(v externalRef0.NullValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMeteringMethod2 returns the union data inside the MeteringMethod as a MeteringMethod2
func (t MeteringMethod) AsMeteringMethod2() (MeteringMethod2, error) {
	var body MeteringMethod2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeteringMethod2 overwrites any union data inside the MeteringMethod as the provided MeteringMethod2
func (t *MeteringMethod) FromMeteringMethod2(v MeteringMethod2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeteringMethod2 performs a merge with any union data inside the MeteringMethod, using the provided MeteringMethod2
func (t *MeteringMethod) MergeMeteringMethod2(v MeteringMethod2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t MeteringMethod) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MeteringMethod) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReportingLevel0 returns the union data inside the ReportingLevel as a ReportingLevel0
func (t ReportingLevel) AsReportingLevel0() (ReportingLevel0, error) {
	var body ReportingLevel0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReportingLevel0 overwrites any union data inside the ReportingLevel as the provided ReportingLevel0
func (t *ReportingLevel) FromReportingLevel0(v ReportingLevel0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReportingLevel0 performs a merge with any union data inside the ReportingLevel, using the provided ReportingLevel0
func (t *ReportingLevel) MergeReportingLevel0(v ReportingLevel0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalRef0NullValue returns the union data inside the ReportingLevel as a externalRef0.NullValue
func (t ReportingLevel) AsExternalRef0NullValue() (externalRef0.NullValue, error) {
	var body externalRef0.NullValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalRef0NullValue overwrites any union data inside the ReportingLevel as the provided externalRef0.NullValue
func (t *ReportingLevel) FromExternalRef0NullValue(v externalRef0.NullValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalRef0NullValue performs a merge with any union data inside the ReportingLevel, using the provided externalRef0.NullValue
func (t *ReportingLevel) MergeExternalRef0NullValue(v externalRef0.NullValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsReportingLevel2 returns the union data inside the ReportingLevel as a ReportingLevel2
func (t ReportingLevel) AsReportingLevel2() (ReportingLevel2, error) {
	var body ReportingLevel2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReportingLevel2 overwrites any union data inside the ReportingLevel as the provided ReportingLevel2
func (t *ReportingLevel) FromReportingLevel2(v ReportingLevel2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReportingLevel2 performs a merge with any union data inside the ReportingLevel, using the provided ReportingLevel2
func (t *ReportingLevel) MergeReportingLevel2(v ReportingLevel2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReportingLevel) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReportingLevel) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateSMPolicyWithBody request with any body
	CreateSMPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSMPolicy(ctx context.Context, body CreateSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSMPolicy request
	GetSMPolicy(ctx context.Context, smPolicyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSMPolicyWithBody request with any body
	DeleteSMPolicyWithBody(ctx context.Context, smPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteSMPolicy(ctx context.Context, smPolicyId string, body DeleteSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSMPolicyWithBody request with any body
	UpdateSMPolicyWithBody(ctx context.Context, smPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSMPolicy(ctx context.Context, smPolicyId string, body UpdateSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateSMPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSMPolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSMPolicy(ctx context.Context, body CreateSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSMPolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSMPolicy(ctx context.Context, smPolicyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSMPolicyRequest(c.Server, smPolicyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSMPolicyWithBody(ctx context.Context, smPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSMPolicyRequestWithBody(c.Server, smPolicyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSMPolicy(ctx context.Context, smPolicyId string, body DeleteSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSMPolicyRequest(c.Server, smPolicyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSMPolicyWithBody(ctx context.Context, smPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSMPolicyRequestWithBody(c.Server, smPolicyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSMPolicy(ctx context.Context, smPolicyId string, body UpdateSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSMPolicyRequest(c.Server, smPolicyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateSMPolicyRequest calls the generic CreateSMPolicy builder with application/json body
func NewCreateSMPolicyRequest(server string, body CreateSMPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSMPolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSMPolicyRequestWithBody generates requests for CreateSMPolicy with any type of body
func NewCreateSMPolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sm-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSMPolicyRequest generates requests for GetSMPolicy
func NewGetSMPolicyRequest(server string, smPolicyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "smPolicyId", runtime.ParamLocationPath, smPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sm-policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSMPolicyRequest calls the generic DeleteSMPolicy builder with application/json body
func NewDeleteSMPolicyRequest(server string, smPolicyId string, body DeleteSMPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteSMPolicyRequestWithBody(server, smPolicyId, "application/json", bodyReader)
}

// NewDeleteSMPolicyRequestWithBody generates requests for DeleteSMPolicy with any type of body
func NewDeleteSMPolicyRequestWithBody(server string, smPolicyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "smPolicyId", runtime.ParamLocationPath, smPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sm-policies/%s/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSMPolicyRequest calls the generic UpdateSMPolicy builder with application/json body
func NewUpdateSMPolicyRequest(server string, smPolicyId string, body UpdateSMPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSMPolicyRequestWithBody(server, smPolicyId, "application/json", bodyReader)
}

// NewUpdateSMPolicyRequestWithBody generates requests for UpdateSMPolicy with any type of body
func NewUpdateSMPolicyRequestWithBody(server string, smPolicyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "smPolicyId", runtime.ParamLocationPath, smPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sm-policies/%s/update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateSMPolicyWithBodyWithResponse request with any body
	CreateSMPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSMPolicyResponse, error)

	CreateSMPolicyWithResponse(ctx context.Context, body CreateSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSMPolicyResponse, error)

	// GetSMPolicyWithResponse request
	GetSMPolicyWithResponse(ctx context.Context, smPolicyId string, reqEditors ...RequestEditorFn) (*GetSMPolicyResponse, error)

	// DeleteSMPolicyWithBodyWithResponse request with any body
	DeleteSMPolicyWithBodyWithResponse(ctx context.Context, smPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSMPolicyResponse, error)

	DeleteSMPolicyWithResponse(ctx context.Context, smPolicyId string, body DeleteSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSMPolicyResponse, error)

	// UpdateSMPolicyWithBodyWithResponse request with any body
	UpdateSMPolicyWithBodyWithResponse(ctx context.Context, smPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSMPolicyResponse, error)

	UpdateSMPolicyWithResponse(ctx context.Context, smPolicyId string, body UpdateSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSMPolicyResponse, error)
}

type CreateSMPolicyResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON201                       *SmPolicyDecision
	ApplicationproblemJSON400     *externalRef0.N400
	ApplicationproblemJSON401     *externalRef0.N401
	ApplicationproblemJSON403     *externalRef0.N403
	ApplicationproblemJSON411     *externalRef0.N411
	ApplicationproblemJSON413     *externalRef0.N413
	ApplicationproblemJSON415     *externalRef0.N415
	ApplicationproblemJSON429     *externalRef0.N429
	ApplicationproblemJSON500     *externalRef0.N500
	ApplicationproblemJSON503     *externalRef0.N503
	ApplicationproblemJSONDefault *externalRef0.Default
}

// Status returns HTTPResponse.Status
func (r CreateSMPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSMPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSMPolicyResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *SmPolicyControl
	JSON307                       *externalRef0.N307
	JSON308                       *externalRef0.N308
	ApplicationproblemJSON400     *externalRef0.N400
	ApplicationproblemJSON401     *externalRef0.N401
	ApplicationproblemJSON403     *externalRef0.N403
	ApplicationproblemJSON404     *externalRef0.N404
	ApplicationproblemJSON429     *externalRef0.N429
	ApplicationproblemJSON500     *externalRef0.N500
	ApplicationproblemJSON503     *externalRef0.N503
	ApplicationproblemJSONDefault *externalRef0.Default
}

// Status returns HTTPResponse.Status
func (r GetSMPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSMPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSMPolicyResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON307                       *externalRef0.N307
	JSON308                       *externalRef0.N308
	ApplicationproblemJSON400     *externalRef0.N400
	ApplicationproblemJSON401     *externalRef0.N401
	ApplicationproblemJSON403     *externalRef0.N403
	ApplicationproblemJSON404     *externalRef0.N404
	ApplicationproblemJSON411     *externalRef0.N411
	ApplicationproblemJSON413     *externalRef0.N413
	ApplicationproblemJSON415     *externalRef0.N415
	ApplicationproblemJSON429     *externalRef0.N429
	ApplicationproblemJSON500     *externalRef0.N500
	ApplicationproblemJSON503     *externalRef0.N503
	ApplicationproblemJSONDefault *externalRef0.Default
}

// Status returns HTTPResponse.Status
func (r DeleteSMPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSMPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSMPolicyResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *SmPolicyDecision
	JSON307                       *externalRef0.N307
	JSON308                       *externalRef0.N308
	ApplicationproblemJSON400     *externalRef0.N400
	ApplicationproblemJSON401     *externalRef0.N401
	ApplicationproblemJSON403     *externalRef0.N403
	ApplicationproblemJSON404     *externalRef0.N404
	ApplicationproblemJSON411     *externalRef0.N411
	ApplicationproblemJSON413     *externalRef0.N413
	ApplicationproblemJSON415     *externalRef0.N415
	ApplicationproblemJSON429     *externalRef0.N429
	ApplicationproblemJSON500     *externalRef0.N500
	ApplicationproblemJSON503     *externalRef0.N503
	ApplicationproblemJSONDefault *externalRef0.Default
}

// Status returns HTTPResponse.Status
func (r UpdateSMPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSMPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateSMPolicyWithBodyWithResponse request with arbitrary body returning *CreateSMPolicyResponse
func (c *ClientWithResponses) CreateSMPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSMPolicyResponse, error) {
	rsp, err := c.CreateSMPolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSMPolicyResponse(rsp)
}

func (c *ClientWithResponses) CreateSMPolicyWithResponse(ctx context.Context, body CreateSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSMPolicyResponse, error) {
	rsp, err := c.CreateSMPolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSMPolicyResponse(rsp)
}

// GetSMPolicyWithResponse request returning *GetSMPolicyResponse
func (c *ClientWithResponses) GetSMPolicyWithResponse(ctx context.Context, smPolicyId string, reqEditors ...RequestEditorFn) (*GetSMPolicyResponse, error) {
	rsp, err := c.GetSMPolicy(ctx, smPolicyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSMPolicyResponse(rsp)
}

// DeleteSMPolicyWithBodyWithResponse request with arbitrary body returning *DeleteSMPolicyResponse
func (c *ClientWithResponses) DeleteSMPolicyWithBodyWithResponse(ctx context.Context, smPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteSMPolicyResponse, error) {
	rsp, err := c.DeleteSMPolicyWithBody(ctx, smPolicyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSMPolicyResponse(rsp)
}

func (c *ClientWithResponses) DeleteSMPolicyWithResponse(ctx context.Context, smPolicyId string, body DeleteSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteSMPolicyResponse, error) {
	rsp, err := c.DeleteSMPolicy(ctx, smPolicyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSMPolicyResponse(rsp)
}

// UpdateSMPolicyWithBodyWithResponse request with arbitrary body returning *UpdateSMPolicyResponse
func (c *ClientWithResponses) UpdateSMPolicyWithBodyWithResponse(ctx context.Context, smPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSMPolicyResponse, error) {
	rsp, err := c.UpdateSMPolicyWithBody(ctx, smPolicyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSMPolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdateSMPolicyWithResponse(ctx context.Context, smPolicyId string, body UpdateSMPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSMPolicyResponse, error) {
	rsp, err := c.UpdateSMPolicy(ctx, smPolicyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSMPolicyResponse(rsp)
}

// ParseCreateSMPolicyResponse parses an HTTP response from a CreateSMPolicyWithResponse call
func ParseCreateSMPolicyResponse(rsp *http.Response) (*CreateSMPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSMPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SmPolicyDecision
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case rsp.StatusCode == 308:
		break // No content-type

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case rsp.StatusCode == 404:
		break // No content-type

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.Default
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetSMPolicyResponse parses an HTTP response from a GetSMPolicyWithResponse call
func ParseGetSMPolicyResponse(rsp *http.Response) (*GetSMPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSMPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmPolicyControl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.N307
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.N308
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case rsp.StatusCode == 406:
		break // No content-type

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.Default
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSMPolicyResponse parses an HTTP response from a DeleteSMPolicyWithResponse call
func ParseDeleteSMPolicyResponse(rsp *http.Response) (*DeleteSMPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSMPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.StatusCode == 204:
		break // No content-type

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.N307
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.N308
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.Default
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSMPolicyResponse parses an HTTP response from a UpdateSMPolicyWithResponse call
func ParseUpdateSMPolicyResponse(rsp *http.Response) (*UpdateSMPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSMPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmPolicyDecision
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest externalRef0.N307
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 308:
		var dest externalRef0.N308
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON308 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 411:
		var dest externalRef0.N411
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON411 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest externalRef0.N413
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest externalRef0.N415
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest externalRef0.N429
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest externalRef0.N503
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest externalRef0.Default
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Create a new Individual SM Policy
	// (POST /sm-policies)
	CreateSMPolicy(c *gin.Context)
	// Read an Individual SM Policy
	// (GET /sm-policies/{smPolicyId})
	GetSMPolicy(c *gin.Context, smPolicyId string)
	// Delete an existing Individual SM Policy
	// (POST /sm-policies/{smPolicyId}/delete)
	DeleteSMPolicy(c *gin.Context, smPolicyId string)
	// Update an existing Individual SM Policy
	// (POST /sm-policies/{smPolicyId}/update)
	UpdateSMPolicy(c *gin.Context, smPolicyId string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// CreateSMPolicy operation middleware
func (siw *ServerInterfaceWrapper) CreateSMPolicy(c *gin.Context) {

	c.Set(OAuth2ClientcredentialsScopes, []string{"npcf-smpolicycontrol"})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateSMPolicy(c)
}

// GetSMPolicy operation middleware
func (siw *ServerInterfaceWrapper) GetSMPolicy(c *gin.Context) {

	var err error

	// ------------- Path parameter "smPolicyId" -------------
	var smPolicyId string

	err = runtime.BindStyledParameter("simple", false, "smPolicyId", c.Param("smPolicyId"), &smPolicyId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter smPolicyId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientcredentialsScopes, []string{"npcf-smpolicycontrol"})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSMPolicy(c, smPolicyId)
}

// DeleteSMPolicy operation middleware
func (siw *ServerInterfaceWrapper) DeleteSMPolicy(c *gin.Context) {

	var err error

	// ------------- Path parameter "smPolicyId" -------------
	var smPolicyId string

	err = runtime.BindStyledParameter("simple", false, "smPolicyId", c.Param("smPolicyId"), &smPolicyId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter smPolicyId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientcredentialsScopes, []string{"npcf-smpolicycontrol"})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteSMPolicy(c, smPolicyId)
}

// UpdateSMPolicy operation middleware
func (siw *ServerInterfaceWrapper) UpdateSMPolicy(c *gin.Context) {

	var err error

	// ------------- Path parameter "smPolicyId" -------------
	var smPolicyId string

	err = runtime.BindStyledParameter("simple", false, "smPolicyId", c.Param("smPolicyId"), &smPolicyId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter smPolicyId: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(OAuth2ClientcredentialsScopes, []string{"npcf-smpolicycontrol"})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateSMPolicy(c, smPolicyId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/sm-policies", wrapper.CreateSMPolicy)
	router.GET(options.BaseURL+"/sm-policies/:smPolicyId", wrapper.GetSMPolicy)
	router.POST(options.BaseURL+"/sm-policies/:smPolicyId/delete", wrapper.DeleteSMPolicy)
	router.POST(options.BaseURL+"/sm-policies/:smPolicyId/update", wrapper.UpdateSMPolicy)
}

type CreateSMPolicyRequestObject struct {
	Body *CreateSMPolicyJSONRequestBody
}

type CreateSMPolicyResponseObject interface {
	VisitCreateSMPolicyResponse(w http.ResponseWriter) error
}

type CreateSMPolicy201ResponseHeaders struct {
	Location string
}

type CreateSMPolicy201JSONResponse struct {
	Body    SmPolicyDecision
	Headers CreateSMPolicy201ResponseHeaders
}

func (response CreateSMPolicy201JSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response.Body)
}

type CreateSMPolicy308ResponseHeaders struct {
	Location string
}

type CreateSMPolicy308Response struct {
	Headers CreateSMPolicy308ResponseHeaders
}

func (response CreateSMPolicy308Response) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)
	return nil
}

type CreateSMPolicy400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response CreateSMPolicy400ApplicationProblemPlusJSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N400ApplicationProblemPlusJSONResponse))
}

type CreateSMPolicy401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response CreateSMPolicy401ApplicationProblemPlusJSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N401ApplicationProblemPlusJSONResponse))
}

type CreateSMPolicy403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response CreateSMPolicy403ApplicationProblemPlusJSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N403ApplicationProblemPlusJSONResponse))
}

type CreateSMPolicy404Response struct {
}

func (response CreateSMPolicy404Response) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type CreateSMPolicy411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response CreateSMPolicy411ApplicationProblemPlusJSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N411ApplicationProblemPlusJSONResponse))
}

type CreateSMPolicy413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response CreateSMPolicy413ApplicationProblemPlusJSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N413ApplicationProblemPlusJSONResponse))
}

type CreateSMPolicy415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response CreateSMPolicy415ApplicationProblemPlusJSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N415ApplicationProblemPlusJSONResponse))
}

type CreateSMPolicy429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response CreateSMPolicy429ApplicationProblemPlusJSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N429ApplicationProblemPlusJSONResponse))
}

type CreateSMPolicy500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response CreateSMPolicy500ApplicationProblemPlusJSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N500ApplicationProblemPlusJSONResponse))
}

type CreateSMPolicy503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response CreateSMPolicy503ApplicationProblemPlusJSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N503ApplicationProblemPlusJSONResponse))
}

type CreateSMPolicydefaultApplicationProblemPlusJSONResponse struct {
	Body       externalRef0.ProblemDetails
	StatusCode int
}

func (response CreateSMPolicydefaultApplicationProblemPlusJSONResponse) VisitCreateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetSMPolicyRequestObject struct {
	SmPolicyId string `json:"smPolicyId"`
}

type GetSMPolicyResponseObject interface {
	VisitGetSMPolicyResponse(w http.ResponseWriter) error
}

type GetSMPolicy200JSONResponse SmPolicyControl

func (response GetSMPolicy200JSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(SmPolicyControl(response))
}

type GetSMPolicy307JSONResponse struct{ externalRef0.N307JSONResponse }

func (response GetSMPolicy307JSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("3gpp-Sbi-Target-Nf-Id", fmt.Sprint(response.Headers.N3gppSbiTargetNfId))
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetSMPolicy308JSONResponse struct{ externalRef0.N308JSONResponse }

func (response GetSMPolicy308JSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("3gpp-Sbi-Target-Nf-Id", fmt.Sprint(response.Headers.N3gppSbiTargetNfId))
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetSMPolicy400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response GetSMPolicy400ApplicationProblemPlusJSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N400ApplicationProblemPlusJSONResponse))
}

type GetSMPolicy401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response GetSMPolicy401ApplicationProblemPlusJSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N401ApplicationProblemPlusJSONResponse))
}

type GetSMPolicy403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response GetSMPolicy403ApplicationProblemPlusJSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N403ApplicationProblemPlusJSONResponse))
}

type GetSMPolicy404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response GetSMPolicy404ApplicationProblemPlusJSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N404ApplicationProblemPlusJSONResponse))
}

type GetSMPolicy406Response externalRef0.N406Response

func (response GetSMPolicy406Response) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.WriteHeader(406)
	return nil
}

type GetSMPolicy429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response GetSMPolicy429ApplicationProblemPlusJSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N429ApplicationProblemPlusJSONResponse))
}

type GetSMPolicy500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response GetSMPolicy500ApplicationProblemPlusJSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N500ApplicationProblemPlusJSONResponse))
}

type GetSMPolicy503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response GetSMPolicy503ApplicationProblemPlusJSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N503ApplicationProblemPlusJSONResponse))
}

type GetSMPolicydefaultApplicationProblemPlusJSONResponse struct {
	Body       externalRef0.ProblemDetails
	StatusCode int
}

func (response GetSMPolicydefaultApplicationProblemPlusJSONResponse) VisitGetSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteSMPolicyRequestObject struct {
	SmPolicyId string `json:"smPolicyId"`
	Body       *DeleteSMPolicyJSONRequestBody
}

type DeleteSMPolicyResponseObject interface {
	VisitDeleteSMPolicyResponse(w http.ResponseWriter) error
}

type DeleteSMPolicy204Response struct {
}

func (response DeleteSMPolicy204Response) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteSMPolicy307JSONResponse struct{ externalRef0.N307JSONResponse }

func (response DeleteSMPolicy307JSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("3gpp-Sbi-Target-Nf-Id", fmt.Sprint(response.Headers.N3gppSbiTargetNfId))
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteSMPolicy308JSONResponse struct{ externalRef0.N308JSONResponse }

func (response DeleteSMPolicy308JSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("3gpp-Sbi-Target-Nf-Id", fmt.Sprint(response.Headers.N3gppSbiTargetNfId))
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteSMPolicy400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response DeleteSMPolicy400ApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N400ApplicationProblemPlusJSONResponse))
}

type DeleteSMPolicy401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response DeleteSMPolicy401ApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N401ApplicationProblemPlusJSONResponse))
}

type DeleteSMPolicy403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response DeleteSMPolicy403ApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N403ApplicationProblemPlusJSONResponse))
}

type DeleteSMPolicy404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response DeleteSMPolicy404ApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N404ApplicationProblemPlusJSONResponse))
}

type DeleteSMPolicy411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response DeleteSMPolicy411ApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N411ApplicationProblemPlusJSONResponse))
}

type DeleteSMPolicy413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response DeleteSMPolicy413ApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N413ApplicationProblemPlusJSONResponse))
}

type DeleteSMPolicy415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response DeleteSMPolicy415ApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N415ApplicationProblemPlusJSONResponse))
}

type DeleteSMPolicy429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response DeleteSMPolicy429ApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N429ApplicationProblemPlusJSONResponse))
}

type DeleteSMPolicy500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response DeleteSMPolicy500ApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N500ApplicationProblemPlusJSONResponse))
}

type DeleteSMPolicy503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response DeleteSMPolicy503ApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N503ApplicationProblemPlusJSONResponse))
}

type DeleteSMPolicydefaultApplicationProblemPlusJSONResponse struct {
	Body       externalRef0.ProblemDetails
	StatusCode int
}

func (response DeleteSMPolicydefaultApplicationProblemPlusJSONResponse) VisitDeleteSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateSMPolicyRequestObject struct {
	SmPolicyId string `json:"smPolicyId"`
	Body       *UpdateSMPolicyJSONRequestBody
}

type UpdateSMPolicyResponseObject interface {
	VisitUpdateSMPolicyResponse(w http.ResponseWriter) error
}

type UpdateSMPolicy200JSONResponse SmPolicyDecision

func (response UpdateSMPolicy200JSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(SmPolicyDecision(response))
}

type UpdateSMPolicy307JSONResponse struct{ externalRef0.N307JSONResponse }

func (response UpdateSMPolicy307JSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("3gpp-Sbi-Target-Nf-Id", fmt.Sprint(response.Headers.N3gppSbiTargetNfId))
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(307)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateSMPolicy308JSONResponse struct{ externalRef0.N308JSONResponse }

func (response UpdateSMPolicy308JSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("3gpp-Sbi-Target-Nf-Id", fmt.Sprint(response.Headers.N3gppSbiTargetNfId))
	w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
	w.WriteHeader(308)

	return json.NewEncoder(w).Encode(response.Body)
}

type UpdateSMPolicy400ApplicationProblemPlusJSONResponse struct {
	externalRef0.N400ApplicationProblemPlusJSONResponse
}

func (response UpdateSMPolicy400ApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N400ApplicationProblemPlusJSONResponse))
}

type UpdateSMPolicy401ApplicationProblemPlusJSONResponse struct {
	externalRef0.N401ApplicationProblemPlusJSONResponse
}

func (response UpdateSMPolicy401ApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N401ApplicationProblemPlusJSONResponse))
}

type UpdateSMPolicy403ApplicationProblemPlusJSONResponse struct {
	externalRef0.N403ApplicationProblemPlusJSONResponse
}

func (response UpdateSMPolicy403ApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N403ApplicationProblemPlusJSONResponse))
}

type UpdateSMPolicy404ApplicationProblemPlusJSONResponse struct {
	externalRef0.N404ApplicationProblemPlusJSONResponse
}

func (response UpdateSMPolicy404ApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N404ApplicationProblemPlusJSONResponse))
}

type UpdateSMPolicy411ApplicationProblemPlusJSONResponse struct {
	externalRef0.N411ApplicationProblemPlusJSONResponse
}

func (response UpdateSMPolicy411ApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(411)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N411ApplicationProblemPlusJSONResponse))
}

type UpdateSMPolicy413ApplicationProblemPlusJSONResponse struct {
	externalRef0.N413ApplicationProblemPlusJSONResponse
}

func (response UpdateSMPolicy413ApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N413ApplicationProblemPlusJSONResponse))
}

type UpdateSMPolicy415ApplicationProblemPlusJSONResponse struct {
	externalRef0.N415ApplicationProblemPlusJSONResponse
}

func (response UpdateSMPolicy415ApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N415ApplicationProblemPlusJSONResponse))
}

type UpdateSMPolicy429ApplicationProblemPlusJSONResponse struct {
	externalRef0.N429ApplicationProblemPlusJSONResponse
}

func (response UpdateSMPolicy429ApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N429ApplicationProblemPlusJSONResponse))
}

type UpdateSMPolicy500ApplicationProblemPlusJSONResponse struct {
	externalRef0.N500ApplicationProblemPlusJSONResponse
}

func (response UpdateSMPolicy500ApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N500ApplicationProblemPlusJSONResponse))
}

type UpdateSMPolicy503ApplicationProblemPlusJSONResponse struct {
	externalRef0.N503ApplicationProblemPlusJSONResponse
}

func (response UpdateSMPolicy503ApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(503)

	return json.NewEncoder(w).Encode(externalRef0.ProblemDetails(response.N503ApplicationProblemPlusJSONResponse))
}

type UpdateSMPolicydefaultApplicationProblemPlusJSONResponse struct {
	Body       externalRef0.ProblemDetails
	StatusCode int
}

func (response UpdateSMPolicydefaultApplicationProblemPlusJSONResponse) VisitUpdateSMPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Create a new Individual SM Policy
	// (POST /sm-policies)
	CreateSMPolicy(ctx context.Context, request CreateSMPolicyRequestObject) (CreateSMPolicyResponseObject, error)
	// Read an Individual SM Policy
	// (GET /sm-policies/{smPolicyId})
	GetSMPolicy(ctx context.Context, request GetSMPolicyRequestObject) (GetSMPolicyResponseObject, error)
	// Delete an existing Individual SM Policy
	// (POST /sm-policies/{smPolicyId}/delete)
	DeleteSMPolicy(ctx context.Context, request DeleteSMPolicyRequestObject) (DeleteSMPolicyResponseObject, error)
	// Update an existing Individual SM Policy
	// (POST /sm-policies/{smPolicyId}/update)
	UpdateSMPolicy(ctx context.Context, request UpdateSMPolicyRequestObject) (UpdateSMPolicyResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// CreateSMPolicy operation middleware
func (sh *strictHandler) CreateSMPolicy(ctx *gin.Context) {
	var request CreateSMPolicyRequestObject

	var body CreateSMPolicyJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateSMPolicy(ctx, request.(CreateSMPolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateSMPolicy")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateSMPolicyResponseObject); ok {
		if err := validResponse.VisitCreateSMPolicyResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSMPolicy operation middleware
func (sh *strictHandler) GetSMPolicy(ctx *gin.Context, smPolicyId string) {
	var request GetSMPolicyRequestObject

	request.SmPolicyId = smPolicyId

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetSMPolicy(ctx, request.(GetSMPolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSMPolicy")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetSMPolicyResponseObject); ok {
		if err := validResponse.VisitGetSMPolicyResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteSMPolicy operation middleware
func (sh *strictHandler) DeleteSMPolicy(ctx *gin.Context, smPolicyId string) {
	var request DeleteSMPolicyRequestObject

	request.SmPolicyId = smPolicyId

	var body DeleteSMPolicyJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteSMPolicy(ctx, request.(DeleteSMPolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteSMPolicy")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteSMPolicyResponseObject); ok {
		if err := validResponse.VisitDeleteSMPolicyResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateSMPolicy operation middleware
func (sh *strictHandler) UpdateSMPolicy(ctx *gin.Context, smPolicyId string) {
	var request UpdateSMPolicyRequestObject

	request.SmPolicyId = smPolicyId

	var body UpdateSMPolicyJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateSMPolicy(ctx, request.(UpdateSMPolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateSMPolicy")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UpdateSMPolicyResponseObject); ok {
		if err := validResponse.VisitUpdateSMPolicyResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}
